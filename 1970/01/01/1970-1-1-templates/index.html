
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Kepp It Simple &amp;&amp; Stupid">
    <title>模版 - Kepp It Simple &amp;&amp; Stupid</title>
    <meta name="author" content="sillyplus">
    
    
        <link rel="alternative" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。
&amp;lt;!-- toc --&amp;gt;
树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475">
<meta property="og:type" content="blog">
<meta property="og:title" content="模版">
<meta property="og:url" content="http://github.com/sillyplus/1970/01/01/1970-1-1-templates/index.html">
<meta property="og:site_name" content="Kepp It Simple && Stupid">
<meta property="og:description" content="这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。
&amp;lt;!-- toc --&amp;gt;
树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475">
<meta property="og:updated_time" content="2015-10-28T01:31:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="模版">
<meta name="twitter:description" content="这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。
&amp;lt;!-- toc --&amp;gt;
树链剖分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475">
<meta name="twitter:creator" content="@sillycross">
    
        <meta rel="publisher" content="https://plus.google.com/dlxtxlb"/>
    
    
        
            <meta property="fb:admins" content="100005974902908" />
        
    
    
        <meta property="og:image" content="http://www.gravatar.com/avatar/b9c024fee19cd6eabae007b57eaf7e17?s=640"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style.min.css" type="text/css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-49870038-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="3">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <h1 class="header-title">
        <a class="header-title-link" href="/ ">Kepp It Simple &amp;&amp; Stupid</a>
    </h1>
    
        
            <a  class="header-right-picture "
                href="/#about">
        
        
            <img class="header-picture" src="http://www.gravatar.com/avatar/b9c024fee19cd6eabae007b57eaf7e17?s=90"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="3">
    
        <div class="sidebar-profile">
            <a href="/#about">
                    <img class="sidebar-profile-picture" src="http://www.gravatar.com/avatar/b9c024fee19cd6eabae007b57eaf7e17?s=110"/>
            </a>
            <span class="sidebar-profile-name">sillyplus</span>
        </div>
    
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/ "
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                    <span class="sidebar-button-desc">Home</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-categories"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                    <span class="sidebar-button-desc">Categories</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-tags"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                    <span class="sidebar-button-desc">Tags</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/all-archives"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                    <span class="sidebar-button-desc">Archives</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/#about"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-question"></i>
                    <span class="sidebar-button-desc">About</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="https://github.com/sillyplus" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                    <span class="sidebar-button-desc">GitHub</span>
                </a>
        </li>
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link " href="mailto:oi_boy@sina.cn" target="_blank">
                
                    <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                    <span class="sidebar-button-desc">Mail</span>
                </a>
        </li>
        
    </ul>
    
        <ul class="sidebar-buttons">
        
            <li class="sidebar-button">
                
                    <a  class="sidebar-button-link "
                         href="/atom.xml"
                        
                    >
                
                    <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
                    <span class="sidebar-button-desc">RSS</span>
                </a>
        </li>
        
    </ul>
    
</nav>

            
            <div id="main" data-behavior="3"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            模版
        </h1>
    
    <div class="post-meta">
    <time itemprop="datePublished" content="Thu Jan 01 1970 00:00:00 GMT+0800">
	
		    Jan 01, 1970
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/资源/">资源</a>


    
</div>
</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。</p>
<h1 id="table-of-contents">Table of Contents</h1><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#树链剖分"><span class="toc-text">树链剖分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ST表"><span class="toc-text">ST表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPFA"><span class="toc-text">SPFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拓扑排序"><span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tarjan"><span class="toc-text">Tarjan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tire"><span class="toc-text">Tire</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra"><span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Matching"><span class="toc-text">Matching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匈牙利算法"><span class="toc-text">匈牙利算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双联通分量"><span class="toc-text">双联通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆"><span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常系数线性齐次递推"><span class="toc-text">常系数线性齐次递推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#割点和桥"><span class="toc-text">割点和桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集"><span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高斯消元"><span class="toc-text">高斯消元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧几里德"><span class="toc-text">欧几里德</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展欧几里德"><span class="toc-text">扩展欧几里德</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高精度整数"><span class="toc-text">高精度整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#筛法求素数"><span class="toc-text">筛法求素数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#欧拉函数"><span class="toc-text">欧拉函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#前向星"><span class="toc-text">前向星</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段树"><span class="toc-text">线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵的逆"><span class="toc-text">矩阵的逆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LCA"><span class="toc-text">LCA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#矩阵类"><span class="toc-text">矩阵类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim算法"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal算法"><span class="toc-text">Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树状数组"><span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号判断"><span class="toc-text">符号判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维点类"><span class="toc-text">二维点类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线段类"><span class="toc-text">线段类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多边形类"><span class="toc-text">多边形类</span></a></li></ol>
<h3 id="树链剖分">树链剖分</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一颗树,将它划分成若干条互不相交的路径,满足:从节点u-&gt;v最多经过logN条路径以及logN条不在路径上的边.</span><br><span class="line">*</span><br><span class="line">*我们使用以下几个数组来描述剖分出来的路径:</span><br><span class="line">*Bolong<span class="comment">[v]</span> 		节点v所属的路径编号</span><br><span class="line">*Idx<span class="comment">[v]</span>			节点v在其路径中的编号,节点按深度由深到浅依次标号</span><br><span class="line">*Head<span class="comment">[p]</span>		编号为p的路径的顶端节点</span><br><span class="line">*Len<span class="comment">[p]</span> 		路径p的长度</span><br><span class="line">*Dep<span class="comment">[v]</span>			节点v的深度</span><br><span class="line">*Father<span class="comment">[v]</span>		节点v的父亲节点</span><br><span class="line">*Size<span class="comment">[v]</span>		以节点v为根的子树的节点个数</span><br><span class="line">*划分操作采用BFS以避免栈空间溢出.按照BFS的发现顺序逆序处理,对于每一个节点v,找到它的size最大的子节点u.如果u不存在,</span><br><span class="line">*那么给v分配一条新的路径,否则v就延续u所属的路径.</span><br><span class="line">*查询两个节点u,v之间的路径时,首先判断它们是否属于同一条路径.如果是则直接在这条路经上查询并返回,否则选择所属路径顶端</span><br><span class="line">*节点h的深度较大的节点(不妨设是v),查询v到h,并令v=father<span class="comment">[h]</span>继续查询,直到u,v属于同一条路径.</span><br><span class="line">*</span><br><span class="line">*void insert(int x, int y);</span><br><span class="line">*输入:		x,y			添加一条x到y的边</span><br><span class="line">*void split();</span><br><span class="line">*复杂度:		O(nlogn)</span><br><span class="line">*输入:		Prev		Prev<span class="comment">[i]</span>表示邻接表中,第i条边在链表中的下一条边</span><br><span class="line">*			info		info<span class="comment">[v]</span>表示邻接表中,从点v出发的边链表的头节点</span><br><span class="line">*输出:		Belong		Belong<span class="comment">[v]</span>表示节点v所属的路径编号</span><br><span class="line">*			Idx			Idx<span class="comment">[v]</span>表示节点v在其路径中的编号,按深度由深到浅依次标号</span><br><span class="line">*			Head		Head<span class="comment">[p]</span>表示编号为p的路径的顶端节点</span><br><span class="line">*			Len			Len<span class="comment">[p]</span>表示路径p的长度</span><br><span class="line">*			Dep			Dep<span class="comment">[v]</span>表示节点v的深度</span><br><span class="line">*			Father		Father<span class="comment">[v]</span>表示节点v的父亲节点</span><br><span class="line">*			Size		Size<span class="comment">[v]</span>表示以节点v为根的子树的节点个数</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const int maxn = 100000 + 5;</span><br><span class="line">const int maxm = maxn + maxn;</span><br><span class="line">int v<span class="comment">[maxm]</span>;</span><br><span class="line">int Prev<span class="comment">[maxm]</span>;</span><br><span class="line">int info<span class="comment">[maxn]</span>;</span><br><span class="line">int Q<span class="comment">[maxn]</span>;</span><br><span class="line">int idx<span class="comment">[maxn]</span>;</span><br><span class="line">int dep<span class="comment">[maxn]</span>;</span><br><span class="line">int size<span class="comment">[maxn]</span>;</span><br><span class="line">int belong<span class="comment">[maxn]</span>;</span><br><span class="line">int father<span class="comment">[maxn]</span>;</span><br><span class="line">bool vis<span class="comment">[maxn]</span>;</span><br><span class="line">int head<span class="comment">[maxn]</span>;</span><br><span class="line">int len<span class="comment">[maxn]</span>;</span><br><span class="line">int l, r, ans, cnt = 0;</span><br><span class="line">int N, nedge = 0;</span><br><span class="line"></span><br><span class="line">inline void insert(int x, int y) &#123;</span><br><span class="line">    nedge++;</span><br><span class="line">    v<span class="comment">[nedge]</span> = y;</span><br><span class="line">    Prev<span class="comment">[nedge]</span> = info<span class="comment">[x]</span>;</span><br><span class="line">    info<span class="comment">[x]</span> = nedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void split() &#123;</span><br><span class="line">    memset(dep, -1, sizeof(dep));</span><br><span class="line">    l = 0;</span><br><span class="line">    dep<span class="comment">[ Q<span class="comment">[ r=1 ]</span> =1 ]</span>=0;</span><br><span class="line">    father<span class="comment">[1]</span> = -1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int x = Q<span class="comment">[++l]</span>;</span><br><span class="line">        vis<span class="comment">[x]</span> = false;</span><br><span class="line">        for (int y = info<span class="comment">[x]</span>; y; y = Prev<span class="comment">[y]</span>)</span><br><span class="line">            if (dep<span class="comment">[v<span class="comment">[y]</span>]</span> == -1) &#123;</span><br><span class="line">                dep<span class="comment">[ Q<span class="comment">[++r]</span> = v<span class="comment">[y]</span> ]</span> = dep<span class="comment">[x]</span> = 1;</span><br><span class="line">                father<span class="comment">[v<span class="comment">[y]</span>]</span> = x;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = N; i; i--) &#123;</span><br><span class="line">        int x = Q<span class="comment">[i]</span>, p = -1;</span><br><span class="line">        size<span class="comment">[x]</span> = 1;</span><br><span class="line">        for (int y = info<span class="comment">[x]</span>; y; y = Prev<span class="comment">[y]</span>)</span><br><span class="line">            if (vis<span class="comment">[v<span class="comment">[y]</span>]</span>) &#123;</span><br><span class="line">                size<span class="comment">[x]</span> == size<span class="comment">[v<span class="comment">[y]</span>]</span>;</span><br><span class="line">                if (p == -1 || size<span class="comment">[v<span class="comment">[y]</span>]</span> &gt; size<span class="comment">[p]</span>)</span><br><span class="line">                    p = v<span class="comment">[y]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        if (p == -1) &#123;</span><br><span class="line">            idx<span class="comment">[x]</span> = len<span class="comment">[++cnt]</span> = 1;</span><br><span class="line">            belong<span class="comment">[head<span class="comment">[cnt]</span> = x]</span> = cnt;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            idx<span class="comment">[x]</span> = ++len<span class="comment">[belong<span class="comment">[x]</span> = belong<span class="comment">[p]</span>]</span>;</span><br><span class="line">            head<span class="comment">[belong<span class="comment">[x]</span>]</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        vis<span class="comment">[x]</span> = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用inset函数建图,然后点哟内split就可以完成剖分.点从1开始编号,并假设根节点是1.</span><br></pre></td></tr></table></figure>
<h3 id="ST表">ST表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一个数组A[n],动态查询数组元素A[l],A[l+1],...,A[r]的最小值。</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*我们首先使用O(nlogn)的时间预处理出数组st[<span class="link_label">i</span>][<span class="link_reference">j</span>],代表从A[i]开始连续2^j个元素中的最小值。</span><br><span class="line">*可以使用动态规划，状态转移方程如下:</span><br><span class="line"><span class="bullet">*    </span>边界条件为st[<span class="link_label">i</span>][<span class="link_reference">0</span>] = A[i]。</span><br><span class="line">*对于一个查询[L,R]，我们令k=floor(log(R-L+1))，那么[L,R]中的最小值就是</span><br><span class="line">*min(st[<span class="link_label">L</span>][<span class="link_reference">k</span>], st[<span class="link_label">R-2^i+1</span>][<span class="link_reference">k</span>])。</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span><span class="emphasis">*void st_prepare(int n, int *</span>array);</span><br><span class="line">*复杂度: O(nlogn)</span><br><span class="line">*输 入:  n        数组长度</span><br><span class="line"><span class="bullet">*       </span>array    数组</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int query_min(int l, int r);</span><br><span class="line">*复杂度: O(1)</span><br><span class="line">*输 入:  l,r    查询区间的两个端点</span><br><span class="line">*输 出:  A[l],A[l+1],...,A[r]的最小值</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*/</span><br><span class="line"></span><br><span class="line">const int MAX = 100000;</span><br><span class="line">int stTable[<span class="link_label">MAX</span>][<span class="link_reference">32</span>];</span><br><span class="line">int preLog2[MAX];</span><br><span class="line"></span><br><span class="line">void st_prepare(int n, int *array) &#123;</span><br><span class="line"><span class="code">    preLog2[1] = 0;</span></span><br><span class="line"><span class="code">    for (int i = 2; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="code">        preLog2[i] = preLog2[i-1];</span></span><br><span class="line"><span class="code">        if ((1 &lt;&lt; preLog2[i] + 1) == i) &#123;</span></span><br><span class="line"><span class="code">            ++preLog2[i];</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    for (int i = n-1; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="code">        stTable[i][0] = array[i];</span></span><br><span class="line"><span class="code">        for (int j = 1; (i + (1 &lt;&lt; j) - 1) &lt; n; j++) &#123;</span></span><br><span class="line"><span class="code">            stTable[i][j] = min(stTable[i][j-1], stTable[i+(1 &lt;&lt; j-1)][j-1]);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query_min(int l, int r) &#123;</span><br><span class="line"><span class="code">    int len = r - l + 1, k = preLog2[len];</span></span><br><span class="line"><span class="code">    return min(stTable[l][k], stTable[r - (1 &lt;&lt; k) + 1][k]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA">SPFA</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*用SPFA算法求单源最短路.</span><br><span class="line">*</span><br><span class="line">*SPFA其实是Bellman-Ford的队列优化.我们用数组dist记录每个结点的最短路径估计值,并用邻接表</span><br><span class="line">*来存储图g.我们采用的方法是松弛:设立一个先进先出的队列用来保持优化的结点,优化时每次取出</span><br><span class="line">*队首结点u,并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作,如果v点的最短</span><br><span class="line">*路径估计值有所调整,且v点不在当前队列中,就将v点放入队尾.这样不断从队列中取出结点来进行</span><br><span class="line">*松弛操作,直至队列空为止.</span><br><span class="line">*只要最短路存在,上述SPFA算法必定能求出最小值.因为每次将点放入队尾,都是经过松弛操作达到</span><br><span class="line">*的.换言之,每次的优化将会有某个点v的最短路径估计值d[v]变小.所以算法的执行会使d越来越小.</span><br><span class="line">*由于我们假定图中不存在负权回路,所以每个结点都有最短路径.因此,算法不会无限执行下去,随着</span><br><span class="line">*d值的逐渐变小,直到到达最短路径值时,算法结束,这时的最短路径估计值就是对应结点的最短路径</span><br><span class="line">*值.</span><br><span class="line">*</span><br><span class="line">*void spfa();</span><br><span class="line">*复杂度:	最坏情况O(|V|*|X|)</span><br><span class="line">*输  入:	n		全局变量,图的点数</span><br><span class="line">*			src		全局变量,表示源点</span><br><span class="line">*			g		全局变量,邻接表存储所有边</span><br><span class="line">*					g[i][j].first表示节点i的第j条边的节点编号</span><br><span class="line">*					g[i][j].second表示边的长度</span><br><span class="line">*输  出:	dist	全局变量,dist[i]表示源点src到i的最短距离</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int maxn = 1000;</span><br><span class="line"></span><br><span class="line">int <span class="keyword">n</span>, <span class="keyword">m</span>, src;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; <span class="keyword">g</span>[maxn + 10];</span><br><span class="line"></span><br><span class="line">int dist[maxn + 10];</span><br><span class="line">bool inQue[maxn + 10];</span><br><span class="line">queue&lt;int&gt; <span class="keyword">que</span>;</span><br><span class="line"></span><br><span class="line">void spfa() &#123;</span><br><span class="line">	memset(dist, 63, sizeof(dist));</span><br><span class="line">	dist[src] = 0;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="keyword">que</span>.empty()) <span class="keyword">que</span>.pop();</span><br><span class="line">	<span class="keyword">que</span>.push(src);</span><br><span class="line">	inQue[src] = true;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="keyword">que</span>.empty()) &#123;</span><br><span class="line">		int <span class="keyword">u</span> = <span class="keyword">que</span>.front();</span><br><span class="line">		<span class="keyword">que</span>.pop();</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">g</span>[<span class="keyword">u</span>].size(); i++)</span><br><span class="line">			<span class="keyword">if</span> (dist[<span class="keyword">u</span>] + <span class="keyword">g</span>[<span class="keyword">u</span>][i].second &lt; dist[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first]) &#123;</span><br><span class="line">				dist[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first] = dist[<span class="keyword">u</span>] + <span class="keyword">g</span>[<span class="keyword">u</span>][i].second;</span><br><span class="line">				<span class="keyword">if</span> (!inQue[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first]) &#123;</span><br><span class="line">					inQue[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first] = true;</span><br><span class="line">					<span class="keyword">que</span>.push(<span class="keyword">g</span>[<span class="keyword">u</span>][i].first);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		inQue[<span class="keyword">u</span>] = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序">拓扑排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*对一个有向无环图拓扑排序.</span><br><span class="line">*</span><br><span class="line">*用一个队列实现,先吧入度为0的点放入队列.然后考虑不断从图中删除队列中的点,每次删除</span><br><span class="line">*一个点会产生一些新的入度为0的点.把这些点插入队列.</span><br><span class="line">*</span><br><span class="line">*bool toposort();</span><br><span class="line">*复杂度: O(|V|+|E|)</span><br><span class="line">*输  入: n	全局变量,表示点数</span><br><span class="line">*        g	全局变量,g[i]表示从点i连出去的边</span><br><span class="line">*输  出: 返回对给定的图,是否可以拓扑排序</span><br><span class="line">*        L	全局变量,拓扑排序的结果</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, L[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span>(du));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++)</span><br><span class="line">			du[g[i][j]]++;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!du[i]) Q.push(i);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		L[tot++] = x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[x].size(); j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = g[x][j];</span><br><span class="line">			du[t]--;</span><br><span class="line">			<span class="keyword">if</span> (!du[t])</span><br><span class="line">				Q.push(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tot == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan">Tarjan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个有向图,找出图中的极大强联通分量,并将属于同一个强联通分量内的点染同样的颜色.</span><br><span class="line">*</span><br><span class="line">*dfn[i]记录的是节点i在深度优先遍历中的访问次序;</span><br><span class="line">*low[i]记录的是点i可以到达的访问时间最早的祖先;</span><br><span class="line">*Stack是记录节点的栈.</span><br><span class="line">*深度优先遍历整个图,一路上标记dfn并把新节点压入栈.对于一个节点i,如果它的dfn值与low值</span><br><span class="line">*相等,说明它无法到达它的任何一个祖先.而在栈里面i与i之后的点一定能够与i互达的(否则在</span><br><span class="line">*之前就会被弹出栈),所以i与栈里i之后的点形成了一个极大强联通分量.这一部分可以作为一个</span><br><span class="line">*整体弹出.</span><br><span class="line">*现在考虑low值的求法.这个可以根据定义来:如果点i访问一个新点j,那么j的low值i也一定能够</span><br><span class="line">*达到,可以用low[j]尝试更新low[i];如果点i访问一个祖先k,那么则直接用dfn[k]尝试更新low[i]</span><br><span class="line">*</span><br><span class="line">*strongly_connected_components(const vector&lt;pair&lt;int,int&gt; &gt; &amp;edgeList, int n, vector&lt;int&gt; &amp;ans);</span><br><span class="line">*复杂度:	O(|V|+|E|)</span><br><span class="line">*输  入:	&amp;edgList	图中所有的边,其中边用pair&lt;int, int&gt;表示</span><br><span class="line">*		  n  			图中点的数目</span><br><span class="line">*		  &amp;ans	  	染色结果</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> strongly_connected_components &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;color;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line">	<span class="keyword">int</span> colorCnt, curr, *instack, *dfn, *low, *info, *next, *to;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		dfn[x] = low[x] = ++curr;</span><br><span class="line">		Stack.push_back(x);</span><br><span class="line">		instack[x] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = info[x]; j; j = next[j])</span><br><span class="line">			<span class="keyword">if</span> (!instack[to[j]]) &#123;</span><br><span class="line">				dfs(to[j]);</span><br><span class="line">				low[x] = <span class="built_in">std</span>::min(low[x], low[to[j]]);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (instack[to[j]] == <span class="number">1</span>)</span><br><span class="line">					low[x] = <span class="built_in">std</span>::min(low[x], dfn[to[j]]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">			<span class="keyword">while</span> (Stack.back() != xs) &#123;</span><br><span class="line">				color[Stack.back()] = colorCnt;</span><br><span class="line">				instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">				Stack.pop_back();</span><br><span class="line">			&#125;</span><br><span class="line">			color[Stack.back()] = colorCnt++;</span><br><span class="line">			instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">			Stack.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strongly_connected_components(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &amp;edgeList,</span><br><span class="line">										<span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans): color(ans) &#123;</span><br><span class="line">		color.resize(n);</span><br><span class="line">		instack = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		dfn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		info = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		next = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edgeList.size() + <span class="number">5</span>];</span><br><span class="line">		to = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edgeList.size() + <span class="number">5</span>];</span><br><span class="line">		<span class="built_in">std</span>::fill_n(info, n, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edgeList.size(); i++) &#123;</span><br><span class="line">			to[i+<span class="number">1</span>] = edgeList[i].second;</span><br><span class="line">			next[i+<span class="number">1</span>] = info[edgeList[i].first];</span><br><span class="line">			info[edgeList[i].first] = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::fill_n(instack, n, <span class="number">0</span>);</span><br><span class="line">		colorCnt = <span class="number">0</span>;</span><br><span class="line">		curr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!instack[i]) &#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span>[] instack;</span><br><span class="line">		<span class="keyword">delete</span>[] dfn;</span><br><span class="line">		<span class="keyword">delete</span>[] low;</span><br><span class="line">		<span class="keyword">delete</span>[] info;</span><br><span class="line">		<span class="keyword">delete</span>[] next;</span><br><span class="line">		<span class="keyword">delete</span>[] to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Tire">Tire</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*设计一种数据结构,支持两种操作:插入一个字符串; 查询一个字符串是否存在.</span><br><span class="line">*</span><br><span class="line">*我们采用2个数组实现一个Trie树. child[i][j]代表以i为根的子树,字符j代表的边连向哪</span><br><span class="line">*一个节点(如果child[i][j] = 0, 则说明没有对应的节点).初始时根节点为1.flag[i]代表节点</span><br><span class="line">*i是否为一个单词的结尾.</span><br><span class="line">*插入时,我们从根节点沿着字符串的每个字符走向下一层节点,如果该节点不存在则分配一个</span><br><span class="line">*新节点.对于最后插入的节点i,我们令flag[i] = true.</span><br><span class="line">*查找和插入的过程基本相同,区别是:如果我们走到一个不存在的节点那么返回查找失败.</span><br><span class="line">*如果最后我们停留在某个节点i,那么返回flag[i]即可.</span><br><span class="line">*</span><br><span class="line">*结构体:	Trie</span><br><span class="line">*成员函数:</span><br><span class="line">*	void insert(cosnt char *str);	插入字符串str</span><br><span class="line">*	复杂度:		O(Length)</span><br><span class="line">*	bool query(const char *str):	查询字符串是否出现</span><br><span class="line">*	复杂度:		O(Length)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CHARSET为字符集的大小</span></span><br><span class="line"><span class="comment">//BASE为字符集ASCII最小字符</span></span><br><span class="line"><span class="comment">//MAX_NODE最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET = <span class="number">26</span>, BASE = <span class="string">'a'</span>, MAX_NODE = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> Trie &#123;</span><br><span class="line">	<span class="keyword">int</span> tot, root, child[MAX_NODE][CHARSET];</span><br><span class="line">	<span class="keyword">bool</span> flag[MAX_NODE];</span><br><span class="line">	Trie() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(child[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(child[<span class="number">1</span>]));</span><br><span class="line">		flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">		root = tot = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *cur = &amp;root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = str; *p; p++) &#123;</span><br><span class="line">			cur = &amp;child[*cur][*p-BASE];</span><br><span class="line">			<span class="keyword">if</span> (*cur == <span class="number">0</span>) &#123;</span><br><span class="line">				*cur = ++tot;</span><br><span class="line">				<span class="built_in">memset</span>(child[tot], <span class="number">0</span>, <span class="keyword">sizeof</span>(child[tot]));</span><br><span class="line">				flag[tot] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		flag[*cur] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *cur = &amp;root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = str; *p &amp;&amp; *cur; p++)</span><br><span class="line">			cur = &amp;child[*cur][*p-BASE];</span><br><span class="line">		<span class="keyword">return</span> (*cur &amp;&amp; flag[*cur]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra">Dijkstra</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*用Dijkstra算法求单源最短路.图中不能有负权的边.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*Dijkstra算法按从源点src到其他各点的最短路长度递增的顺序,依次确定src到每个点的最短路.</span><br><span class="line">*首先将dis[src]赋为0,其余各点赋为正无穷,此时所有点的最短路都还未确定.之后,每次在还未</span><br><span class="line">*确定最短路的点中,取一个当前已得的所有可能的路径长度中最短的那个点确定,设此点为mark.</span><br><span class="line">*然后对所有与mark相连的点进行松弛操作,即对于边(mark, v),判断dis[<span class="link_label">v</span>]是否大于dis[<span class="link_label">mark</span>]+g[<span class="link_label">mark</span>][<span class="link_reference">v</span>],</span><br><span class="line">*若是,则更新dis[<span class="link_label">v</span>]为dis[<span class="link_label">mark</span>]+g[<span class="link_label">mark</span>][<span class="link_reference">v</span>].如此做N遍后,即确定了src到所有N个点的最短距离.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*void dijksta();</span><br><span class="line">*复杂度:	O(N^2)</span><br><span class="line">*输  入:	N		全局变量,图中的点数</span><br><span class="line"><span class="bullet">*			</span>g		全局变量,g[<span class="link_label">i</span>][<span class="link_reference">j</span>]表示i到j之间边的距离</span><br><span class="line">*输  出:	dis		全局变量,dis[i]表示节点1到i的最短距离</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*/</span><br><span class="line"></span><br><span class="line">const int MN = 1000;</span><br><span class="line">int dis[<span class="link_label">MN</span>], g[<span class="link_label">MN</span>][<span class="link_reference">MN</span>], N;</span><br><span class="line">bool v[MN];</span><br><span class="line"></span><br><span class="line">void dijkstra() &#123;</span><br><span class="line"><span class="code">	for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line"><span class="code">		dis[i] = INF;</span></span><br><span class="line"><span class="code">	dis[1] = 0;</span></span><br><span class="line"><span class="code">	memset(v, 0, sizeof(v));</span></span><br><span class="line"><span class="code">	for (int i = 1; i &lt;= N; i++) &#123;</span></span><br><span class="line"><span class="code">		int mark = -1, mindis = INF;</span></span><br><span class="line"><span class="code">		for (int j = 1; j &lt;= N; j++)</span></span><br><span class="line"><span class="code">			if (!v[j] &amp;&amp; dis[j] &lt; mindis) &#123;</span></span><br><span class="line"><span class="code">				mindis = dis[j];</span></span><br><span class="line"><span class="code">				mark = j;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		v[mark] = 1;</span></span><br><span class="line"><span class="code">		for (int j = 1; j &lt;= N; j++)</span></span><br><span class="line"><span class="code">			if (!v[j])</span></span><br><span class="line"><span class="code">				dis[j] = min(dis[j], dis[mark] + g[mark][j]);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Matching">Matching</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    &gt; File Name: Matching.cpp</span><br><span class="line">    &gt; Author: sillyplus</span><br><span class="line">    &gt; Mail: oi_boy<span class="comment">@sina.cn</span></span><br><span class="line">    &gt; Created Time: Tue May 12 11:52:05 2015</span><br><span class="line"></span><br><span class="line">    给出一个无向图，求最大匹配。</span><br><span class="line"></span><br><span class="line">    不断在图中寻找路径增广，直到不存在增广路径。</span><br><span class="line"></span><br><span class="line">    在寻在路径的过程中，可能出现一个奇环，这时候把奇环收缩，成为一朵“花”，并在新图</span><br><span class="line">    上进行增广。可以发现，每一条增广路径都可以通过把“花”展开还原回去（因为一个奇环</span><br><span class="line">    的两段路径必然是一奇一偶，总能找到一段时满足的）。</span><br><span class="line"></span><br><span class="line">    void matching();</span><br><span class="line">    复杂度：    O(n^3)</span><br><span class="line">    输入：      n           全局变量，图的点数</span><br><span class="line">               a           全局变量，图的邻接矩阵</span><br><span class="line">    输出：      ans         全局变量，最大匹配数</span><br><span class="line">               match       全局变量，match[i]表示和i匹配的点</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">const int MAXN = 222 + 10;</span><br><span class="line">int n, x, y, fore, rear, cnt, ans;</span><br><span class="line">int father[MAXN], f[MAXN], path[MAXN], tra[MAXN], que[MAXN], match[MAXN];</span><br><span class="line">bool a[MAXN][MAXN], check[MAXN], treec[MAXN], pathc[MAXN];</span><br><span class="line"></span><br><span class="line">inline void push(int x) &#123;</span><br><span class="line">    que[++rear] = x;</span><br><span class="line">    check[x] = true;</span><br><span class="line">    if (!treec[x]) &#123;</span><br><span class="line">        tra[++cnt] = x;</span><br><span class="line">        treec[x] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int root(int x) &#123;</span><br><span class="line">    return f[x] ? f[x] = root(f[x]) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear() &#123;</span><br><span class="line">    for (int i = 1, j; i <span class="variable">&lt;= cnt; ++i) &#123;</span><br><span class="line">        j = tra[i];</span><br><span class="line">        check[j] = treec[j] = false;</span><br><span class="line">        father[j] = 0, f[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int u, int v) &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    for (; u; u = father[match[u]]) &#123;</span><br><span class="line">        u = root(u);</span><br><span class="line">        path[++len] = u;</span><br><span class="line">        pathc[u] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;v = father[match[v]]) &#123;</span><br><span class="line">        v = root(v);</span><br><span class="line">        if (pathc[v]) break;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; len; ++i)</span><br><span class="line">        pathc[path[i]] = false;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(int u, int p) &#123;</span><br><span class="line">    for (int v; root(u) != p;) &#123;</span><br><span class="line">        if (!check[v=match[u]]) push(v);</span><br><span class="line">        if (f[u] == 0) f[u] = p;</span><br><span class="line">        if (f[v] == 0) f[v] = p;</span><br><span class="line">        u = father[v];</span><br><span class="line">        if (root(u) != p) father[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flower(int u, int v) &#123;</span><br><span class="line">    int p = lca(u, v);</span><br><span class="line">    if (root(u) != p) father[u] = v;</span><br><span class="line">    if (root(v) != p) father[v] = u;</span><br><span class="line">    reset(u, p), reset(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">    fore = rear = cnt = 0, push(x);</span><br><span class="line">    while (fore++ &lt; rear) &#123;</span><br><span class="line">        int i = que[fore];</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            if (a[i][j] &amp;&amp; root(i) != root(j) &amp;&amp; match[j] != i)</span><br><span class="line">                if (match[j] &amp;&amp; father[match[j]])</span><br><span class="line">                    flower(i, j);</span><br><span class="line">                else if (father[j] == 0) &#123;</span><br><span class="line">                    father[j] = i;</span><br><span class="line">                    tra[++cnt] = j;</span><br><span class="line">                    treec[j] = true;</span><br><span class="line">                    if (match[j])</span><br><span class="line">                        push(match[j]);</span><br><span class="line">                    else &#123;</span><br><span class="line">                        for (int k = i, l = j, p; k; l = p, k = father[l]) &#123;</span><br><span class="line">                            p = match[k];</span><br><span class="line">                            match[k] = l;</span><br><span class="line">                            match[l] = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void matching() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    if (match[i] == 0) &#123;</span><br><span class="line">        if (find(i))</span><br><span class="line">            ++ans;</span><br><span class="line">    clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法">匈牙利算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个二分图,用匈牙利算法求这个二分图的最大匹配数.</span><br><span class="line">*</span><br><span class="line">*求最大匹配数,那么我们希望每一个在左边的点都尽量找到右边的一个点和它匹配.我们</span><br><span class="line">*依次枚举左边的点x的所有出边指向的y,若y之前没有被匹配,那么(x, y)就是一对合法的</span><br><span class="line">*匹配,我们将匹配数加一,否则我们试图给原来匹配y的x'重新找一个匹配,如果x'匹配成功,</span><br><span class="line">*那么就可以新增为一对合法的匹配.给x'寻找匹配的过程可以递归解决.</span><br><span class="line">*</span><br><span class="line">*int hungary();</span><br><span class="line">*复杂度:	O(|E|sqrt(|V|))</span><br><span class="line">*输  入:	n		全局变量,一侧的点数</span><br><span class="line">*		  g	 	  全局变量,g[i]表示与左边点i相连的右边的点</span><br><span class="line">*输	 出:	最大匹配数</span><br><span class="line">*		  from	  全局变量,mx[i]表示最大匹配中与左边点i相连的边</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">555</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="keyword">int</span> from[MAXN], tot;</span><br><span class="line"><span class="keyword">bool</span> use[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++)</span><br><span class="line">		<span class="keyword">if</span> (!use[g[x][i]]) &#123;</span><br><span class="line">			use[g[x][i]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (from[g[x][i]] == -<span class="number">1</span> || match(from[g[x][i]])) &#123;</span><br><span class="line">				from[g[x][i]] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(from, <span class="number">255</span>, seizeof(from));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span>(use));</span><br><span class="line">		<span class="keyword">if</span> (match(i))</span><br><span class="line">			tot++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双联通分量">双联通分量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个无向图,求出它的双联通分量.</span><br><span class="line">*双联通分量是指图中不包含割点的联通分量.</span><br><span class="line">*</span><br><span class="line">*和求割点的方法类似,在对图DFS的时候记录low和dfn.由于一个点可以属于多个双联通分量,而一条边属于唯一的双</span><br><span class="line">*联通分量,所以我们用一个边集来描述一个双联通分量.即:属于这个边集的所有边加上这些边的端点构成一个双联通分</span><br><span class="line">*量.每次我们发现一条树边(从父节点指向未被访问的子节点)和回边(从子节点指向父节点),就将它压入栈中.当DFS</span><br><span class="line">*从一个点u返回到点v时,如果low[u]&gt;=dfn[v],那么我们就不断地将栈顶的边弹出,直到弹出边(v,u)为止.所有弹</span><br><span class="line">*出的边构成一个双联通分量.</span><br><span class="line">*</span><br><span class="line">*void biconnect(int v);</span><br><span class="line">*复杂度: O(|E|+|V|)</span><br><span class="line">*输入:	 v			DFS到的当前节点</span><br><span class="line">*		 edge		全局变量,edge[i]表示从点i连出去的边</span><br><span class="line">*输出:	connect		全局变量,表示各个双联通分量</span><br><span class="line">*					connect内的每个元素为一个双联通分量,用属于这个双联通分量的点的编号组成的vector表示</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; connect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], in_seq[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn], <span class="built_in">list</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, top, pop, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biconnect</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>[++top] = v;</span><br><span class="line">	dfn[v] = low[v] = pop++;</span><br><span class="line">	<span class="keyword">int</span> i, succ;</span><br><span class="line">	<span class="keyword">for</span> (i = edge[v].size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		succ = edge[v][i];</span><br><span class="line">		<span class="keyword">if</span> (dfn[succ] == -<span class="number">1</span>) &#123;</span><br><span class="line">			biconnect(succ);</span><br><span class="line">			<span class="keyword">if</span> (low[succ] &gt;= dfn[v]) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				len = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					in_seq[<span class="built_in">stack</span>[top]] = cnt;</span><br><span class="line">					<span class="built_in">list</span>[len++] = <span class="built_in">stack</span>[top];</span><br><span class="line">					top--;</span><br><span class="line">				&#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[top+<span class="number">1</span>] != succ);</span><br><span class="line">				in_seq[v] = cnt;</span><br><span class="line">				<span class="built_in">list</span>[len++] = v;</span><br><span class="line">				<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="built_in">list</span>, <span class="built_in">list</span>+len);</span><br><span class="line">				connect.push_back(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			low[v] = min(low[v], low[succ]);</span><br><span class="line">		&#125; <span class="keyword">else</span> low[v] = min(low[v], dfn[succ]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于每个联通块取一个x调用disconnect(x).</span></span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*由于堆是完全二叉树,我们使用下标从1开始的数组来表示这棵树,1代表根节点,对于每个节点i,它的左儿子为i*2,又儿子为2*i+1,父亲为i/2.</span><br><span class="line">*我们使用数组heap[]来记录队中的元素.为了实现修改和删除操作我们额外使用id[]记录堆中位置为i的元素是第几个插入的,pos[]记录第i个</span><br><span class="line">*插入元素在堆中的位置.</span><br><span class="line">*实现堆核心函数up(i)和down(i),up(i)将堆中的位置为i的节点不断"上浮"(与父亲节点相比较,如果小于父亲节点则与父亲节点交换),down(i)</span><br><span class="line">*将堆中位置为i的节点不断"下沉"(与两个儿子节点比较,如果大于较小的儿子节点则与之交换).</span><br><span class="line">*在插入一个值value时,我们将它加入堆的最底层(heap[++size] = value),然后将其上浮;删除栈顶元素时,我们将栈顶与最后一个元素交换,</span><br><span class="line">*然后下沉;修改元素时我们先利用pos数组找到它当前在堆中的位置,然后直接修改并调用up()及down()维护堆的性质即可;删除元素时我们将它修改</span><br><span class="line">*为负无穷大,上浮到根,最后删除堆顶即可.</span><br><span class="line">*</span><br><span class="line">*结构体:		BinaryHeap</span><br><span class="line">*成员变量:</span><br><span class="line">*			int n			堆中当前元素个数</span><br><span class="line">*			int counter		加入堆中的元素个数</span><br><span class="line">*			int heap[]		堆中的元素</span><br><span class="line">*			int id[]		堆中位置为i的元素是第几个插入堆中的</span><br><span class="line">*			int pos[]		第i个插入堆中的元素在堆中的位置</span><br><span class="line">*成员函数:</span><br><span class="line">*			BinaryHeap();							构造出的一个空堆</span><br><span class="line">*			BinaryHeap(int array[]; int offset);	将数组中的元素按顺序插入所构造的堆</span><br><span class="line">*			复杂度: O(n)</span><br><span class="line">*			输入:	array[]							创建堆的元素所在的数组</span><br><span class="line">*					offset							数组中需要用作创建堆的元素的个数</span><br><span class="line">*			void push(int v);						插入键值v</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*			int pop();								删除栈顶元素</span><br><span class="line">*			复杂度:	O(logn)</span><br><span class="line">*			输出:	堆顶元素插入堆中的次序编号</span><br><span class="line">*			int get(int i);							获取第i个插入堆中的元素值</span><br><span class="line">*			复杂度: O(1)</span><br><span class="line">*			void change(int i, int value);			修改第i个元素为value</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*			void erase(int i);						删除第i个元素</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">100000</span>;			<span class="comment">//二叉堆的大小</span></span><br><span class="line">Struct BinaryHeap &#123;</span><br><span class="line">	<span class="keyword">int</span> heap[MAXSIZE], id[MAXSIZE], pos[MAXSIZE], n, counter;</span><br><span class="line"></span><br><span class="line">	BinaryHeap() : n(<span class="number">0</span>), counter(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	BinaryHeap(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> offset) : n(<span class="number">0</span>), counter(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; offset; i++) &#123;</span><br><span class="line">			heap[++n] = <span class="built_in">array</span>[i];</span><br><span class="line">			id[n] = pos[n] = n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			down(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		heap[++n] = v;</span><br><span class="line">		id[n] = ++counter;</span><br><span class="line">		pos[id[n]] = n;</span><br><span class="line">		up(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		swap(heap[<span class="number">1</span>], heap[n]);</span><br><span class="line">		swap(id[<span class="number">1</span>], id[n--]);</span><br><span class="line">		pos(id[<span class="number">1</span>]) = <span class="number">1</span>;</span><br><span class="line">		down(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> id[n+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> heap[pos[i]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		heap[pos[i]] = value;</span><br><span class="line">		down(pos[i]);</span><br><span class="line">		up(pos[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		heap[pos[i]] = INT_MIN;</span><br><span class="line">		up(pos[i]);</span><br><span class="line">		pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = heap[i], y = id[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i/<span class="number">2</span>; j &gt;=<span class="number">1</span>; j /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>	(heap[j] &gt; x) &#123;</span><br><span class="line">				heap[i] = heap[j];</span><br><span class="line">				id[i] = id[j];</span><br><span class="line">				pos[id[i]] = i;</span><br><span class="line">				i = j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		heap[i] = x;</span><br><span class="line">		id[i] = x;</span><br><span class="line">		pos[y] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = heap[i], y = id[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = i*<span class="number">2</span>; j &lt;= n; j *= <span class="number">2</span>) &#123;</span><br><span class="line">			j += j &lt; n &amp;&amp; heap[j] &gt; heap[j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>	(heap[j] &lt; x) &#123;</span><br><span class="line">				heap[i] = heap[j];</span><br><span class="line">				id[i] = id[j];</span><br><span class="line">				pos[id[i]] = i;</span><br><span class="line">				i = j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		heap[i] = x;</span><br><span class="line">		id[i] = y;</span><br><span class="line">		pos[y] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="常系数线性齐次递推">常系数线性齐次递推</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*常系数线性齐次递推</span><br><span class="line">*已知f(x) = a0f(x-1) + a1f(x-2) +...+ an-1f(x-n)和f(0),f(1),...f(n-1), 给定t,求f(t).</span><br><span class="line">*</span><br><span class="line">*f的递推可以看成一个n*n的矩阵A乘以一个n维列向量B,因为矩阵乘法满足结合率,用快速幂可以加速.</span><br><span class="line">*	|0	1	0   ...   0|</span><br><span class="line">*	|0	0	1   ...   0|</span><br><span class="line">*A =|	:		':.	  :|</span><br><span class="line">*	|0	0	0	...	  1|</span><br><span class="line">*	|an-1............a0|</span><br><span class="line">*</span><br><span class="line">*	|f(x-n)	 |</span><br><span class="line">*	|f(x-n+1)|</span><br><span class="line">*B =|	:	 |</span><br><span class="line">*	|f(x-2)	 |</span><br><span class="line">*	|f(x-1)  |</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*int slove(int a[], int b[], int n, int t);</span><br><span class="line">*复杂度: O(n^3logt)</span><br><span class="line">*输入:</span><br><span class="line">		a	常系数数组</span><br><span class="line">		b	初值数组</span><br><span class="line">		n	数组大小</span><br><span class="line">		t	要求解的项数</span><br><span class="line">*输出:  函数在第t项的值f(t)</span><br><span class="line">*调用外部函数:</span><br><span class="line">*		矩阵类</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">int solve(int a[], int b[], int <span class="keyword">n</span>, int t) &#123;</span><br><span class="line">	<span class="keyword">Matrix</span> <span class="keyword">M</span>, F, <span class="keyword">E</span>;</span><br><span class="line">	<span class="keyword">M</span>.<span class="keyword">clear</span>(), F.<span class="keyword">clear</span>(), <span class="keyword">E</span>.<span class="keyword">clear</span>();</span><br><span class="line">	<span class="keyword">M</span>.<span class="keyword">n</span> = <span class="keyword">M</span>.<span class="keyword">m</span> = <span class="keyword">n</span>;</span><br><span class="line">	<span class="keyword">E</span>.<span class="keyword">n</span> = <span class="keyword">E</span>.<span class="keyword">m</span> = <span class="keyword">n</span>;</span><br><span class="line">	F.<span class="keyword">n</span> = <span class="keyword">n</span>, f.<span class="keyword">m</span> = 1;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>-1; i++)</span><br><span class="line">		<span class="keyword">M</span>.a[i][i+1] = 1;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">M</span>.a[<span class="keyword">n</span>-1][i] = a[i];</span><br><span class="line">		F.a[i][0] = b[i];</span><br><span class="line">		<span class="keyword">E</span>.a[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="keyword">n</span>)</span><br><span class="line">		<span class="keyword">return</span> F.a[t][0];</span><br><span class="line">	<span class="keyword">for</span>	(t -= <span class="keyword">n</span> - 1; t; t /= 2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; 1)</span><br><span class="line">			<span class="keyword">E</span> = <span class="keyword">M</span> * <span class="keyword">E</span>;</span><br><span class="line">		<span class="keyword">M</span> = <span class="keyword">M</span> * <span class="keyword">M</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	F = <span class="keyword">E</span> * F;</span><br><span class="line">	<span class="keyword">return</span> F.a[<span class="keyword">n</span>-1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割点和桥">割点和桥</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一个无向图,找出图中的割点和桥.</span><br><span class="line">*</span><br><span class="line">*我们使用三个数组来完成这个算法:</span><br><span class="line">*vis<span class="string">[v]</span>记录的是节点v当前的访问状态:<span class="number">1</span>表示在栈中,<span class="number">0</span>表示未访问,<span class="number">2</span>表示已经访问过;</span><br><span class="line">*dfn<span class="string">[v]</span>记录的是节点v被访问时的深度;</span><br><span class="line">*low<span class="string">[v]</span>记录的是节点v可以到达的访问时间最早的祖先.</span><br><span class="line">*在深度遍历图的过程中,记录下每个节点的深度.对当前节点cur,以及和它相连的节点i,有两种情况:</span><br><span class="line">*(<span class="number">1</span>)i没被访问过,这时递归访问节点i,并用i的可以到达的最早的祖先来更新cur的low值.</span><br><span class="line">*(<span class="number">2</span>)i在当前栈中,说明图中有一个环,用i的深度更新cur的low值.</span><br><span class="line">*cur是割点的条件:cur是根且有大于一个的儿子,或者cur不是根,且cur有一个儿子使得low<span class="string">[v]</span> &gt;= dfn<span class="string">[cur]</span>.</span><br><span class="line">*(cur, i)是桥的条件:low<span class="string">[i]</span> &gt; dfn<span class="string">[cur]</span>.</span><br><span class="line">*</span><br><span class="line">*void cut_bridge(int cur, int father, int dep, int n);</span><br><span class="line">*复杂度: O(|E|+|V|)</span><br><span class="line">*输入:   cur			当前节点</span><br><span class="line">*		 father		当前节点的父亲节点</span><br><span class="line">*		 dep 		当前节点被访问时的深度</span><br><span class="line">*		 n 			图的总点数</span><br><span class="line">*		 edge 		全局变量,图的邻接矩阵(点从<span class="number">0</span>开始编号)</span><br><span class="line">*输出:	 bridge		全局变量,bridge<span class="string">[u]</span><span class="string">[v]</span>表示边(u,v)是否是一个桥</span><br><span class="line">*		 cut 		全局变量,cut<span class="string">[v]</span>表示节点v是否是一个割点</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const int V = <span class="number">1000</span>;</span><br><span class="line">int edge<span class="string">[V]</span><span class="string">[V]</span>;</span><br><span class="line">int bridge<span class="string">[V]</span><span class="string">[V]</span>, cut<span class="string">[V]</span>;</span><br><span class="line">int low<span class="string">[V]</span>, dfn<span class="string">[V]</span>, vis<span class="string">[V]</span>;</span><br><span class="line"></span><br><span class="line">void cut_bridge(int cur, int father, int dep, int n) &#123;		//vertex: <span class="number">0</span> ~ n-<span class="number">1</span></span><br><span class="line">	vis<span class="string">[cur]</span> =  <span class="number">1</span>;</span><br><span class="line">	dfn<span class="string">[cur]</span> = low<span class="string">[cur]</span> = dep;</span><br><span class="line">	int children = <span class="number">0</span>;</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; n; i++) if (edge<span class="string">[cur]</span><span class="string">[i]</span>) &#123;</span><br><span class="line">		if (i != father &amp;&amp; <span class="number">1</span> == vis<span class="string">[i]</span>) &#123;</span><br><span class="line">			if (dfn<span class="string">[i]</span> &lt; low<span class="string">[cur]</span>)</span><br><span class="line">				low<span class="string">[cur]</span> = dfn<span class="string">[i]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		if (<span class="number">0</span> == vis<span class="string">[i]</span>) &#123;</span><br><span class="line">			cut_bridge(i, cur, dep+<span class="number">1</span>, n);</span><br><span class="line">			children++;</span><br><span class="line">			if (low<span class="string">[i]</span> &lt; low<span class="string">[cur]</span>) low<span class="string">[cur]</span> = low<span class="string">[i]</span>;</span><br><span class="line">			if ((father == -<span class="number">1</span> &amp;&amp; children &gt; <span class="number">1</span>) || (father != -<span class="number">1</span> &amp;&amp; low<span class="string">[i]</span> &gt;= dfn<span class="string">[cur]</span>))</span><br><span class="line">				cut<span class="string">[cur]</span> = true;</span><br><span class="line">			if (low<span class="string">[i]</span> &gt; dfn<span class="string">[cur]</span>) &#123;</span><br><span class="line">				bridge<span class="string">[cur]</span><span class="string">[i]</span> = bridge<span class="string">[i]</span><span class="string">[cur]</span> = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis<span class="string">[cur]</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于每一个联通块取一个点x调用cut_bridge(x, -<span class="number">1</span>, <span class="number">0</span>, n),其中n为点数</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*维护一个森林,每一棵树代表一个集合,树根元素为这个集合的代表元.利用数组father[]记录维护每个元素的父节点.</span><br><span class="line">*查询一个元素所处的集合时,只需不断需找父亲节点,即可找到该元素所处集合的代表元.</span><br><span class="line">*合并两个集合时,先找到两个集合的代表元x,y,然后令father[x] = y即可.</span><br><span class="line">*优化<span class="number">1</span>: 路径压缩,即沿着树根的路径找到元素a所在集合的代表元b之后,对这条路径上的所有元素x(包括a),直接令father[x] = b.</span><br><span class="line">*优化<span class="number">2</span>: 按<span class="built_in">rank</span>启发合并,即对于每个集合维护一个<span class="built_in">rank</span>值,每次将<span class="built_in">rank</span>较小的集合合并到<span class="built_in">rank</span>较大的集合,合并两个<span class="built_in">rank</span>相同的集合时<span class="built_in">rank</span> = <span class="built_in">rank</span> + <span class="number">1.</span></span><br><span class="line">*</span><br><span class="line">*结构体: 	DisjoinSet</span><br><span class="line">*成员变量:	vector&lt;<span class="typename">int</span>&gt; father			元素的父节点,树根元素的父亲为本身</span><br><span class="line">*			vector&lt;<span class="typename">int</span>&gt; <span class="built_in">rank</span>			树根元素代表集合的<span class="built_in">rank</span></span><br><span class="line">*成员函数:</span><br><span class="line">*			DisjointSet(<span class="typename">int</span> n);			初始化,n个元素,处于单独集合</span><br><span class="line">*			复杂度:	O(n)</span><br><span class="line">*			<span class="typename">int</span> find(<span class="typename">int</span> v);			查找v所在的集合的代表元</span><br><span class="line">*			复杂度:	均摊O(<span class="number">1</span>)</span><br><span class="line">*			void merge(<span class="typename">int</span> x, <span class="typename">int</span> y);	合并x所在的集合与y所在的集合</span><br><span class="line">*			复杂度:	均摊O(<span class="number">1</span>)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct DisjointSet &#123;</span><br><span class="line">	std::vector&lt;<span class="typename">int</span>&gt; father, <span class="built_in">rank</span>;</span><br><span class="line"></span><br><span class="line">	DisjointSet (<span class="typename">int</span> n) : father(n), <span class="built_in">rank</span>(n) &#123;</span><br><span class="line">		for (<span class="typename">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="typename">int</span> find(<span class="typename">int</span> v) &#123;</span><br><span class="line">		return father[v] = father[v] == v ? v : find(father[v]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void merge(<span class="typename">int</span> x, <span class="typename">int</span> y) &#123;</span><br><span class="line">		<span class="typename">int</span> a = find(x), b = find(y);</span><br><span class="line">		if (<span class="built_in">rand</span>[a] &lt; <span class="built_in">rank</span>[b]) &#123;</span><br><span class="line">			father[a] = b;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			father[b] = a;</span><br><span class="line">			if (<span class="built_in">rank</span>[b] == <span class="built_in">rank</span>[a]) &#123;</span><br><span class="line">				<span class="built_in">rank</span>[a]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="高斯消元">高斯消元</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*高斯消元</span><br><span class="line">*给一个n元一次方程组,求其解集</span><br><span class="line">*将方程组做成矩阵形式,再利用三种初等矩阵变换,得到上三角矩阵,最后回代得到解集</span><br><span class="line">*</span><br><span class="line">*int solve(double a[][MAXN], bool l[], double ans[], const int &amp;n);</span><br><span class="line">*</span><br><span class="line">*复杂度(N^3)</span><br><span class="line">*输入:</span><br><span class="line">		a		方程组对应的矩阵</span><br><span class="line">		n		未知数的个数</span><br><span class="line">		l, ans	l[]表示是否为自由元,储存解</span><br><span class="line">*输出:	解空间的维数</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">int</span> <span class="title">solve</span>(<span class="params"><span class="keyword">double</span> a[][MAXN], <span class="keyword">bool</span> l[], <span class="keyword">double</span> ans[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		l[i] = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = r; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (fabs(a[j][i]) &gt; EPS) &#123;</span><br><span class="line">				<span class="keyword">for</span>	(<span class="keyword">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">					swap(a[j][k], a[r][k]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (fabs(a[r][i]) &lt; EPS) &#123;</span><br><span class="line">			res++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (j != r &amp;&amp; fabs(a[j][i]) &gt; EPS) &#123;</span><br><span class="line">				<span class="keyword">double</span> tmp = a[j][i] / a[r][i];</span><br><span class="line">				<span class="keyword">for</span>	(<span class="keyword">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">					a[j][k] -= tmp * a[r][k];</span><br><span class="line">			&#125;</span><br><span class="line">		l[i] = <span class="keyword">true</span>;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l[i])</span><br><span class="line">			<span class="keyword">for</span>	(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">if</span>	(fabs(a[j][i]) &gt; <span class="number">0</span>)</span><br><span class="line">					ans[i] = a[j][n] / a[j][i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧几里德">欧几里德</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里德">扩展欧几里德</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*求出A,B的最大公约数,且求出X,Y满足AX+BY = GCD(A, B).</span><br><span class="line">*</span><br><span class="line">*要求X,Y,满足: AX+BY = GCD(A, B).</span><br><span class="line">*当B = 0时,有X = 1, Y = 0时等式成立.</span><br><span class="line">*当B &gt; 0时,在欧几里德算法的基础上,已知:</span><br><span class="line">*			GCD(A, B) = GCD(B, A mod B)</span><br><span class="line">*先递归求出X', Y'满足:</span><br><span class="line">*	BX' + (A mod B)Y' = GCD(B, A mod B) = GCD(A, B)</span><br><span class="line">*然后可以回推,我们将上式化简得:</span><br><span class="line">*		BX' + (A - A/B * B)Y' = GCD(A, B)</span><br><span class="line">*		AY' + BX' - (A/B) * BY' = GCD(A, B)</span><br><span class="line">*这里除法指整除.把含B的因式提取一个B,可得:</span><br><span class="line">*		AY' + B(X' - A/B * Y') = GCD(A, B)</span><br><span class="line">*故X = Y', Y = X' - A/B * Y'.</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*int estend_gcd(int a, int b, int &amp;x, int &amp;y);</span><br><span class="line">*复杂度:	O(logN)		其中N和a,b同阶</span><br><span class="line">*输  入:	a, b 		两个整数</span><br><span class="line">*			&amp;x, &amp;y		引用,ax + by = GCD(a, b)的一组解</span><br><span class="line">*输  出:	a和b的最大公约数</span><br><span class="line">*调用后x, y满足方程ax + by = GCD(a, b).</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ectend_gcd(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y) &#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> r = extend_gcd(b, a % b, y, x);</span><br><span class="line">		y -= x*(a/b);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度整数">高精度整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*完成高精度整数的加减乘除以及取模运算。</span><br><span class="line">*</span><br><span class="line">*结构体：BigNumber</span><br><span class="line">*成员变量：</span><br><span class="line">*    int d[maxl] d[0]表示当前的位数</span><br><span class="line">*                其余d[i]表示第i位上的数(每四位压成一个万进制)</span><br><span class="line">*构造函数：</span><br><span class="line">*    BigNumber(string s)   从字符串s构造</span><br><span class="line">*成员函数：</span><br><span class="line">*    string toString()     输出字符串</span><br><span class="line">*重载运算符：+、-、*、/、&lt;、==</span><br><span class="line">*</span><br><span class="line">*运算过程中和结果都不能包含负数。答案最长长度为(maxl-1)*4。做除法的时候保存在全局变量d里面</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ten[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BigNumber&#123;</span><br><span class="line">    <span class="keyword">int</span> d[maxl];</span><br><span class="line">    BigNumber(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        d[<span class="number">0</span>] = (len-<span class="number">1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; maxl; i++) d[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            j = (len-<span class="number">1</span>-i)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">            k = (len-<span class="number">1</span>-i)%<span class="number">4</span>;</span><br><span class="line">            d[j] += ten[k] * (s[i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d[<span class="number">0</span>] &gt; <span class="number">1</span> &amp;&amp; d[d[<span class="number">0</span>]] == <span class="number">0</span>) d[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    BigNumber() &#123;</span><br><span class="line">        *<span class="keyword">this</span> = BigNumber(<span class="built_in">string</span>(<span class="string">"0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (d[d[<span class="number">0</span>]] &gt;= ten[i]) <span class="keyword">break</span>;</span><br><span class="line">        temp = d[d[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            s = s + (<span class="keyword">char</span>)(temp/ten[j]+<span class="string">'0'</span>);</span><br><span class="line">            temp %= ten[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = d[<span class="number">0</span>]-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = d[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">3</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                s = s + (<span class="keyword">char</span>)(temp/ten[j]+<span class="string">'0'</span>);</span><br><span class="line">                temp %= ten[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; zero(<span class="string">"0"</span>), d, temp, mid1[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] != b.d[<span class="number">0</span>]) <span class="keyword">return</span> a.d[<span class="number">0</span>] &lt; b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = a.d[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (a.d[i] != b.d[i]) <span class="keyword">return</span> a.d[i] &lt; b.d[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> + (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = max(a.d[<span class="number">0</span>], b.d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= c.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = a.d[i] + b.d[i] + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[++c.d[<span class="number">0</span>]] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> - (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= c.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = <span class="number">10000</span> + a.d[i] - b.d[i] + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x = x / <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> * (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>] + b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b.d[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">            x = a.d[i] * b.d[j] + x + cd[i+j-<span class="number">1</span>];</span><br><span class="line">            c.d[i+j-<span class="number">1</span>] = x % <span class="number">10000</span>;</span><br><span class="line">            x /= <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.d[i+b.d[<span class="number">0</span>]] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">smaller</span> <span class="params">(<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] + delta != b.d[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a.d[<span class="number">0</span>] + delta &lt; b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.d[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (a.d[i] != b.d[i+delta])</span><br><span class="line">            <span class="keyword">return</span> a.d[i] &lt; b.d[i+delta];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Minus</span><span class="params">(BigNumber &amp;a, <span class="keyword">const</span> BigNumer &amp;b, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]-delta; i++) &#123;</span><br><span class="line">        x = <span class="number">10000</span> + a.d[i+delta] - b.d[i] + x;</span><br><span class="line">        a.d[i+delta] = x % <span class="number">10000</span>;</span><br><span class="line">        x = x / <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((a.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (a.d[a.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        a.d[<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> * (<span class="keyword">const</span> bigNumber &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = a.d[i] * k + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[++c.d[<span class="number">0</span>]] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> / (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    d = a;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    mid1[<span class="number">0</span>] = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++) &#123;</span><br><span class="line">        mid1[i] = mid1[i-<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = a.d[<span class="number">0</span>] - b.d[<span class="number">0</span>]; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = <span class="number">8192</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">13</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smaller(mid1[j], i)) &#123;</span><br><span class="line">                Minus(d, mid1[j], i);</span><br><span class="line">                c.d[i+<span class="number">1</span>] += temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.d[<span class="number">0</span>] = max(<span class="number">1</span>, a.d[<span class="number">0</span>]-b.d[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] != b.d[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="keyword">if</span> (a,d[i] != b.d[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛法求素数">筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个正整数N,求出[2,N]中所有的素数.</span><br><span class="line">*</span><br><span class="line">*数组valid[i]记录i是否为素数.初始所有的valid[i]都为true.从2开始从小到大枚举;若valid[i] = true,则把从i^2开始的</span><br><span class="line">*每一个i的倍数的valid赋为false.</span><br><span class="line">*结束之后valid[i] = true的就是素数.</span><br><span class="line">*</span><br><span class="line">*void getPrime(int n, int &amp;tot, int ans[maxn]);</span><br><span class="line">*复杂度: O(NlogN), O(N),	 两种实现</span><br><span class="line">*输入:	 N				 所需素数的范围</span><br><span class="line">*输出:	 &amp;tot			 引用,素数总数</span><br><span class="line">*		 ans 			 素数表</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 素数筛法 O(NlogN) */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> maxn <span class="number">1000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> ans[maxn])</span> </span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) valid[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (valid[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n/i &lt; i) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt;= n; j += i) valid[j] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (valid[i]) ans[++tot] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 素数筛法 O(N) */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> ans[maxn])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(valid, <span class="literal">true</span>, <span class="keyword">sizeof</span>(valid));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (valid[i]) ans[++tot] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ((j &lt;= tot) &amp;&amp; (i*ans[j] &lt;= n)); j++) &#123;</span><br><span class="line">			valid[i*ans[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % ans[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数">欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*计算N的欧拉函数Phi(N)。</span><br><span class="line">*</span><br><span class="line">*定义：欧拉函数Phi(N)，表示小于或等于n的数中与n互质的数的数目。</span><br><span class="line">*欧拉函数求值的方法是：</span><br><span class="line">*(1) Phi(1) ＝ 1</span><br><span class="line">*(2) 若n是素数p的k次幂，Phi(n)＝p^k-p^(k-1)=(p-1)p^(k-1)</span><br><span class="line">*(3) 若n，m互质，Phi(nm) = Phi(n)*Phi(m)</span><br><span class="line">*</span><br><span class="line">*根据欧拉函数的定义，可以推出欧拉函数的递推式：</span><br><span class="line">*</span><br><span class="line">*令p为N的最小质因数，若p^2|N,Phi(N)=Phi(N/p)*p;否则Phi(N)=Phi(N)*(p-1)。</span><br><span class="line">*</span><br><span class="line">*void genPhi();</span><br><span class="line">*复杂度：  O(NlogN)</span><br><span class="line">*输 出：   phi 全局变量，存储了1～max中每个数的欧拉函数。</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minDiv[max], phi[max], sum[max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">        minDiv[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minDiv[i] == i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; max; j += i) &#123;</span><br><span class="line">                minDiv[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max; i++) &#123;</span><br><span class="line">        phi[i] = phi[i / minDiv[i]];</span><br><span class="line">        <span class="keyword">if</span> ((i / minDiv[i]) % minDiv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            phi[i] *= minDiv[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            phi[i] *= minDiv[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前向星">前向星</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*以前向星方式存储一个有向图的基本信息.</span><br><span class="line">*使用链表方式存储图的边.info[i]为节点i的边集所对应的链表的头指针,next[j]为第j条边的指向下一条边的指针,to[j]表示第j条边</span><br><span class="line">*所指向的节点编号.即:令addr = info[i],之后不断用addr = next[addr]即可得到链表中节点i的所有边集的编号,其中to[addr]表示</span><br><span class="line">*对应边指向的节点编号.</span><br><span class="line">*</span><br><span class="line">*结构体:graph</span><br><span class="line">*成员变量:</span><br><span class="line">*		vector&lt;int&gt; info 	由该点出发的所有边构成的链表的表</span><br><span class="line">*		vector&lt;int&gt; next 	链表中下一条边在to数组中的位置</span><br><span class="line">*		vector&lt;int&gt; to		to[i]表示编号为i的边指向的节点</span><br><span class="line">*成员函数:</span><br><span class="line">*		graph(int n, int m);	初始化图为n个点,m条边</span><br><span class="line">*		void add(int i, int j); 添加(i,j)之间的边</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> graph &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line">	VI info, next, to;</span><br><span class="line">	graph(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>) : to(<span class="number">0</span>), next(<span class="number">0</span>) &#123;</span><br><span class="line">		info.resize(n);</span><br><span class="line">		next.reserve(m);</span><br><span class="line">		to.reserve(m);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">edge_size</span><span class="params">()</span> </span>&#123;					<span class="comment">//返回边的数量</span></span><br><span class="line">		<span class="keyword">return</span> to.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">vertex_size</span><span class="params">()</span> </span>&#123;					<span class="comment">//返回值为最大点的编号+1</span></span><br><span class="line">		<span class="keyword">return</span> info.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (info.size() &lt; i + <span class="number">1</span>)</span><br><span class="line">			info.resize(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;			<span class="comment">//添加一条i到j的边</span></span><br><span class="line">		expand(i), expand(j);</span><br><span class="line">		to.push_back(j);</span><br><span class="line">		next.push_back(info[i]);</span><br><span class="line">		info[i] = to.size() - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del_back</span><span class="params">()</span> </span>&#123;					<span class="comment">//删除最后一次添加的边</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>	(i = <span class="number">0</span>; i &lt; info.size(); i++)</span><br><span class="line">			<span class="keyword">if</span> (info[i] == to.size() - <span class="number">1</span>) &#123;</span><br><span class="line">				info[i] = next.back();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		to.pop_back();</span><br><span class="line">		next.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;						<span class="comment">//清空图类</span></span><br><span class="line">		info.clear();</span><br><span class="line">		next.resize(<span class="number">0</span>);</span><br><span class="line">		tp.resize(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树">线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*要求实现一种数据结构,使得它能够在O(logN)时间复杂度内动态维护一段序列:修改一个元素的权值,查询一段区间的最小(最大)值.</span><br><span class="line">*</span><br><span class="line">*线段树是一个二叉树,树上每个节点表示一段区间,每个节点的左右儿子分别是该节点表示的区间从中间断开后分成的左区间和右区间.</span><br><span class="line">*每个区间记录一个当前子树的最小/最大值Top[i].</span><br><span class="line">*查询[a,b]区间的话也很简单,对于当前节点i,如果[a,b]能够完全覆盖i表示的区间,则直接返回Top[i],否则判断与左右区间是否有交</span><br><span class="line">*递归进入访问,取两者之间的最大值即可.</span><br><span class="line">*</span><br><span class="line">*(假设这里维护的是最大值)</span><br><span class="line">*类: IntervalTree</span><br><span class="line">*成员函数:</span><br><span class="line">*		IntervalTree(int size);		构造一颗维护区间[1..size]的线段树</span><br><span class="line">*		Int Query(int a, int b);	查询[a..b]区间内的最大值</span><br><span class="line">*		复杂度:	O(logN)</span><br><span class="line">*		void Modify(int a, int d);	把第a个元素的值改成d</span><br><span class="line">*		复杂度:	O(logN)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TREE_SIZE (i&lt;&lt;(<span class="number">20</span>))</span></span><br><span class="line"><span class="keyword">class</span> IntervalTree&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> Cover[TREE_SIZE], Top[TREE_SIZE];</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> _Query(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Ind) &#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= l &amp;&amp; b &gt;= r) <span class="keyword">return</span> Top[Ind];</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>, ret = Cover[Ind];</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= mid) ret = max(ret, _Query(a, b, l, mid, Ind &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (b &gt; mid) ret = max(ret, _Query(a, b, mid+<span class="number">1</span>, r, (Ind &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> _Modify(<span class="keyword">int</span> a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Ind, <span class="keyword">int</span> d) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r &amp;&amp; l == a) &#123;</span><br><span class="line">			Cover[Ind] = Top[Ind] = d;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &lt;= mid) _Modify(a, l, mid, Ind &lt;&lt; <span class="number">1</span>, d);</span><br><span class="line">		<span class="keyword">else</span> _Modify(a, mid+<span class="number">1</span>, r, (Ind&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, d);</span><br><span class="line">		Top[Ind] = max(Top[Ind&lt;&lt;<span class="number">1</span>], Top[(Ind&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntervalTree() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(Cover, <span class="number">0</span>, <span class="keyword">sizeof</span>(Cover));</span><br><span class="line">		<span class="built_in">memset</span>(Top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Top));</span><br><span class="line">		size = (TREE_SIZE&gt;&gt;<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IntervalTree(<span class="keyword">int</span> size):size(size) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(Cover, <span class="number">0</span>, <span class="keyword">sizeof</span>(Cover));</span><br><span class="line">		<span class="built_in">memset</span>(Top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Top));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Query(a, b, <span class="number">1</span>, size, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Modify(a, <span class="number">1</span>, size, <span class="number">1</span>, d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵的逆">矩阵的逆</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*求矩阵的逆</span><br><span class="line">*将原矩阵<span class="keyword">A</span>和一个单位矩阵E作成大矩阵(<span class="keyword">A</span>,E),用初等行变换将大矩阵中的<span class="keyword">A</span>变成E,</span><br><span class="line">*则会得到(E,<span class="keyword">A</span>')的形式</span><br><span class="line">*</span><br><span class="line">*void inverse(vector&lt;double&gt; <span class="keyword">A</span>[], vector&lt;double&gt; C[], int N)<span class="comment">;</span></span><br><span class="line">*复杂度(n^3)</span><br><span class="line">*输入:</span><br><span class="line">*		<span class="keyword">A</span>	原矩阵</span><br><span class="line">*		C	逆矩阵</span><br><span class="line">*		N	矩阵的阶数</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">inline vector&lt;double&gt; operator * (vector&lt;double&gt; a, double b) &#123;</span><br><span class="line">	int N = a.size()<span class="comment">;</span></span><br><span class="line">	vector&lt;double&gt; res(N, 0)<span class="comment">;</span></span><br><span class="line">	for (int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		res[i] = a[i] * b<span class="comment">;</span></span><br><span class="line">	return res<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline vector&lt;double&gt; operator - (vector&lt;double&gt; a, vector&lt;double&gt; b) &#123;</span><br><span class="line">	int N = a.size()<span class="comment">;</span></span><br><span class="line">	vector&lt;double&gt; res(N, 0)<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		res[i] = a[i] - b[i]<span class="comment">;</span></span><br><span class="line">	return res<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void inverse(vector&lt;double&gt; <span class="keyword">A</span>[], vector&lt;double&gt; C[], int N) &#123;</span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		C[i] = vector&lt;double&gt;(N,0)<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		C[i][i] = 1<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++) &#123;</span></span><br><span class="line">		for	(int j = i<span class="comment">; j &lt; N; j++)</span></span><br><span class="line">			if (fabs(<span class="keyword">A</span>[j][i]) &gt; 0) &#123;</span><br><span class="line">				swap(<span class="keyword">A</span>[i], <span class="keyword">A</span>[j])<span class="comment">;</span></span><br><span class="line">				swap(C[i], C[j])<span class="comment">;</span></span><br><span class="line">				break<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		C[i] = C[i] * (1 / <span class="keyword">A</span>[i][i])<span class="comment">;</span></span><br><span class="line">		<span class="keyword">A</span>[i] = <span class="keyword">A</span>[i] * (1 / <span class="keyword">A</span>[i][i])<span class="comment">;</span></span><br><span class="line">		for	(int j = 0<span class="comment">; j &lt; N; j++)</span></span><br><span class="line">			if (j != i &amp;&amp; fabs(<span class="keyword">A</span>[j][i]) &gt; 0) &#123;</span><br><span class="line">				C[j] = C[j] - C[i] * <span class="keyword">A</span>[j][i]<span class="comment">;</span></span><br><span class="line">				<span class="keyword">A</span>[j] = <span class="keyword">A</span>[j] - <span class="keyword">A</span>[i] * <span class="keyword">A</span>[j][i]<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA">LCA</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*对于每个节点v,记录anc[<span class="link_label">v</span>][<span class="link_reference">k</span>],表示从它向上走2^k步之后达到的节点(如果越过了根节点,那么anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]就是根节点)</span><br><span class="line">*dfs函数对树进行dfs,先求出anc[<span class="link_label">v</span>][<span class="link_reference">0</span>],再利用anc[<span class="link_label">v</span>][<span class="link_reference">k</span>] = anc[<span class="link_label">anc[v</span>][<span class="link_reference">k-1</span>]][<span class="link_reference">k-1</span>]求出其他anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]的值</span><br><span class="line">*swim(x,k)函数从节点x向上走k步,并将x赋为新走到的节点</span><br><span class="line">*find(x,y)函数需找x和y的LCA.首先利用swin,将x,y调整到同一高度.如果此时x和y重合,那么这就是我们要找的LCA.</span><br><span class="line">*如果它们不重合,不断地寻找一个最小的k,使得anc[<span class="link_label">x</span>][<span class="link_reference">k</span>] = anc[<span class="link_label">y</span>][<span class="link_reference">k</span>](说明向上走2^k越过了x,y的LCA),然后x,y同时</span><br><span class="line">*向上移动2^(k-1)步,显然新的x,y和原来的x,y有相同的LCA.直到k = 0,说明此时x,y的父节点anc[<span class="link_label">x</span>][<span class="link_reference">0</span>]和anc[<span class="link_label">y</span>][<span class="link_reference">0</span>]重合</span><br><span class="line">*并且就是我们要寻找的LCA.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int lca(int root);</span><br><span class="line">*复杂度: O(N)</span><br><span class="line">*输入:</span><br><span class="line"><span class="bullet">*		</span>root	树的根节点</span><br><span class="line"><span class="bullet">*		</span>head	全局变量,存储边的信息,head[i]表示第i个节点的头指针</span><br><span class="line"><span class="bullet">*		</span>point	全局变量,point[i]表示第i条边指向的节点</span><br><span class="line"><span class="bullet">*		</span>next	全局变量,next[i]表示第i条边的下一个指针</span><br><span class="line">*输出:</span><br><span class="line"><span class="bullet">*		</span>anc		全局变量,anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]表示节点v向上走2^k步后到达的节点</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int find(int x, int y);</span><br><span class="line">*复杂度: O(logN)</span><br><span class="line">*输入:</span><br><span class="line"><span class="bullet">*		</span>x,y 	询问x和y的LCA</span><br><span class="line">*输出:</span><br><span class="line"><span class="bullet">*		</span>点x和y的LCA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void dfs(int root) &#123;</span><br><span class="line"><span class="code">	static int Stack[maxn];</span></span><br><span class="line"><span class="code">	int top = 0;</span></span><br><span class="line"><span class="code">	dep[root] = 1;</span></span><br><span class="line"><span class="code">	for	(int i = 0; i &lt; maxh; i++)</span></span><br><span class="line"><span class="code">		ans[root][i] = root;</span></span><br><span class="line"><span class="code">	Stack[++top] = root;</span></span><br><span class="line"><span class="code">	memcpy(head, info, szieof(head));</span></span><br><span class="line"><span class="code">	while (top) &#123;</span></span><br><span class="line"><span class="code">		int x = Stack[top];</span></span><br><span class="line"><span class="code">		if	(x != root) &#123;</span></span><br><span class="line"><span class="code">			for	(int i = 1; i &lt; maxh; i++) &#123;</span></span><br><span class="line"><span class="code">				int y = anc[x][i-1];</span></span><br><span class="line"><span class="code">				anc[x][i] = anc[y][i-1];</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		for (int &amp;i = head[x]; i; i = next[i]) &#123;</span></span><br><span class="line"><span class="code">			int y = point[i];</span></span><br><span class="line"><span class="code">			if (y != anc[x][0]) &#123;</span></span><br><span class="line"><span class="code">				dep[y] = dep[x] + 1;</span></span><br><span class="line"><span class="code">				anc[y][0] = x;</span></span><br><span class="line"><span class="code">				Stack[++top] = y;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		while (top &amp;&amp; head[Stack[top]] == 0) top--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swim(int &amp;x, int H) &#123;</span><br><span class="line"><span class="code">	for (int i = 0; H &gt; 0; i++) &#123;</span></span><br><span class="line"><span class="code">		if (H &amp; 1) x = anc[x][i];</span></span><br><span class="line"><span class="code">		H /= 2;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x, int y) &#123;</span><br><span class="line"><span class="code">	int i;</span></span><br><span class="line"><span class="code">	if (dep[x] &gt; dep[y]) swap(x, y);</span></span><br><span class="line"><span class="code">	swim(y, dep[y] - dep[x]);</span></span><br><span class="line"><span class="code">	if (x == y) return x;</span></span><br><span class="line"><span class="code">	for (;;) &#123;</span></span><br><span class="line"><span class="code">		for	(i = 0; anc[x][i] != anc[y][i]; i++);</span></span><br><span class="line"><span class="code">		if (i == 0) return anc[x][0];</span></span><br><span class="line"><span class="code">		x = anc[x][i-1];</span></span><br><span class="line"><span class="code">		y = anc[y][i-1];</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	return -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵类">矩阵类</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现矩阵的基本变换</span><br><span class="line">*结构体: Matrix</span><br><span class="line">*成员变量:</span><br><span class="line">*	int n,m       矩阵大小</span><br><span class="line">*	int a[][]	  矩阵内容</span><br><span class="line">*重载运算符: + - *</span><br><span class="line">*成员函数:</span><br><span class="line">*	void cleat()  清空矩阵</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int MAXN = 1010;</span><br><span class="line"><span class="keyword">const</span> int MAXM = 1010;</span><br><span class="line">struct <span class="keyword">Matrix</span>&#123;</span><br><span class="line">	int <span class="keyword">n</span>, <span class="keyword">m</span>;</span><br><span class="line">	int a[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line">	void <span class="keyword">clear</span>()&#123;</span><br><span class="line">		<span class="keyword">n</span> = <span class="keyword">m</span> = 0;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator +(<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				tmp.a[i][j] = a[i][j] + b.a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator - (<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				tmp.a[i][j] = a[i][j] - b.a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator * (<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">clear</span>();</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; b.<span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>	(int k = 0; k &lt; <span class="keyword">m</span>; k++)&#123;</span><br><span class="line">					tmp.a[i][j] += a[i][k] * b.a[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		retrun tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Prim算法">Prim算法</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*先任意找一个点标记,然后每次找一条最短的两端分别为标记和未标记的边加进来,</span><br><span class="line">*把未标记的点标记上.即每次加入一条合法的最短的边,每次扩展一个点由未标记为</span><br><span class="line">*以标记,直到扩展至N个点</span><br><span class="line">*</span><br><span class="line">*int Prim();</span><br><span class="line">*复杂度: O(|V|^2)</span><br><span class="line">*输入:</span><br><span class="line">*	g	全局变量,g[i]表示所有与节点i相连的边</span><br><span class="line">*		g[i][j].first表示与节点i的第j条边相连的节点的编号</span><br><span class="line">*		g[i][j].second表示距离</span><br><span class="line">*</span><br><span class="line">*输出:	最小生成树的边权和</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">void Prim() &#123;</span><br><span class="line">	memset(v, 0, sizeof(v));</span><br><span class="line">	<span class="keyword">for</span> (int i= 1; i &lt;= <span class="keyword">N</span>; i++) <span class="keyword">dis</span>[i] = <span class="keyword">INF</span>;</span><br><span class="line">	<span class="keyword">dis</span>[1] = 0;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 1; i &lt;= <span class="keyword">N</span>; i++) &#123;</span><br><span class="line">		int <span class="keyword">mark</span> = -1;</span><br><span class="line">		<span class="keyword">for</span>	(int j = 1; j &lt;= <span class="keyword">N</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>	(!v[j])</span><br><span class="line">				<span class="keyword">if</span>	(<span class="keyword">mark</span> == -1) &#123;</span><br><span class="line">					<span class="keyword">mark</span> = j;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">dis</span>[j] &lt; <span class="keyword">dis</span>[<span class="keyword">mark</span>]) <span class="keyword">mark</span> = j;</span><br><span class="line">		<span class="keyword">if</span>	(<span class="keyword">mark</span> = -1) <span class="keyword">break</span>;</span><br><span class="line">		v[<span class="keyword">mark</span>] = 1;</span><br><span class="line">		ans += <span class="keyword">dis</span>[<span class="keyword">mark</span>];</span><br><span class="line">		<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">g</span>[<span class="keyword">mark</span>].size(); j++)</span><br><span class="line">			<span class="keyword">if</span>	(!v[<span class="keyword">g</span>[<span class="keyword">mark</span>][j].first]) &#123;</span><br><span class="line">				int x = <span class="keyword">g</span>[<span class="keyword">mark</span>][j].first;</span><br><span class="line">				<span class="keyword">dis</span>[x] = <span class="literal">min</span>(<span class="keyword">dis</span>[x], <span class="keyword">g</span>[<span class="keyword">mark</span>][j].seceond);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法">Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给出带权无向图，用Kruskal算法求出其权值和最小的生成树。</span><br><span class="line">*</span><br><span class="line">*Kruskal是通过一个贪心的想法：每次去剩下的边权最小的边，如果加上这条边以后图出现了一个环(这个可以</span><br><span class="line">*通过并查集维护)，则破坏了生成树的性质，就不选这条边。依次进行直到整张图出现一棵生成树为止。</span><br><span class="line">*</span><br><span class="line">*int kruskal();</span><br><span class="line">*复杂度：O(MlogM)</span><br><span class="line">*输 入： N, M     全局变量，图中的点数和边数</span><br><span class="line">*       e        全局变量，e[i]表示第i条边的信息(连接x与y，权值为w)</span><br><span class="line">*输 出： 最小生成树的边权和</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> edge&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    edge(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>):x(x), y(y), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fa[x] = getfather(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(e+<span class="number">1</span>, e+M+<span class="number">1</span>, cmp);        <span class="comment">//对边权从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = getfather(fa[e[i].x]);</span><br><span class="line">        <span class="keyword">int</span> t2 = getfather(fa[e[i].y]);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组">树状数组</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*对于数组A[1..n],在O(logn)的时间内完成一下任务:</span><br><span class="line">*(1)给A[i]加上一个数</span><br><span class="line">*(2)求A[1]+...+A[i]的和</span><br><span class="line">*</span><br><span class="line">*树状数组的第i个元素Tree[i]表示A[lowbit(i)+1..i]的和,其中lowbit(i)表示i的最低二进制位.</span><br><span class="line">*当想要查询一个A[1]+...+A[i]的和,可以依据如下算法即可:</span><br><span class="line">*(1)令sum=0,转第(2)步.</span><br><span class="line">*(2)假如i&lt;=0,算法结束,返回sum值,否则sum+=Tree[i],转第(3)步.</span><br><span class="line">*(3)i-=lowbit(i),转第(2)步.</span><br><span class="line">*可以看出,这个算法就是将这一个个区间的和全部加起来,为什么效率是O(logn)的呢?一下给出证明:</span><br><span class="line">*i-=lowbit(i)这一步实际上等价于将i的二进制的最后一个1减去.而i的二进制里最多有logn个1,所以查询效率是O(logn)的.</span><br><span class="line">*而且A[i]加上x的算法如下:</span><br><span class="line">*(1)当i&gt;n时,算法结束,否则转第(2)步.</span><br><span class="line">*(2)Tree[i]+=x, i+=lowbit(i),否则转第(1)步.</span><br><span class="line">*i+=lowbit(i)这个过程实际上也只是一个把末尾1补为0的过程.容易看出复杂度也是O(logn)的.</span><br><span class="line">*最后lowbit(i)的求法有个简单的公式,lowbit(i) = i &amp; (-i).</span><br><span class="line">*</span><br><span class="line">*void add(int x, int value);</span><br><span class="line">*复杂度: O(logn)</span><br><span class="line">*输入: 	 x, value A[x]增加value</span><br><span class="line">*int get(int x)</span><br><span class="line">*复杂度: O(logn)</span><br><span class="line">*输入:	 x 查询A[1]~A[x]的和</span><br><span class="line">*输出:	 A[1]+...+A[x]</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxn为最大容量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> Tree[maxn+<span class="number">10</span>];</span><br><span class="line">inline <span class="keyword">int</span> lwbit(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &amp; -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(<span class="keyword">int</span> x, <span class="keyword">int</span> value)&#123;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = x; i &lt;= maxn; i += lowbit(i))</span><br><span class="line">		Tree[i] += value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> get(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">		sum += Tree[i];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="符号判断">符号判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个double类型的数,判断它的符号.</span><br><span class="line">*</span><br><span class="line">*因为计算几何中经常涉及精度问题,需要对一个很小的数判断正负,所以需要引入</span><br><span class="line">*一个极小量eps.</span><br><span class="line">*</span><br><span class="line">*返回值: -1表示x为负数,1表示x为正数,0表示x为0.</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维点类">二维点类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*设计一个二维点类,可以进行一些向量运算</span><br><span class="line">*</span><br><span class="line">*结构体:point</span><br><span class="line">*成员变量:</span><br><span class="line">*	double x, y		点的坐标</span><br><span class="line">*重载运算符:	+, -, *, /, ==</span><br><span class="line">*成员函数:</span><br><span class="line">*	input()		输入一个点</span><br><span class="line">*	norm()		计算向量的模长</span><br><span class="line">*相关函数:</span><br><span class="line">*	double sqr(double x)							计算一个数的平方</span><br><span class="line">*	double det(cosnt point &amp;a, const point &amp;b)		计算两个向量的叉积</span><br><span class="line">*	double dot(cosnt point &amp;a, const point &amp;b)		计算两个向量的点积</span><br><span class="line">*	double dist(cosnt point &amp;a, const point &amp;b)		计算两个点的距离</span><br><span class="line">*	point rotate_point(cosnt point &amp;p, double A)	向量&lt;OP&gt;绕原点逆时针旋转A(弧度)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(-<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">double</span> sqr(<span class="keyword">double</span> x) &#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct <span class="built_in">point</span> &#123;</span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	<span class="built_in">point</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">point</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b): x(a), y(b) &#123;&#125;</span><br><span class="line">	<span class="keyword">void</span> input() &#123;</span><br><span class="line">		scanf(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator + (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator - (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x - b.x, a.y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend bool operator == (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> cmp(a.x - b.x) == <span class="number">0</span> &amp;&amp; cmp(a.y - b.y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator * (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x * b, a.y * b);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator * (<span class="keyword">const</span> <span class="keyword">double</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a * b.x, a * b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator / (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x / b, a.y / b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="built_in">norm</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(x) + sqr(y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> det(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> dot(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> <span class="built_in">dist</span>(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> (a - b).<span class="built_in">norm</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> rotate_point(<span class="keyword">const</span> <span class="built_in">point</span> &amp;p, <span class="keyword">double</span> A) &#123;</span><br><span class="line">	<span class="keyword">double</span> tx = p.x, ty = p.y;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">point</span>(tx * <span class="built_in">cos</span>(A) - ty * <span class="built_in">sin</span>(A), tx * <span class="built_in">sin</span>(A) + ty * <span class="built_in">cos</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段类">线段类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现一个线段类,可以完成线段的一些计算几何运算.</span><br><span class="line">*</span><br><span class="line">*为了避免精度问题,且实现起来方便,线段用一个有向线段表示.线段类的运算也都使用</span><br><span class="line">*向量运算.在存储时,就存下线段上的两点,用a-&gt;b来表示有向线段.同样也可以用这种方</span><br><span class="line">*法来表示直线.</span><br><span class="line">*</span><br><span class="line">*结构体: line</span><br><span class="line">*成员变量:</span><br><span class="line">*		point a, b 线段的两个端点</span><br><span class="line">*相关函数:</span><br><span class="line">*		line point_make_line(const point a, const point b);</span><br><span class="line">*		用两个点a, b生成的一个线段或直线</span><br><span class="line">*		double dis_point_segment(const point p, const point s, const point t);</span><br><span class="line">*		求p点到线段st的距离</span><br><span class="line">*		void PointProjLine(const point p, const point s, const point t, point &amp; cp);</span><br><span class="line">*		求p点到线段st的垂足,保存在cp中.</span><br><span class="line">*		bool PointOnSegment(point p, point s, point t);</span><br><span class="line">*		判断p点是否在线段st上(包括端点)</span><br><span class="line">*		bool parallel(line a, line b);</span><br><span class="line">*		判断a和b是否平行</span><br><span class="line">*		bool line_make_point(line a, line b, point &amp;res);</span><br><span class="line">*		判断a和b是否相交,如果相交则返回true且交点保存在res中</span><br><span class="line">*		line move_d(line a, const double &amp;len);</span><br><span class="line">*		将直线a沿法向量方向平移距离len得到的直线</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">struct <span class="built_in">line</span> &#123;</span><br><span class="line">	<span class="built_in">point</span> a, b;</span><br><span class="line">	<span class="built_in">line</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">line</span>(<span class="built_in">point</span> x, <span class="built_in">point</span> y): a(x), b(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">line</span> point_make_line(<span class="keyword">const</span> <span class="built_in">point</span> a, <span class="keyword">const</span> <span class="built_in">point</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">line</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> dis_point_segment(<span class="keyword">const</span> <span class="built_in">point</span> p, <span class="keyword">const</span> <span class="built_in">point</span> s, <span class="keyword">const</span> <span class="built_in">point</span> t) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cmp(dot(p-s, t-s)) &lt; <span class="number">0</span>) <span class="keyword">return</span> (p-s).<span class="built_in">norm</span>();</span><br><span class="line">	<span class="keyword">if</span> (cmp(dot(p-t, s-t)) &lt; <span class="number">0</span>) <span class="keyword">return</span> (p-t).<span class="built_in">norm</span>();</span><br><span class="line">	<span class="keyword">return</span> fabs(det(s-p, t-p) / dot(t-s, t-s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> PointProjLine(<span class="keyword">const</span> <span class="built_in">point</span> p, <span class="keyword">const</span> <span class="built_in">point</span> s, <span class="keyword">const</span> <span class="built_in">point</span> t, <span class="built_in">point</span> &amp;cp) &#123;</span><br><span class="line">	<span class="keyword">double</span> r = dot((t-s), (p-s)) / dot(t-s, t-s);</span><br><span class="line">	cp = s + r * (t-s);</span><br><span class="line">&#125;</span><br><span class="line">bool PointOnSegment(<span class="built_in">point</span> p, <span class="built_in">point</span> s, <span class="built_in">point</span> t) &#123;</span><br><span class="line">	<span class="keyword">return</span> cmp(det(p-s, t-s)) == <span class="number">0</span> &amp;&amp; cmp(dot(p-s, p-t)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool parallel(<span class="built_in">line</span> a, <span class="built_in">line</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> !cmp(det(a.a - a.b, b.a - b.b));</span><br><span class="line">&#125;</span><br><span class="line">bool line_make_point(<span class="built_in">line</span> a, <span class="built_in">line</span> b, <span class="built_in">point</span> &amp;res) &#123;</span><br><span class="line">	<span class="keyword">if</span> (parallel(a, b)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">double</span> s1 = det(a.a - b.a, b.b - b.a);</span><br><span class="line">	<span class="keyword">double</span> s2 = det(a.b - b.a, b.b - b.a);</span><br><span class="line">	res = (s1*a.b - s2*a.a) / (s1 - s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">lien move_d(<span class="built_in">line</span> a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;len) &#123;</span><br><span class="line">	<span class="built_in">point</span> d = a.b - a.a;</span><br><span class="line">	d = d / d.<span class="built_in">norm</span>();</span><br><span class="line">	d = retate_point(d, pi/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">line</span>(a.a+d*len, a.b+d*len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多边形类">多边形类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现一个多边形类,完成计算多边形的面积,重心等基本操作.</span><br><span class="line">*</span><br><span class="line">*判断点在多边形内:从该点做一条水平向右的射线,统计射线与多边形相交的情况,若相</span><br><span class="line">*交次数为偶数,则说明该点在形外,否则在形内.为了便于交点在顶点或射线与某些边重</span><br><span class="line">*合时的判断,可以将每条边看成左开右闭的线段,即若交点为左端点则不计算.</span><br><span class="line">*</span><br><span class="line">*结构体: polygon</span><br><span class="line">*成员变量:</span><br><span class="line">*	int n					多边形点数</span><br><span class="line">*	point a[]				多边形顶点坐标(按顺时针顺序)</span><br><span class="line">*成员函数:</span><br><span class="line">*	double perimeter()		计算多边形周长</span><br><span class="line">*	double area()			计算多边形面积</span><br><span class="line">*	int Point_In(point t);	判断点是否在多边形内部</span><br><span class="line">*	复杂度: O(N)</span><br><span class="line">*	输  入:	t	需要判断的点t</span><br><span class="line">*	输	出: 0 	表示t点在多边形外</span><br><span class="line">*			1	表示t点在多边形内</span><br><span class="line">*			2	表示t点在多边形的边界上</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> polygon &#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	point a[maxn];</span><br><span class="line">	polygon() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">perimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		a[n] = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += (a[i+<span class="number">1</span>] - a[i]).norm();</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		a[n] = a[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += det(a[i+<span class="number">1</span>], a[i]);</span><br><span class="line">		<span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Point_In</span><span class="params">(point t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>, i, d1, d2, k;</span><br><span class="line">		a[n] = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PointOnSergment(t, a[i], a[i+<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">			k = cmp(det(a[i+<span class="number">1</span>]-a[i], t-a[i]));</span><br><span class="line">			d1 = cmp(a[i].y - t.y);</span><br><span class="line">			d2 = cmp(a[i+<span class="number">1</span>].y - t.y);</span><br><span class="line">			<span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) num++;</span><br><span class="line">			<span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) num--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num != <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

            
                

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/template/">template</a>

            </div>
        
        <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2012/08/25/tyvj-p1039/"  data-tooltip="TYVJ 忠诚2 线段树">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


        
            <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2015 sillyplus. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="3">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2012/08/25/tyvj-p1039/"  data-tooltip="TYVJ 忠诚2 线段树">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-google-plus"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-facebook-official"></i>
            </a>
        </li>
        <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-twitter"></i>
            </a>
        </li>
        
            <li class="post-action">
                <a class="post-action-btn btn btn--default" href="#disqus_thread">
                    <i class="fa fa-comment-o"></i>
                </a>
            </li>
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents">
            
                <i class="fa fa-list"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="3">
    <ul class="share-options">
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-google-plus"></i><span class="">Share on Google Plus</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
            </a>
        </li>
        <li class="share-option">
            <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://github.com/sillyplus/1970/01/01/1970-1-1-templates/">
                <i class="fa fa-twitter"></i><span>Share on Twitter</span>
            </a>
        </li>
    </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
            
        </div>
        <!-- Define author's picture -->


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="http://www.gravatar.com/avatar/b9c024fee19cd6eabae007b57eaf7e17?s=110"/>
        
            <h4 id="about-card-name">sillyplus</h4>
        
            <h5 id="about-card-bio"><p>Write the code and change the world</p>
</h5>
        
        
            <h5 id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Student</p>

            </h5>
        
        
            <h5 id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China
            </h5>
        
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
    </body>
    <!--SCRIPTS-->
<script src="/assets/js/script.min.js" type="text/javascript"></script>
<!--SCRIPTS END-->

    <script type="text/javascript">
        var disqus_shortname = 'sillyplus';
        (function() {
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>



</html>
