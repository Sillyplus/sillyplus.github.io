<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Kepp It Simple && Stupid]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="https://github.com/sillyplus/"/>
  <updated>2015-10-26T08:03:41.000Z</updated>
  <id>https://github.com/sillyplus/</id>
  
  <author>
    <name><![CDATA[sillyplus]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Xcode插件]]></title>
    <link href="https://github.com/sillyplus/2015/10/26/make-up-your-xcode/"/>
    <id>https://github.com/sillyplus/2015/10/26/make-up-your-xcode/</id>
    <published>2015-10-26T00:41:27.000Z</published>
    <updated>2015-10-26T08:03:41.000Z</updated>
    <content type="html"><![CDATA[<!-- excerpt -->
<h1 id="Alcatraz">Alcatraz</h1><p><a href="http://alcatraz.io/" target="_blank" rel="external">Alcatraz</a> 是一个开源的 Xcode 包管理工具，包管理工具的好处就不用安利了。使用 Alcatraz 带来的便利，自己体验下就知道了。安装以及使用我觉得自行参考官方的说明是最好的了。<br><img src="alcatraz.png" alt=""></p>
<h1 id="Xvim">Xvim</h1><p>总的来说，我是一个 vim 爱好者，所以有时候会很想把 vim 下的一些使用体验延续到 Xcode 开发中，比如使用 hjkl 快速在代码中移动，以及其它各种操作，<a href="https://github.com/XVimProject/XVim">Xvim</a> 就很好的基本上满足了我的需求。Xvim 还有几个附加的命令可以帮助你编译，运行你的项目。</p>
<blockquote>
<p><strong>几个特殊命令</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:run</span>    <span class="comment">#相当于 command-R</span></span><br><span class="line"><span class="symbol">:make</span>   <span class="comment">#相当于 command-B</span></span><br><span class="line"><span class="symbol">:xhelp</span>  <span class="comment">#打开光标所在位置的快速帮助</span></span><br></pre></td></tr></table></figure></p>
<p><strong>遇到的坑</strong><br>我在 Xcode7.1 下，使用 Alcatrz 无法成功安装，找到的一个解决办法是自己下载 Xvim 在<br>GitHub 上的工程，自己编译运行一下即可安装成功，重启 Xcode 后便能生效。</p>
</blockquote>
<h1 id="SCXcodeMinimap">SCXcodeMinimap</h1><p>对于使用过 Sublime Text 的人来说，minimap 的特性一定不会陌生，<a href="https://github.com/stefanceriu/SCXcodeMiniMap">SCXcodeMiniMap</a> 就是一个这样的插件，如果你喜欢 minimap 特性一定不要错过。</p>
<h1 id="VVDocumenter-Xcode">VVDocumenter-Xcode</h1><p><a href="https://github.com/onevcat/VVDocumenter-Xcode">VVDocumenter-Xcode</a> 是人称 <a href="http://www.onevcat.com/" target="_blank" rel="external">猫神</a> 的大牛开发维护的一个快速文档注释插件，支持 OC 还有 swift。</p>
<h1 id="最后附效果图一张">最后附效果图一张</h1><p><img src="233.png" alt=""></p>]]></content>
    <summary type="html">
    <![CDATA[<p>在我看来，Xcode 已经是一个非常强大的IDE，而且苹果公司也一直在它添加新特性，不断的完善。即便 Xcode 已经足够强大了，但是总会有人觉得它不够好，或者想要给它做一些个性化的配置。如果你也有这样的想法的话，那么给 Xcode 安装第三方插件，或者自己给它写插件就是你的不二选择了。</p>]]>
    
    </summary>
    
      <category term="Alcatraz" scheme="https://github.com/sillyplus/tags/Alcatraz/"/>
    
      <category term="Plugins" scheme="https://github.com/sillyplus/tags/Plugins/"/>
    
      <category term="Xcode" scheme="https://github.com/sillyplus/tags/Xcode/"/>
    
      <category term="Xvim" scheme="https://github.com/sillyplus/tags/Xvim/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MacTeX中的一个可用中文的方法]]></title>
    <link href="https://github.com/sillyplus/2014/12/28/usingchineseinTeX/"/>
    <id>https://github.com/sillyplus/2014/12/28/usingchineseinTeX/</id>
    <published>2014-12-27T16:00:00.000Z</published>
    <updated>2015-10-19T10:06:42.000Z</updated>
    <content type="html"><![CDATA[<pre><code><span class="comment"><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%!TEX TS-program = xelatex</span></span><br><span class="line"><span class="comment">%!TEX encoding = UTF-8 Unicode</span></span><br><span class="line"></span><br><span class="line"><span class="command">\documentclass</span><span class="special">[</span>12pt, a4paper<span class="special">]</span><span class="special">&#123;</span>book<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>extsizes<span class="special">&#125;</span>                           <span class="comment">%使用自定义字号</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>fontspec<span class="special">&#125;</span>                           <span class="comment">%字体控制包</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>xltxtra<span class="special">&#125;</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>xunicode<span class="special">&#125;</span>                           <span class="comment">%Unicode</span></span><br><span class="line"><span class="command">\usepackage</span><span class="special">&#123;</span>indentfirst<span class="special">&#125;</span>                        <span class="comment">%中文行首缩进</span></span><br><span class="line"><span class="command">\defaultfontfeatures</span><span class="special">&#123;</span>Mapping=tex-text<span class="special">&#125;</span></span><br><span class="line"><span class="command">\setromanfont</span><span class="special">&#123;</span>Yuanti SC<span class="special">&#125;</span>                        <span class="comment">%设置中文字体</span></span><br><span class="line"><span class="command">\XeTeXlinebreaklocale</span> “zh”</span><br><span class="line"><span class="command">\XeTeXlinebreakskip</span> =<span class="number"> 0pt</span> plus 1pt minus 0.1pt  <span class="comment">%文章内中文自动换行</span></span><br><span class="line"></span><br><span class="line"><span class="command">\newfontfamily</span><span class="special">&#123;</span><span class="command">\H</span><span class="special">&#125;</span><span class="special">&#123;</span>STSong<span class="special">&#125;</span></span><br><span class="line"><span class="command">\newfontfamily</span><span class="special">&#123;</span><span class="command">\E</span><span class="special">&#125;</span><span class="special">&#123;</span>Zapfino<span class="special">&#125;</span></span><br></pre></td></tr></table></figure></span>
</code></pre><p>TeX可以使用的字体大小默认为10pt|11pt|13pt，可以通过使用extsizes这个package来使<br>用其它大小的字体，可选的类型有8～12, 14, 17 和 20pt。</p>
]]></content>
    <summary type="html">
    <![CDATA[<pre><code><span class="comment"><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class]]>
    </summary>
    
      <category term="MacTeX" scheme="https://github.com/sillyplus/tags/MacTeX/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Floyd算法求最小环]]></title>
    <link href="https://github.com/sillyplus/2014/11/04/floyd-and-mincircle/"/>
    <id>https://github.com/sillyplus/2014/11/04/floyd-and-mincircle/</id>
    <published>2014-11-03T16:00:00.000Z</published>
    <updated>2015-10-26T01:55:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="算法思想">算法思想</h2><p>对于构成最小环的点集{x1, x2, …}，其中必定存在一个最大点xk，那么最小环的长度可以由<code>dis[i][j]+m[j][xk]+m[xk][i]</code>来表示，其中i，j均在点集中且小于xk，dis[i][j]是i到j的最短路径。因为xk是点集中最大的那个点，所以i到j的最短路径没有经过编号比xk更大的点。那么要求最小环的长度就可以由小到大枚举一下xk就行了。我们知道，floyd算法最外层每循环一次，就是由一个中间节点k更新点i到j的最短路径。k从小到大枚举，就保证了循环到k的时候，当前i到j的最短路经过的最大节点只可能是k，这刚好满足上面提到的dis[i][j]的定义。所以我们就可以愉快的使用floyd来求最小环了。</p>
<a id="more"></a>
<h2 id="例题">例题</h2><h3 id="vijos_P1046_观光旅游">vijos P1046 观光旅游</h3><p>很裸的描述了，直接求最小环就好了。</p>
<h3 id="Timus_1004-_Sightseeing_Trip">Timus 1004. Sightseeing Trip</h3><p>同上，不过要注意的就是，这个题目要求最小环的路径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, num, ans;</span><br><span class="line"><span class="keyword">int</span> mp[MN][MN], dis[MN][MN], pre[MN][MN];</span><br><span class="line"><span class="keyword">int</span> path[MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_path</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre[a][b]) &#123;</span><br><span class="line">        get_path(a, pre[a][b]);</span><br><span class="line">        get_path(pre[a][b], b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        path[num++] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) &amp;&amp; (n != -<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                mp[i][j] = INF;</span><br><span class="line">                dis[i][j] = INF;</span><br><span class="line">                pre[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a, b, l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">            mp[a][b] = min(mp[a][b], l);</span><br><span class="line">            mp[b][a] = dis[a][b] = dis[b][a] = mp[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = dis[i][j] + mp[j][k] + mp[k][i];</span><br><span class="line">                    <span class="keyword">if</span> (tmp &lt; ans) &#123;</span><br><span class="line">                        ans = tmp;</span><br><span class="line">                        num = <span class="number">0</span>;</span><br><span class="line">                        get_path(i, j);</span><br><span class="line">                        path[num++] = j;</span><br><span class="line">                        path[num++] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="keyword">if</span> (dis[i][j] &gt; tmp) &#123;</span><br><span class="line">                        dis[i][j] = tmp;</span><br><span class="line">                        pre[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans == INF) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No solution."</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="算法思想">算法思想</h2><p>对于构成最小环的点集{x1, x2, …}，其中必定存在一个最大点xk，那么最小环的长度可以由<code>dis[i][j]+m[j][xk]+m[xk][i]</code>来表示，其中i，j均在点集中且小于xk，dis[i][j]是i到j的最短路径。因为xk是点集中最大的那个点，所以i到j的最短路径没有经过编号比xk更大的点。那么要求最小环的长度就可以由小到大枚举一下xk就行了。我们知道，floyd算法最外层每循环一次，就是由一个中间节点k更新点i到j的最短路径。k从小到大枚举，就保证了循环到k的时候，当前i到j的最短路经过的最大节点只可能是k，这刚好满足上面提到的dis[i][j]的定义。所以我们就可以愉快的使用floyd来求最小环了。</p>]]>
    
    </summary>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github Page + Jekyll 博客搭建小记]]></title>
    <link href="https://github.com/sillyplus/2014/10/12/github-jekyll-build-a-blog/"/>
    <id>https://github.com/sillyplus/2014/10/12/github-jekyll-build-a-blog/</id>
    <published>2014-10-11T16:00:00.000Z</published>
    <updated>2015-10-19T10:12:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="占位扯淡"><del>占位扯淡</del></h3><p><del>折腾了几天，终于可以坐下来写点总结了。不过现在是早上三点多快四点，还在想六七点的时候要去踢球，所以只是<br>占个位置而已，熟悉一下。毕竟还有很多东西不会，不过光是搭好现在这个样子就用了挺多时间的(其实也不是很多啦。。。)</del></p>
<a id="more"></a>
<h3 id="博客搭建">博客搭建</h3><h4 id="(ｰ_ｰ;)">(ｰ ｰ;)</h4><p>从搭好这个blog到现在已经好几天了，然后今天发现已经没有来写这样一篇介绍的热情了。。。原因是，介绍这个方面的内容在网上很容易就能找到许多，<br>所以似乎没有必要重复说明，但是每个人的搭建过程都多少还是会遇到各种不同的问题。这里我打算来记录一下我遇到的一些问题吧。</p>
<p>以下这些我都是Mac下做的，因为OS X是类UNIX系统，所以很多都是基本跟Linux下一样的，如果你在搭建过程中遇到什么问题没办法解决，<br>可以尝试在搜索的时候添加跟Linux相关的关键字。</p>
<h4 id="Github_Page的设置">Github Page的设置</h4><p>首先你要有一个Github的账号<del>，这不废话嘛</del>，然后进入这个页面：<a href="https://pages.github.com" target="_blank" rel="external">Github Page</a>,<br>Github Page有两种类型，一种是个人或者组织的站点，一种是作为项目的主页，因为我们是要搭建个人博客，<br>所以选择创建一个User site就好了，然后就是按照引导就能十分轻松的成功创建了。最后把repo存到本地来，<br>另外说一下我用的是Mac的客户端来管理repo的，不是用的命令行，所以对于git的那些命令就不是很清楚了，<br>如果你想了解更多请自行Google。Github Page使用的是Jekyll模版系统，相当于是静态页面发布。</p>
<h4 id="Jekyll的设置">Jekyll的设置</h4><p>这个也是很简单的啊，还是直接看<a href="http://jekyllrb.com/docs/quickstart/" target="_blank" rel="external">官网</a>。我貌似是用brew安装的，<br>不过没差啦。至于怎么使用还是看官网的说明好了(感觉会被喷：什么都说去看官方文档，她喵的我还看你博客干嘛。。。)</p>
<p>在terminal中，进入到你自己本地那个Github Page的repo，然后执行下面的命令创建</p>
<pre><code><span class="title">jekyll</span> build
</code></pre><p>创建成功的话，会得到类似如下的目录结构</p>
<pre><code>.
├── _config.yml
├── _drafts
<span class="string">|   ├── begin-with-the-crazy-ideas.textile</span>
<span class="string">|   └── on-simplicity-in-technology.markdown</span>
├── _includes
<span class="string">|   ├── footer.html</span>
<span class="string">|   └── header.html</span>
├── _layouts
<span class="string">|   ├── default.html</span>
<span class="string">|   └── post.html</span>
├── _posts
<span class="string">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span>
<span class="string">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span>
├── _data
<span class="string">|   └── members.yml</span>
├── _site
└── index.html
</code></pre><p>然后启用本地服务器只需进入到上面的目录中，执行</p>
<pre><code><span class="title">jekyll</span> serve
</code></pre><p>就能在浏览器打开</p>
<pre><code><span class="string">http:</span><span class="comment">//localhost:4000</span>
</code></pre><p>jekyll更多的使用方法可以查看官方说明或者在终端中输入</p>
<pre><code>jekyll <span class="comment">--help</span>
</code></pre><p>在Github上你可以找到许多Jekyll博客的模版，而且其中绝大部分都是你能直接使用的，我也是使用的别人的模版进行简单的修改，<br>如果对这个模版有兴趣，可以进入的我的<a href="https://github.com/Sillyplus">Github主页</a>查看。</p>
<p>现在你就可以愉快的写作啦～＼(^o^)／</p>
<h3 id="wordpress博客迁移">wordpress博客迁移</h3><p>接下来的内容多半是我的吐槽，如果你赶时间去写博客的话可以忽略，如果你实在闲得发慌，不介意的话可以看一看，<br>说不定能发现一点有用的内容。</p>
<p>本来打算顺便说一下域名绑定的，但我在这方面花费的时间比较长主要是自己的问题，绑定之后居然要一整天才能生效，<br>不清楚这个的我也被纠结了很久啦。既然是这样的话，我们就直接进入主题啦～</p>
<p>我之前使用的是wordpress，虽然我已经尽可能的选择一些简单的工具来使用，但是我发现，一堆要维护的东西搞得自己都没办法只是专注于内容了。<br>这也是我为什么决定转到这边来啦，现在直接使用Atom编辑markdown文档，用这种方式来写博文体验真的很好(￣▽￣)。<br>虽然原本的博客内容不多，但还是想要把它们搬到这边来，所以在wordpress里导出了所有博文。导出的是xml的文件，<br>然后使用<a href="https://github.com/thomasf/exitwp">exitwp</a>来从xml文件中提取出内容，并转换成markdown的文档。<br>使用方法看作者的说明就好了，另外，我在运行exitwp.py的时候提示出错</p>
<pre><code>Traceback (most recent <span class="operator"><span class="keyword">call</span> <span class="keyword">last</span>):
  <span class="keyword">File</span> <span class="string">"exitwp.py"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;
    <span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup
ImportError: <span class="keyword">No</span> <span class="keyword">module</span> named bs4</span>
</code></pre><p>然后我在pip list中发现我装的直接是BeautifulSoup，并没有bs4，所以我exitwp.py中的</p>
<pre><code><span class="label">from</span> <span class="keyword">bs4 </span><span class="preprocessor">import</span> <span class="keyword">BeautifulSoup</span>
</code></pre><p>直接改为</p>
<pre><code><span class="preprocessor"><span class="keyword">import</span> BeautifulSoup</span>
</code></pre><p>然后就能成功运行了，这样就导出成功了。如果你对python比较熟悉，你也可以自己修改exitwp.py，使它特定导出你想要的内容。<br>如果你想要从其它博客系统迁移博客过来的话，jekyll的官网上貌似也有相关的教程说明。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="占位扯淡"><del>占位扯淡</h3><p><del>折腾了几天，终于可以坐下来写点总结了。不过现在是早上三点多快四点，还在想六七点的时候要去踢球，所以只是<br>占个位置而已，熟悉一下。毕竟还有很多东西不会，不过光是搭好现在这个样子就用了挺多时间的(其实也不是很多啦。。。)</p>]]>
    
    </summary>
    
      <category term="Github" scheme="https://github.com/sillyplus/tags/Github/"/>
    
      <category term="Jekyll" scheme="https://github.com/sillyplus/tags/Jekyll/"/>
    
      <category term="OSX" scheme="https://github.com/sillyplus/tags/OSX/"/>
    
      <category term="python" scheme="https://github.com/sillyplus/tags/python/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1143 - 飘飘乎居士的约会]]></title>
    <link href="https://github.com/sillyplus/2014/07/25/tyvj-p1143/"/>
    <id>https://github.com/sillyplus/2014/07/25/tyvj-p1143/</id>
    <published>2014-07-25T00:40:48.000Z</published>
    <updated>2015-10-19T11:47:38.000Z</updated>
    <content type="html"><![CDATA[<p>背景 Background</p>
<p>一阵狂风吹过<br>只听“pong”的一声，飘飘乎居士降落了！！！<br>描述 Description</p>
<p>又是美妙的一天，这天飘飘乎居士要和MM约会，因此他打扮的格外帅气。但是，因为打扮的时间花了太久，离约会的时间已经所剩无几。<br>幸运的是，现在飘飘乎居士得到了一张n<em>m的地图，图中左上角是飘飘乎居士的位置，右下角是约会的地点。‘.’代表马路，‘</em>’代表房屋。飘飘乎居士只能沿着‘.’行走（也就是不能踏入‘<em>’），而且行走的方向只能为上下左右的相邻格子。为了不让MM等待太久，飘飘乎居士在整个过程中可能会使用一次飘飘神功（也可能不使用，但最多使用一次），使用飘飘神功后，飘飘乎居士可以走进房屋一次（也就是在全程的行走中最多可以走一个‘</em>’,注意，只有一个）；<br>现在飘飘乎居士想要知道最少需要走多少步，飘飘乎居士才能到达约会的地点。<br><a id="more"></a></p>
<p>输入格式 InputFormat</p>
<p>第一行，2个正整数 n和m，表示一个n<em>m的矩阵<br>接下来n行，每行m个字符，字符一定为 ’.’ 或者是‘</em>’ ，分别代表马路和房屋。<br>输入数据保证左上角和右下角都为‘.’<br>输出格式 OutputFormat</p>
<p>一行，如果可以到达，则输入需要行走的最少步数（飘飘神功也记为一步）<br>如果不可以到达，则输出‘no’<br>样例输入 SampleInput [复制数据]</p>
<p>样例输入1<br>3 3<br>.*.<br>…<br>…</p>
<p>样例输入2<br>3 3<br>.**</p>
<hr>
<p>**.<br>样例输出 SampleOutput [复制数据]</p>
<p>样例输入1<br>4</p>
<p>样例输入2<br>no<br>数据范围和注释 Hint</p>
<p>0&lt;N M &lt;=1000<br>来源 Source</p>
<p>飘飘乎居士——violet hill</p>
<p>//————————————————————–</p>
<p>这道我的做法是分别由起点和终点开始，做两遍bfs，求出各自到其它点的最短距离，然后枚举使用飘飘神功的点，如果起点和终点都可以到达与该点相连并且相异的点就更新一下答案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> pos&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, deep;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;pos&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MN][MN];</span><br><span class="line"><span class="keyword">int</span> a[MN][MN], b[MN][MN];</span><br><span class="line"><span class="keyword">char</span> c[MN][MN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(pos t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = (t.x &gt;= <span class="number">0</span> &amp;&amp; t.y &gt;= <span class="number">0</span> &amp;&amp; t.x &lt; n &amp;&amp; t.y &lt; m);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[t.x][t.y] || (c[t.x][t.y] == <span class="string">'*'</span>)) ret = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(pos sr, <span class="keyword">int</span> d[][MN])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">    q.push(sr);</span><br><span class="line">    vis[sr.x][sr.y] = <span class="literal">true</span>;</span><br><span class="line">    d[sr.x][sr.y] = sr.deep;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        pos now, next;</span><br><span class="line">        now = q.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            next.x = now.x + dx[i];</span><br><span class="line">            next.y = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (check(next)) &#123;</span><br><span class="line">                next.deep = now.deep+<span class="number">1</span>;</span><br><span class="line">                d[next.x][next.y] = next.deep;</span><br><span class="line">                q.push(next);</span><br><span class="line">                vis[next.x][next.y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">63</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">63</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="keyword">int</span> INF = a[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">//!!!!!!</span></span><br><span class="line">    pos sro, orz, l, r;</span><br><span class="line">    sro.x = sro.y = sro.deep = <span class="number">0</span>;</span><br><span class="line">    orz.x = n-<span class="number">1</span>, orz.y = m-<span class="number">1</span>, orz.deep = <span class="number">0</span>;</span><br><span class="line">    bfs(sro, a);</span><br><span class="line">    bfs(orz, b);</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    ans = min(ans, a[n-<span class="number">1</span>][m-<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) <span class="keyword">if</span> (c[i][j] == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; <span class="number">4</span>; p++) &#123;</span><br><span class="line">                l.x = i+dx[p], l.y = j+dy[p];</span><br><span class="line">                <span class="keyword">if</span> (check(l))</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> q = <span class="number">0</span>; q &lt; <span class="number">4</span>; q++) <span class="keyword">if</span> (p != q) &#123;</span><br><span class="line">                        r.x = i+dx[q], r.y = j+dy[q];</span><br><span class="line">                        <span class="keyword">if</span> (check(r)) &#123;</span><br><span class="line">                            ans = min(ans, a[l.x][l.y]+b[r.x][r.y]+<span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans != INF)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>背景 Background</p>
<p>一阵狂风吹过<br>只听“pong”的一声，飘飘乎居士降落了！！！<br>描述 Description</p>
<p>又是美妙的一天，这天飘飘乎居士要和MM约会，因此他打扮的格外帅气。但是，因为打扮的时间花了太久，离约会的时间已经所剩无几。<br>幸运的是，现在飘飘乎居士得到了一张n<em>m的地图，图中左上角是飘飘乎居士的位置，右下角是约会的地点。‘.’代表马路，‘</em>’代表房屋。飘飘乎居士只能沿着‘.’行走（也就是不能踏入‘<em>’），而且行走的方向只能为上下左右的相邻格子。为了不让MM等待太久，飘飘乎居士在整个过程中可能会使用一次飘飘神功（也可能不使用，但最多使用一次），使用飘飘神功后，飘飘乎居士可以走进房屋一次（也就是在全程的行走中最多可以走一个‘</em>’,注意，只有一个）；<br>现在飘飘乎居士想要知道最少需要走多少步，飘飘乎居士才能到达约会的地点。<br>]]>
    
    </summary>
    
      <category term="BFS" scheme="https://github.com/sillyplus/tags/BFS/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1309_刷题的玖君]]></title>
    <link href="https://github.com/sillyplus/2014/07/16/tyvj_p1309/"/>
    <id>https://github.com/sillyplus/2014/07/16/tyvj_p1309/</id>
    <published>2014-07-16T06:40:33.000Z</published>
    <updated>2015-10-19T11:47:32.000Z</updated>
    <content type="html"><![CDATA[<p>描述 Description</p>
<p>某一天在网上闲逛的玖君不小心发现了TYVJ，就立刻被TYVJ吸引住了，果断驻扎下来。玖君决定按照顺序来切题，因为离复赛越来越近了，所以他希望能够用最短时间AC掉前面N道题目，完成第i道题目玖君需要花费t[i]个单位的代价。玖君做题有个特点，他喜欢看完几道题后，一次把几道题的代码写完。如果玖君决定一次写完从编号L到编号R的题目，那么他完成这些题目的总代价等于编号L到R题目的代价之和与R之积，即SUM{t[L..R]} <em>R。此外每道题在被切之前都会等待被切，等待的时间，也被算在代价里面，对于每个第k次被切的题，在它被切之前的等待代价为(k-1)</em>S。综上，切完N道题的总代价=第1次切题的代价+第2次切题的代价+…+第k次切题的代价+每道题的等待代价。现在我们想知道玖君切完这N道题目的最小代价。<br><a id="more"></a><br>输入格式 InputFormat</p>
<p>第1行：2个用空格分开的整数N, S<br>第2行：N个用空格分开的整数，分别表示t[1]到t[N]<br>输出格式 OutputFormat</p>
<p>第1行：1个整数，表示玖君完成N道题的最小代价<br>样例输入 SampleInput [复制数据]</p>
<p>4 7<br>8 1 7 6<br>样例输出 SampleOutput [复制数据]</p>
<p>79<br>数据范围和注释 Hint</p>
<p>[样例解释]<br>第1次切1、2、3题：代价为48<br>第2次切4题：代价为24<br>其中每道题的等待时间代价为:0,0,0,7<br>共计48 + 24 + 7 = 79</p>
<p>[数据范围]<br>对于70%的数据，1 &lt;= N &lt;= 3000<br>对于100%的数据，1 &lt;= N &lt;= 30000<br>对于100%的数据，1 &lt;= S,t[i] &lt;= 100</p>
<p>Dp，然后先求前缀和数组，方便后面用到，设f[i]表示刷完前i个题所花费的最小代价，然后一个比较容易想到的方程就是</p>
<ul>
<li>f[i]=min{f[j]+(sum[i]-sum[j])<em>i+(n-i)</em>S|0&lt;=j&lt;i} //shiugaosuyixiawo(n-i)*sshisuanfeiyongtiqianjisuanma?</li>
</ul>
<p>然后这个显然当N＝30000时是不行的，会T，然后就发现，设用k更新i比用j更优，则</p>
<ul>
<li>f[k] + (sum[i]-sum[k]) <em> i + (n-i)</em>s &gt;=f[j] + (sum[i]-sum[j]) <em> i + (n-i)</em>s</li>
</ul>
<ul>
<li>(f[k]-f[j])/(sum[k]-sum[j])&lt;=i</li>
</ul>
<p>当满足这个条件时，k优于j ，然后就维护一个队列就行了，这个是所谓的斜率优化？还是得好好消化啊，dp水平太次了我。。。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const <span class="keyword">int</span> MN = <span class="number">30010</span>;</span><br><span class="line"></span><br><span class="line">LL n, <span class="keyword">s</span>;</span><br><span class="line">LL f[MN];</span><br><span class="line">LL sum[MN];</span><br><span class="line"><span class="keyword">int</span> <span class="string">q[MN]</span>;</span><br><span class="line"></span><br><span class="line">double grad(<span class="keyword">int</span> j, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((f[k]-f[j])*<span class="number">1.0</span> / (sum[k]-sum[j]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; <span class="keyword">s</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        scanf(<span class="string">"<span class="variable">%lld</span>"</span>, &amp;sum[i]);</span><br><span class="line">        sum[i] += sum[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>, t = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((h &lt; t) &amp;&amp; (grad(<span class="string">q[h]</span>, <span class="string">q[h+1]</span>) &lt;= i)) ++h;</span><br><span class="line">        f[i] = f[<span class="string">q[h]</span>] + (sum[i]-sum[<span class="string">q[h]</span>])*i + (n-i)*<span class="keyword">s</span>;</span><br><span class="line">        <span class="keyword">while</span> ((h &lt; t) &amp;&amp; (grad(<span class="string">q[t-1]</span>, <span class="string">q[t]</span>) &gt;= grad(<span class="string">q[t]</span>, i))) --t;</span><br><span class="line">        <span class="string">q[++t]</span> = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>描述 Description</p>
<p>某一天在网上闲逛的玖君不小心发现了TYVJ，就立刻被TYVJ吸引住了，果断驻扎下来。玖君决定按照顺序来切题，因为离复赛越来越近了，所以他希望能够用最短时间AC掉前面N道题目，完成第i道题目玖君需要花费t[i]个单位的代价。玖君做题有个特点，他喜欢看完几道题后，一次把几道题的代码写完。如果玖君决定一次写完从编号L到编号R的题目，那么他完成这些题目的总代价等于编号L到R题目的代价之和与R之积，即SUM{t[L..R]} <em>R。此外每道题在被切之前都会等待被切，等待的时间，也被算在代价里面，对于每个第k次被切的题，在它被切之前的等待代价为(k-1)</em>S。综上，切完N道题的总代价=第1次切题的代价+第2次切题的代价+…+第k次切题的代价+每道题的等待代价。现在我们想知道玖君切完这N道题目的最小代价。<br>]]>
    
    </summary>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1064_P1404_旧题]]></title>
    <link href="https://github.com/sillyplus/2014/07/16/tyvj_p1064_p1404/"/>
    <id>https://github.com/sillyplus/2014/07/16/tyvj_p1064_p1404/</id>
    <published>2014-07-16T02:20:15.000Z</published>
    <updated>2015-10-19T11:47:26.000Z</updated>
    <content type="html"><![CDATA[<p>这两道题都是从我开始接触tyvj的时候就看过的，可是一直没去写，今天终于。。。</p>
<p>P1064 - 新三国争霸</p>
<p>描述 Description<br>PP 特别喜欢玩即时战略类游戏，但他觉得那些游戏都有美中不足的地方。灾害总不降临道路，而只降临城市，而且道路不能被占领，没有保护粮草的真实性。于是他就研发了《新三国争霸》。<br>在这款游戏中，加入灾害对道路的影响（也就是一旦道路W[i，j]受到了灾害的影响，那么在一定时间内，这条路将不能通过）和道路的占领权（对于一条道路W[i，j]，至少需要K[i，j]个士兵才能守住）。<br>PP可真是高手，不一会，就攻下了N-1座城市，加上原来的就有N座城市了，但他忽略了一点……那就是防守同样重要，不过现在还来的及。因为才打完仗所以很多城市都需要建设，PP估算了一下，大概需要T天。他现在无暇分身进攻了，只好在这T天内好好的搞建设了。所以他秒要派士兵占领一些道路，以确保任何两个城市之间都有路（不然敌人就要分而攻之了，是很危险的）。士兵可不是白干活的，每个士兵每天都要吃掉V的军粮。因为有灾害，所以方案可能有变化（每改变一次就需要K的军粮，初始方案也需要K的军粮）。<br>因为游戏是PP编的，所以他知道什么时候有灾害。PP可是一个很节约的人，他希望这T天在道路的防守上花最少的军粮。<br>N&lt;=300，M&lt;=5000 ，T&lt;=50；<br><a id="more"></a><br>输入格式 InputFormat<br>第一行有5个整数N，M，T，V，K。N表示有城市数，M表示道路数，T表示需要修养的天数，V表示每个士兵每天吃掉的军粮数，K表示修改一次花掉的军粮数。<br>以下M行，每行3个数A，B，C。表示A与B有一条路（路是双向的）需要C个士兵才能守住。<br>第M+2行是一个数P，表示有P个灾害。<br>以下P行，每行4个数，X，Y，T1，T2。表示X到Y的这条路，在T1到T2这几天都会受灾害。</p>
<p>输出格式 OutputFormat<br>T天在道路的防守上花费最少的军粮。</p>
<p>样例输入 SampleInput [复制数据]<br>3 3 5 10 30<br>1 2 1<br>2 3 2<br>1 3 4<br>1<br>1 3 2 5<br>样例输出 SampleOutput [复制数据]<br>180<br>个人感觉一道不错的动态规划题吧，一直不敢下手写，写完真是心旷神怡啊～～<br>设F[i]表示前i天的最少花费，则有<br>F[i] = min(F[i], F[j-1] + mt<em>(i-j+1)</em>v+k)<br>其中，mt表示第j天到第i天的最少花费，也就是在第j天到第i天可通行的道路求一遍最小生成树，一开始我是认为必须在第j天到第i天均不能通行的才不用排兵去收，不过事实好像是只要这期间道路遭遇灾害就可以不用派兵把守了。还是说是我没读懂题意</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MM = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> edge&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp; a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; a.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[MM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, v, k, p;</span><br><span class="line"><span class="keyword">bool</span> can[MM], road[MM][MM];</span><br><span class="line"><span class="keyword">int</span> f[MM/<span class="number">10</span>], fa[MM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fa[x] == x ? x : fa[x] = getfa(fa[x]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(can, <span class="literal">true</span>, <span class="keyword">sizeof</span>(can));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = t1; j &lt;= t2; j++)</span><br><span class="line">            <span class="keyword">if</span> (!road[i][j]) &#123;</span><br><span class="line">                can[i] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (can[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = getfa(e[i].x);</span><br><span class="line">            <span class="keyword">int</span> f2 = getfa(e[i].y);</span><br><span class="line">            <span class="keyword">if</span> (f1 != f2) &#123;</span><br><span class="line">                fa[f1] = f2;</span><br><span class="line">                ret += e[i].w;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">if</span> (cnt == n-<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; v &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;e[i].x, &amp;e[i].y, &amp;e[i].w);</span><br><span class="line">    sort(e+<span class="number">1</span>, e+<span class="number">1</span>+m);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">    <span class="built_in">memset</span>(road, <span class="literal">true</span>, <span class="keyword">sizeof</span>(road));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, t1, t2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x, &amp;y,&amp;t1, &amp;t2);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (((e[j].x == x) &amp;&amp; (e[j].y == y)) || ((e[j].x == y) &amp;&amp; (e[j].y == x))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> tt = t1; tt &lt;= t2; tt++)</span><br><span class="line">                    road[j][tt] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        f[i] = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            f[i] = min(f[i], f[j-<span class="number">1</span>]+kruskal(j, i)*(i-j+<span class="number">1</span>)*v+k);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[t] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>P1404 - [NOIP2010]引水入城</p>
<p>noip的题目，所以网上一堆题解，所以就贴一下自己的代码就好了</p>
<p>主要就是由一个证明说某蓄水池在最后一排城市可到达的是一个连续的区间，然后就可以从第一排开始dfs求出对应区间的左右边界，然后就是一个最小区间覆盖吧，然后数据好像之后500，DP一下就行，然后好像关于最小区间覆盖的话是有一个贪心的解法。以后再想想看。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, root;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[MN][MN];</span><br><span class="line"><span class="keyword">int</span> l[MN], r[MN], f[MN];</span><br><span class="line"><span class="keyword">bool</span> vis[MN][MN];</span><br><span class="line"><span class="keyword">bool</span> last[MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ck</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x &lt;= n &amp;&amp; y &lt;= m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    vis[x][y] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == n) &#123;</span><br><span class="line">        last[y] = <span class="literal">true</span>;</span><br><span class="line">        l[root] = min(l[root], y);</span><br><span class="line">        r[root] = max(r[root], y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">        <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (ck(tx, ty)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[x][y] &gt; a[tx][ty]) &amp;&amp; (!vis[tx][ty]))</span><br><span class="line">                sc(tx, ty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="literal">false</span>, <span class="keyword">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MN; i++)</span><br><span class="line">        l[i] = MN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">1</span>][i] &gt;= a[<span class="number">1</span>][i-<span class="number">1</span>]) &amp;&amp; (a[<span class="number">1</span>][i] &gt;= a[<span class="number">1</span>][i+<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            root = i;</span><br><span class="line">            sc(<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">if</span> (!last[i]) ans++;</span><br><span class="line">    <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        f[i] = MN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l[i]; j &lt;= r[i]; j++)</span><br><span class="line">            f[j] = min(f[j], f[l[i]-<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两道题都是从我开始接触tyvj的时候就看过的，可是一直没去写，今天终于。。。</p>
<p>P1064 - 新三国争霸</p>
<p>描述 Description<br>PP 特别喜欢玩即时战略类游戏，但他觉得那些游戏都有美中不足的地方。灾害总不降临道路，而只降临城市，而且道路不能被占领，没有保护粮草的真实性。于是他就研发了《新三国争霸》。<br>在这款游戏中，加入灾害对道路的影响（也就是一旦道路W[i，j]受到了灾害的影响，那么在一定时间内，这条路将不能通过）和道路的占领权（对于一条道路W[i，j]，至少需要K[i，j]个士兵才能守住）。<br>PP可真是高手，不一会，就攻下了N-1座城市，加上原来的就有N座城市了，但他忽略了一点……那就是防守同样重要，不过现在还来的及。因为才打完仗所以很多城市都需要建设，PP估算了一下，大概需要T天。他现在无暇分身进攻了，只好在这T天内好好的搞建设了。所以他秒要派士兵占领一些道路，以确保任何两个城市之间都有路（不然敌人就要分而攻之了，是很危险的）。士兵可不是白干活的，每个士兵每天都要吃掉V的军粮。因为有灾害，所以方案可能有变化（每改变一次就需要K的军粮，初始方案也需要K的军粮）。<br>因为游戏是PP编的，所以他知道什么时候有灾害。PP可是一个很节约的人，他希望这T天在道路的防守上花最少的军粮。<br>N&lt;=300，M&lt;=5000 ，T&lt;=50；<br>]]>
    
    </summary>
    
      <category term="DFS" scheme="https://github.com/sillyplus/tags/DFS/"/>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="MST" scheme="https://github.com/sillyplus/tags/MST/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1253 - 无聊的战争]]></title>
    <link href="https://github.com/sillyplus/2014/07/06/tyvj_p1253/"/>
    <id>https://github.com/sillyplus/2014/07/06/tyvj_p1253/</id>
    <published>2014-07-06T03:51:11.000Z</published>
    <updated>2015-10-19T11:47:21.000Z</updated>
    <content type="html"><![CDATA[<p>描述 Description</p>
<p>ForeverBell不仅精通破译密码,更是我军的重要代码编写者(至于什么代码,自己想吧).战争的日子是无聊的,有一天,ForeverBell找到了treeboy,出了一个极其简单的问题:给定一段序列,找出这段数列中第k小的数.<br>为了照顾treeboy的超弱语文水平,ForeverBell极其耐心地解释了这个问题:给定一个整数数列num[1…n],序列中的每个数字都不相同.你需要回答一组格式为Q(i,j,k)的查询,表示”在num[i…j]中第k小的数是多少”.<br>由于treeboy不仅语文差,而且代码能力巨弱,所以再次找到了你,请你编写一个程序,应对ForeverBell的询问.<br>输入格式 InputFormat</p>
<p>第一行两个整数n,m.分别是数列的总长度和ForeverBell询问的次数. 1≤n≤100 000，1≤m≤5 000<br>第二行有n个数，代表数列的元素，所有数都不相同，而且不会超过10^9 。<br>接下来有m行，每行三个整数i、j、k，代表一次查询，i、j、k满足：1≤i≤j≤n， 1≤k≤j-i+1。<br>输出格式 OutputFormat</p>
<p>一共m行.第i行表示第i次询问的答案.<br>样例输入 SampleInput [复制数据]</p>
<p>7 3<br>1 5 2 6 3 7 4<br>2 5 3<br>4 4 1<br>1 7 3<br>样例输出 SampleOutput [复制数据]</p>
<p>5<br>6<br>3</p>
<p>这道题算是模版题吧，看了一下说是什么划分树，不懂。。。然后就百度了一下，然后发现百度上的模版直接就能用了，然后就学习了一下，然后我打算把百度百科上的说明copy下来这里方便查阅。。。<br><a id="more"></a><br>划分树是一种基于线段树的数据结构。主要用于快速求出(在log(n)的时间复杂度内）序列区间的第k大值</p>
<h4 id="1简介"><strong>1简介</strong></h4><p>查找整序列的第k大值往往采用快速查找法。然而此方法会破坏原序列，并且需要O(n)的时间复杂度。抑或使用二叉平衡树进行维护，此方法每次查找时间复杂度仅为O(logn)。然而此方法丢失了原序列的顺序信息，无法查找出某区间内的第k大值。</p>
<p>划分树的基本思想就是对于某个区间，把它划分成两个子区间，左边区间的数小于右边区间的数。查找的时候通过记录进入左子树的数的个数，确定下一个查找区间，最后范围缩小到1，就找到了。</p>
<h4 id="2建树"><strong>2建树</strong></h4><p>建树的过程比较简单，对于区间[l,r]，首先通过对原数组的排序找到这个区间的中位数a[mid]，小于a[mid]的数划入他的左子树[l,mid-1]，大于它的划入右子树[mid,r]。同时，对于第i个数，记录在[l,i]区间内有多少数被划入左子树。最后，对它的左子树区间[l,mid-1]和右子树区间[mid,r]递归的继续建树就可以了。<br>建树的时候要注意对于被分到同一子树的元素，元素间的相对位置不能改变。</p>
<h4 id="3查找"><strong>3查找</strong></h4><p>查找的过程中主要问题就是确定将要查找的区间。这个问题有些麻烦。</p>
<p>先看一下查找过程tree_find.他的定义如下：</p>
<p>查找深度为h，在大区间[st,ed]中找小区间[s,e]中的第k元素。<br>再看看他是如何工作的。我们的想法是，先判断[s,e]中第k元素在[st,ed]的哪个子树中，然后找出对应的小区间和k，递归的进行查找，直到小区间的s=e为止。<br>那如何解决这个问题呢？这时候前面记录的进入左子树的元素个数就派上用场了。通过之前的记录可以知道，在区间[st,s-1]中有el[h,s-1]进入左子树，记它为l。同理区间[st,e]中有el[h,e]个数进去左子树，记它为r。所以，我们知道区间小区间[s,e]中有(r-l)个数进入左子树。那么如果(r-l)&gt;=k，那么就在左子树中继续查找，否则就在右子树中继续查找。<br>接着解决查找的小区间的问题。<br>如果接下来要查找的是左子树，那么小区间应该是[st+([st,s-1]区间进入左子树的个数),st+([st,e]区间内进入左子树的个数)-1]，即区间[st+l,st+r-1]。显然，这里k不用变。<br>如果接下来要查找的是右子树，那么小区间应该是[mid+([st,s-1]区间中进入右子树的个数),mid+([st,e]区间进入右子树的个数)-1]。即区间[mid+(s-st-l),mid+(e-st-r)]。显然，这里k要减去区间里已经进入左子树的个数，即k变为k-(r-l)。<br>于是递归继续查找直到s=e即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N <span class="number">100500</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> MID ((l+r)&gt;&gt;<span class="number">1</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], s[N], t[<span class="number">20</span>][N], num[<span class="number">20</span>][N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Build</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lm = MID-l+<span class="number">1</span>, lp = l, rp = MID+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= MID; i++)</span><br><span class="line">        lm -= s[i] &lt; s[MID];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == l)</span><br><span class="line">            num[c][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            num[c][i] = num[c][i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (t[c][i] == s[MID]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lm) &#123;</span><br><span class="line">                lm--;</span><br><span class="line">                num[c][i]++;</span><br><span class="line">                t[c+<span class="number">1</span>][lp++] = t[c][i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t[c+<span class="number">1</span>][rp++] = t[c][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t[c][i] &lt; s[MID]) &#123;</span><br><span class="line">            num[c][i]++;</span><br><span class="line">            t[c+<span class="number">1</span>][lp++] = t[c][i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t[c+<span class="number">1</span>][rp++] = t[c][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">        Build(c+<span class="number">1</span>, l, MID);</span><br><span class="line">        Build(c+<span class="number">1</span>, MID+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span> t[c][l];</span><br><span class="line">    <span class="keyword">int</span> s, ss;</span><br><span class="line">    <span class="keyword">if</span> (l == ql) &#123;</span><br><span class="line">        s = <span class="number">0</span>;</span><br><span class="line">        ss = num[c][qr];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = num[c][ql-<span class="number">1</span>];</span><br><span class="line">        ss = num[c][qr] - num[c][ql-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= ss)</span><br><span class="line">        <span class="keyword">return</span> Query(c+<span class="number">1</span>, l, MID, l+s, l+s+ss-<span class="number">1</span>, k);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Query(c+<span class="number">1</span>, MID+<span class="number">1</span>, r, MID+<span class="number">1</span>+ql-l-s, MID+<span class="number">1</span>+qr-l-s-ss, k-ss);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        s[i] = t[<span class="number">0</span>][i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(s+<span class="number">1</span>, s+<span class="number">1</span>+n);</span><br><span class="line">    Build(<span class="number">0</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(<span class="number">0</span>, <span class="number">1</span>, n, l, r, k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>描述 Description</p>
<p>ForeverBell不仅精通破译密码,更是我军的重要代码编写者(至于什么代码,自己想吧).战争的日子是无聊的,有一天,ForeverBell找到了treeboy,出了一个极其简单的问题:给定一段序列,找出这段数列中第k小的数.<br>为了照顾treeboy的超弱语文水平,ForeverBell极其耐心地解释了这个问题:给定一个整数数列num[1…n],序列中的每个数字都不相同.你需要回答一组格式为Q(i,j,k)的查询,表示”在num[i…j]中第k小的数是多少”.<br>由于treeboy不仅语文差,而且代码能力巨弱,所以再次找到了你,请你编写一个程序,应对ForeverBell的询问.<br>输入格式 InputFormat</p>
<p>第一行两个整数n,m.分别是数列的总长度和ForeverBell询问的次数. 1≤n≤100 000，1≤m≤5 000<br>第二行有n个数，代表数列的元素，所有数都不相同，而且不会超过10^9 。<br>接下来有m行，每行三个整数i、j、k，代表一次查询，i、j、k满足：1≤i≤j≤n， 1≤k≤j-i+1。<br>输出格式 OutputFormat</p>
<p>一共m行.第i行表示第i次询问的答案.<br>样例输入 SampleInput [复制数据]</p>
<p>7 3<br>1 5 2 6 3 7 4<br>2 5 3<br>4 4 1<br>1 7 3<br>样例输出 SampleOutput [复制数据]</p>
<p>5<br>6<br>3</p>
<p>这道题算是模版题吧，看了一下说是什么划分树，不懂。。。然后就百度了一下，然后发现百度上的模版直接就能用了，然后就学习了一下，然后我打算把百度百科上的说明copy下来这里方便查阅。。。<br>]]>
    
    </summary>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="划分树" scheme="https://github.com/sillyplus/tags/%E5%88%92%E5%88%86%E6%A0%91/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1008_Image Encoding]]></title>
    <link href="https://github.com/sillyplus/2014/07/05/timus_1008_image-encoding/"/>
    <id>https://github.com/sillyplus/2014/07/05/timus_1008_image-encoding/</id>
    <published>2014-07-05T07:37:28.000Z</published>
    <updated>2015-10-19T11:47:13.000Z</updated>
    <content type="html"><![CDATA[<p>我应该怎么说这道题好呢，只能怪自己英语没有学好吧T^T，为什么造福小众，我决定不翻译题意了，大家自己看吧。。。。<br><a id="more"></a><br>There are several ways to encode an image. In this problem we will consider two representations of an image. We assume that the image consists of black and white pixels. There is at least one black pixel and all black pixels are connected with their sides. Coordinates of black pixels are not less than 1 and not greater than 10. An example of such an image is at the figure.</p>
<p>Both representations describe arrangement of black pixels only.</p>
<p>At the first representation we specify in the first line number of black pixels and coordinates of each black pixel in the following lines. Pixels are listed in order of increasing X. In case of equality of X they are listed in order of increasing Y. Image at the figure is encoded as follows:</p>
<p><strong>6<br>2 3<br>2 4<br>3 3<br>3 4<br>4 2<br>4 3
</strong></p>
<p>At the second representation we specify in the first line coordinates of the lowest left black pixel. Each of the following lines contains a description of neighbors for one of the pixels. At first, neighbors of the lowest left pixel are specified, then neighbors of its first neighbor (if it exists) are specified, then neighbors of its second neighbor (if it also exists) follow. When all its neighbors are described the description of the neighbors of its first neighbor follows. The description of the neighbors of its second neighbor follows then and so on.</p>
<p>Each descriptive line contains at most one letter for each neighbor: R for the right, T for the top, L for the left, B for the bottom. If the neighbor was already specified it is not included into the descriptive line and vice-versa. Also there is only one descriptive line for each pixel. Neighbors are listed counter-clockwise starting with the right. Each descriptive line except the last ends with a comma. The last line ends with a full stop. Image at the figure is encoded as follows:</p>
<p><strong>2 3<br>RT,<br>RT,<br>,<br>B,<br>,<br>.
</strong></p>
<p>There are no leading or tailing spaces in any representation. There is exactly one space between X and Y coordinates.</p>
<h3 id="Input">Input</h3><p>One representation of the image will be given to your program in the input.</p>
<h3 id="Output">Output</h3><p>Your program has to write other representation of the image to the output.</p>
<h3 id="Sample">Sample</h3><table class="sample"><br><tbody><br><tr><br>input<br>output<br></tr><br><tr><br><br><td><br><br><br>    6<br>    2 3<br>    2 4<br>    3 3<br>    3 4<br>    4 2<br>    4 3<br><br><br><br><br></td><br><br><td><br><br><br>    2 3<br>    RT,<br>    RT,<br>    ,<br>    B,<br>    ,<br>    .<br><br><br><br><br></td><br></tr><br></tbody><br></table>


<p><strong>Problem Source: </strong>Third Open USTU Collegiate Programming Contest (PhysTech Cup), March 18, 2000</p>
<p>我只想说重点在最后几句话。。可能只有我没看清楚吧。。。。<br>看懂题意之后就会发现整个转换的过程其实就是bfs吧，然后就硬上了。一开始我由于没看清楚题意只写了一个转换，wa了几次，后来经过谷哥翻译才发现有这么个坑。<br>然后读入数据有点麻烦，总之就是我最不擅长的东西，还有要记得是逆时针方向，搜的时候。然后我就因为不明原因一直爆内存。。。。后来的后来，把原本读入字符数组的部分改成读字符串后不知道为什么就过了。。。。白白D了那么久的bug了。。。。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> pt&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans, vx, vy;</span><br><span class="line"><span class="keyword">bool</span> vis[MN][MN];</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">pt a[MN*MN];</span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'R'</span>, <span class="string">'T'</span>, <span class="string">'L'</span>, <span class="string">'B'</span>&#125;, b[MN];</span><br><span class="line"><span class="built_in">queue</span>&lt;pt&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> pt &amp;pa, <span class="keyword">const</span> pt &amp;pb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pa.x != pb.x) <span class="keyword">return</span> pa.x &lt; pb.x;</span><br><span class="line">    <span class="keyword">return</span> pa.y &lt; pb.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfsa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pt now, next;</span><br><span class="line">    <span class="built_in">string</span> dir;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        now = q.front();</span><br><span class="line">        a[ans] = now;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dir;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dir.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> tc = dir[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c[j] == tc) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next.x = now.x + dx[j];</span><br><span class="line">            next.y = now.y + dy[j];</span><br><span class="line">            q.push(next);</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfsb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pt now, next;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        now = q.front();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = now.x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = now.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (vis[tx][ty] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; c[i];</span><br><span class="line">                vis[tx][ty] = <span class="number">0</span>;</span><br><span class="line">                next.x = tx;</span><br><span class="line">                next.y = ty;</span><br><span class="line">                q.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">if</span> (ans != n)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">",\n"</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">".\n"</span>;</span><br><span class="line">        q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    pt k;</span><br><span class="line">    <span class="keyword">if</span> (s.find(<span class="string">' '</span>) != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">        s.copy(b, s.find(<span class="string">' '</span>), <span class="number">0</span>);</span><br><span class="line">        vx = atoi(b);</span><br><span class="line">        s.copy(b, <span class="number">100</span>, s.find(<span class="string">' '</span>) + <span class="number">1</span>);</span><br><span class="line">        vy = atoi(b);</span><br><span class="line">        pt k;</span><br><span class="line">        k.x = vx;</span><br><span class="line">        k.y = vy;</span><br><span class="line">        q.push(k);</span><br><span class="line">        bfsa();</span><br><span class="line">        sort(a, a+ans, comp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; a[i].x &lt;&lt; <span class="string">' '</span> &lt;&lt; a[i].y &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = atoi(s.c_str());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; k.x &gt;&gt; k.y;</span><br><span class="line">            vis[k.x][k.y] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(k);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; k.x &lt;&lt; <span class="string">' '</span> &lt;&lt; k.y &lt;&lt; endl;</span><br><span class="line">                vis[k.x][k.y] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        bfsb();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我应该怎么说这道题好呢，只能怪自己英语没有学好吧T^T，为什么造福小众，我决定不翻译题意了，大家自己看吧。。。。<br>]]>
    
    </summary>
    
      <category term="BFS" scheme="https://github.com/sillyplus/tags/BFS/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1297 - 小气的小B]]></title>
    <link href="https://github.com/sillyplus/2014/07/04/tyvj_p1297/"/>
    <id>https://github.com/sillyplus/2014/07/04/tyvj_p1297/</id>
    <published>2014-07-03T22:34:13.000Z</published>
    <updated>2015-10-19T11:45:38.000Z</updated>
    <content type="html"><![CDATA[<p>经典问题，RMQ，不过为了增加一下文章长度，我打算贴一下题目<br><a id="more"></a><br>描述 Description</p>
<p>其实你们都不知道，小B是很小气的。一天小B带着他的弟弟小B’一起去摘果子，走着走着，他们忽然发现了一颗长满了果子的树。由于弟弟长得太矮了，弟弟只有让哥哥小B帮他摘一些果子下来。哥哥小B说:”弟弟啊，不是我不想给你摘多，我只是一次拿不了那么多，昨天晚上又没睡好，只能上一次树。所以哥哥只能给你摘一个哈。”没办法，弟弟只有答应了这个要求。<br>于是几下小B就上了树，树上的果子还真多，有N个呢！！但是小B很快发现这些果子大小不一。抠门的小B就想给自己拿个最大的，给弟弟拿个最小的果子。但是由于树上有些果子太高，小B不一定可以够着，所以他给你选了P个可以够着的果子区间，让你在这些区间里面找一个最大的果子和一个最小的果子。</p>
<p>输入格式 InputFormat</p>
<p>共p+2行，<br>第一行为n和p，<br>第二行为区间[1,n]的果子大小（用正整数表示）<br>后面p行形如a b，意为每次询问的区间的左界和右界</p>
<p>输出格式 OutputFormat</p>
<p>共p行，第i行为第i次询问时得到的最大值以及最小值（一个询问用空格空开max和min）</p>
<p>【注意】在输入数据中果子的大小是无序的。</p>
<p>样例输入 SampleInput [复制数据]</p>
<p>5 2<br>1 3 2 4 5<br>1 4<br>2 5</p>
<p>样例输出 SampleOutput [复制数据]</p>
<p>4 1<br>5 2</p>
<p>数据范围和注释 Hint</p>
<p>【数据范围】<br>保证果子大小不超过maxlongint<br>40%的数据：  1&lt;=n,p&lt;=1,000<br>100%的数据：1&lt;=n&lt;=50,000<br>1&lt;=p&lt;=20,000</p>
<p>有很多种解法啦，线段树也可以，之前我还写过一篇<a href="http://sillyplus.com/2013/06/98/" target="_blank" rel="external">块状数组</a>的也能解决这个问题，然后就是今天复习了一下st算法，所以就用st写了，关于st算法的话可以看看Archive里面的模版。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[MN][<span class="number">32</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> a[MN], pl[MN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    pl[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pl[i] = pl[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; (pl[i]+<span class="number">1</span>)) == i) &#123;</span><br><span class="line">            pl[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        st[i][<span class="number">0</span>][<span class="number">0</span>] = st[i][<span class="number">0</span>][<span class="number">1</span>] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span>) &lt; n; j++) &#123;</span><br><span class="line">            st[i][j][<span class="number">0</span>] = max(st[i][j-<span class="number">1</span>][<span class="number">0</span>], st[i + (<span class="number">1</span> &lt;&lt; (j-<span class="number">1</span>))][j-<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            st[i][j][<span class="number">1</span>] = min(st[i][j-<span class="number">1</span>][<span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j-<span class="number">1</span>))][j-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    stp(n);</span><br><span class="line">    <span class="keyword">int</span> l, r, len, k, mx, mi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        l--;</span><br><span class="line">        r--;</span><br><span class="line">        len = r-l+<span class="number">1</span>;</span><br><span class="line">        k = pl[len];</span><br><span class="line">        mx = max(st[l][k][<span class="number">0</span>], st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k][<span class="number">0</span>]);</span><br><span class="line">        mi = min(st[l][k][<span class="number">1</span>], st[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k][<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mx, mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>经典问题，RMQ，不过为了增加一下文章长度，我打算贴一下题目<br>]]>
    
    </summary>
    
      <category term="ST" scheme="https://github.com/sillyplus/tags/ST/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj_P1323 - 识别水果]]></title>
    <link href="https://github.com/sillyplus/2014/07/03/tyvj_p1323/"/>
    <id>https://github.com/sillyplus/2014/07/03/tyvj_p1323/</id>
    <published>2014-07-03T08:14:02.000Z</published>
    <updated>2015-10-19T11:45:30.000Z</updated>
    <content type="html"><![CDATA[<p>本来说好的每日一题解，因为下午睡了一觉醒来发现已经快十点了，然后才开始做题。。然后发现现在已经过了十二点了。。。</p>
<p>题目可以在这里看：<a href="http://www.tyvj.cn/Problem_Show.aspx?id=1323" target="_blank" rel="external">传送门</a></p>
<p>然后这可以说是一道陈年老题了，我从高中的时候就打算要写，然后一直拖到现在-_-#，根据题意很容易想到可以用并查集来解决，我们可以添加一个节点0，然后有毒的水果都合并到0，然后最后统计一下有多少水果是有毒的就行了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">30</span>], b[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, k, p;</span><br><span class="line"><span class="keyword">int</span> f[MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">cv</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == a[j]) &#123;</span><br><span class="line">                ret += b[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[v] = f[v] == v ? v : find(f[v]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k &gt;&gt; s;</span><br><span class="line">        s = cv(s);</span><br><span class="line">        <span class="keyword">int</span> t = s.find(<span class="string">"poison"</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; s.length())</span><br><span class="line">            f[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == <span class="number">0</span> || fy == <span class="number">0</span>) &#123;</span><br><span class="line">            f[fx] = <span class="number">0</span>;</span><br><span class="line">            f[fy] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = find(i);</span><br><span class="line">        <span class="keyword">if</span> (f[i] == <span class="number">0</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n-ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ps：我这哪还是在写题解。。。这样下去真的可以吗T^T</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来说好的每日一题解，因为下午睡了一觉醒来发现已经快十点了，然后才开始做题。。然后发现现在已经过了十二点了。。。</p>
<p>题目可以在这里看：<a href="http://www.tyvj.cn/Problem_Show.aspx?id=1323">传送门</a></p>
<p>然后这可以说是一道陈年老题了，我从高中的时候就打算要写，然后一直拖到现在-_-#，根据题意很容易想到可以用并查集来解决，我们可以添加一个节点0，然后有毒的水果都合并到0，然后最后统计一下有多少水果是有毒的就行了。<br>]]>
    
    </summary>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="并查集" scheme="https://github.com/sillyplus/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1727_Znaika's Magic Numbers]]></title>
    <link href="https://github.com/sillyplus/2014/07/02/timus_1727_znaikas-magic-numbers/"/>
    <id>https://github.com/sillyplus/2014/07/02/timus_1727_znaikas-magic-numbers/</id>
    <published>2014-07-01T16:00:00.000Z</published>
    <updated>2015-10-19T11:45:23.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意：给你一个N (0 &lt; N &lt; 10^5)，把N分解成若干个不相同且值不超过10^5的整数的各个位数的和，例如：N＝17时有，17 ＝ 7 ＋ 1 ＋ 2 ＋ 4 ＋ 3，所以17可以分解成7， 12， 43，这三个不同的整数。</p>
<p>题目其实是比较简单的，解法也有很多种，我就说一个我认为比较有趣的解法。我们可以每次把N加到所求的整数集合里面，然后再把N减去自身各位数字的和得到新的N’，直到N等于零。正确性也很容易验证，注意到我们每次往集合里添加的数必然都是递减的，这就保证了无重复数字的出现，然后按照生成的规则可知，减到N为0的时候自然集合里的所有数的各位数字之和就为最初的N了。<br><a id="more"></a><br>其他解法：比如说先把1～99999，每个数的位数和算出来，然后排个序，然后就由大到小减等等。。。</p>
<p>烂烂的还是贴下代码。。。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator its;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ds</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ret += (x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        v.push_back(n);</span><br><span class="line">        n -= ds(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.size() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (its = v.begin(); its != v.end(); its++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *its &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意：给你一个N (0 &lt; N &lt; 10^5)，把N分解成若干个不相同且值不超过10^5的整数的各个位数的和，例如：N＝17时有，17 ＝ 7 ＋ 1 ＋ 2 ＋ 4 ＋ 3，所以17可以分解成7， 12， 43，这三个不同的整数。</p>
<p>题目其实是比较简单的，解法也有很多种，我就说一个我认为比较有趣的解法。我们可以每次把N加到所求的整数集合里面，然后再把N减去自身各位数字的和得到新的N’，直到N等于零。正确性也很容易验证，注意到我们每次往集合里添加的数必然都是递减的，这就保证了无重复数字的出现，然后按照生成的规则可知，减到N为0的时候自然集合里的所有数的各位数字之和就为最初的N了。<br>]]>
    
    </summary>
    
      <category term="Math" scheme="https://github.com/sillyplus/tags/Math/"/>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus 1028 1318 [树状数组]]]></title>
    <link href="https://github.com/sillyplus/2014/07/01/timus_1028_1318/"/>
    <id>https://github.com/sillyplus/2014/07/01/timus_1028_1318/</id>
    <published>2014-06-30T19:56:24.000Z</published>
    <updated>2015-10-19T11:45:16.000Z</updated>
    <content type="html"><![CDATA[<h4 id="除草向"><em>除草向</em></h4><p>博客好久没有更新了，自从打完补选赛之后就一直一副颓废状态，外加要期末考，得预习课内知识(虽然我到最后还是。。。)，不管怎么样，现在以及放假了，所以我打算兑现之前对自己的承诺，暑假好好做题，所以这段时间应该会比较经常更新一些水题的题解啦( ´ ▽ ` )ﾉ。昨天选拔赛第一场就爆零滚粗，作为一名候补选手，我只剩下今天这个最后一次机会了，好伤感的说T^T，希望写一写题解涨张RP。。。<br><a id="more"></a><br>吐槽完毕，接下来进入正题啦～ ，虽然以前偶尔也又写过树状数组的题目，不过基本就没去记住，然后每次都得看模版。。。这两天写了两三次，终于记住啦啦啦啦</p>
<ol>
<li>Star</li>
</ol>
<p>题目大衣：一个二维平面上又N (1 ≤ <em>N</em> ≤ 15000)个点(0 ≤ <em>X</em>,<em>Y</em> ≤ 32000)，然后定义每个点的level，对于点i，它的level为横纵坐标均不大于点i的点的个数。要求输出0～N-1的各个level的的点数。</p>
<p>这道题的只要求出每个点的level，统计一下就行了。然后就是求level的办法了，我们首先可以把每个点先按x递增，然后y递增的顺序排序。这样x就有序了，然后我们顺序处理每个点，对一个点Pi，已知点Pj(j&lt;i)的x不大于Pi的x，然后要做的就是统计一下Pj中y小于等于Pi的y的个数。我们用c[i]表示y为i的点的个数，Pi的level值就为sum＝ c[0] + c[1] + .. + c[y-1], 然后再更新一下c数组，c[y]+1,以上都可以用树状数组来解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">32001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> pt&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pt a[MN/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> level[MN/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> t[MN+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> pt &amp;a, <span class="keyword">const</span> pt &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">    <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= MN; i += lowbit(i))</span><br><span class="line">        t[i] += value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">        sum += t[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, a+n, comp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = a[i].y+<span class="number">1</span>;</span><br><span class="line">        level[get(k)]++;</span><br><span class="line">        add(k, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, level[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Electronic Auction</li>
</ol>
<p>题目大衣：好像是拍卖铁猪来着，价格0.01～10000.00，最多两位小数。然后有几个操作：</p>
<ul>
<li>BID X   以X元竞标一头猪</li>
</ul>
<ul>
<li>DEL X  取消一个价格为X的竞标</li>
</ul>
<ul>
<li>SALE X K  以X元卖掉K头猪</li>
</ul>
<ul>
<li>QUIT  结束输入</li>
</ul>
<p>对于每一个SALE，前K个出价不小于X的客户可以得到一头猪，如果不够K个客户满足条件，自然是能买出多少就多少了，每卖出一头获利0.01，求最大获利好像差不多就是这样了把。</p>
<p>然后其实我们可以把每个数乘上100，就变成整数，不过直接这样好像会有精度问题，我因此WA了几次，后来看了讨论区，弄了个修正的办法。数组a[i]表示出价X的客户数，然后就直接套树状数组了吧，SALE的时候就是求a[i]~a[maxn],这个一个除法也就出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">int</span> f[MN+<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= MN; i += lowbit(i))</span><br><span class="line">        f[i] += value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">        sum += f[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span> (str[<span class="number">0</span>] != <span class="string">'Q'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'B'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;d);</span><br><span class="line">            add(<span class="keyword">int</span>(d*<span class="number">100</span> + <span class="number">0.5</span>), <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'D'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;d);</span><br><span class="line">            add(<span class="keyword">int</span>(d*<span class="number">100</span> + <span class="number">0.5</span>), -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;d, &amp;k);</span><br><span class="line">            <span class="keyword">int</span> t = <span class="keyword">int</span>(d*<span class="number">100</span> + <span class="number">0.5</span>);</span><br><span class="line">            <span class="keyword">int</span> ts = get(MN) - get(t-<span class="number">1</span>);</span><br><span class="line">            ans += min(k, ts);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    &#125;</span><br><span class="line">    ans /= <span class="number">100.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为赶着要去吃饭然后打选拔赛去了，所以后面没怎么想好表达就乱写了，实在想在比赛前写完。故事不会就这样终结的，</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="除草向"><em>除草向</em></h4><p>博客好久没有更新了，自从打完补选赛之后就一直一副颓废状态，外加要期末考，得预习课内知识(虽然我到最后还是。。。)，不管怎么样，现在以及放假了，所以我打算兑现之前对自己的承诺，暑假好好做题，所以这段时间应该会比较经常更新一些水题的题解啦( ´ ▽ ` )ﾉ。昨天选拔赛第一场就爆零滚粗，作为一名候补选手，我只剩下今天这个最后一次机会了，好伤感的说T^T，希望写一写题解涨张RP。。。<br>]]>
    
    </summary>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="树状数组" scheme="https://github.com/sillyplus/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1106_Two Teams]]></title>
    <link href="https://github.com/sillyplus/2014/05/21/timus_1106_two-teams/"/>
    <id>https://github.com/sillyplus/2014/05/21/timus_1106_two-teams/</id>
    <published>2014-05-21T09:17:54.000Z</published>
    <updated>2015-10-19T11:45:05.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意：给一个无向图，N个顶点(n&lt;=100,好小的样子。。)，要求把这N个顶点分成两组，使得对任一个组中的每个顶点，都至少存在一条边连接到另一组中的某个顶点，要求给出任一满足条件的分组，输出其中一个组的顶点编号。</p>
<p>话说一开始看完题目我想到的是二分图，应该是可以做的，不过本题似乎不必那么麻烦。因为题目给的条件相当宽松，我们可以对每个顶点进行染色，从某个为染色的顶点出发，把跟它相邻同时还没有染色的顶点染色跟它相反的颜色，然后就这样一直搜下去好了，要注意的就是整个图可能存在多个联通块，然后应该就没有然后了吧。。。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MN];</span><br><span class="line"><span class="keyword">int</span> vit[MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    vit[x] = color;</span><br><span class="line">    color = (color == <span class="number">1</span> ? <span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (!vit[g[x][i]]) dfs(g[x][i], color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vit, <span class="number">0</span>, <span class="keyword">sizeof</span>(vit));</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        <span class="keyword">while</span> (k) &#123;</span><br><span class="line">            g[i].push_back(k);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vit[i]) dfs(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!vit[i]) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vit[i] == <span class="number">1</span>) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (vit[i] == <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意：给一个无向图，N个顶点(n&lt;=100,好小的样子。。)，要求把这N个顶点分成两组，使得对任一个组中的每个顶点，都至少存在一条边连接到另一组中的某个顶点，要求给出任一满足条件的分组，输出其中一个组的顶点编号。</p>
<p>话说一开始看完题目我想到的是二分图，应该是可以做的，不过本题似乎不必那么麻烦。因为题目给的条件相当宽松，我们可以对每个顶点进行染色，从某个为染色的顶点出发，把跟它相邻同时还没有染色的顶点染色跟它相反的颜色，然后就这样一直搜下去好了，要注意的就是整个图可能存在多个联通块，然后应该就没有然后了吧。。。<br>]]>
    
    </summary>
    
      <category term="DFS" scheme="https://github.com/sillyplus/tags/DFS/"/>
    
      <category term="Graph" scheme="https://github.com/sillyplus/tags/Graph/"/>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1024_Permutations]]></title>
    <link href="https://github.com/sillyplus/2014/05/15/timus_1024_permutations/"/>
    <id>https://github.com/sillyplus/2014/05/15/timus_1024_permutations/</id>
    <published>2014-05-14T16:29:38.000Z</published>
    <updated>2015-10-19T11:44:59.000Z</updated>
    <content type="html"><![CDATA[<p>因为题目的编号是2^10，所以决定写一下题解。</p>
<p>题目大意：给出一个n阶的置换P，问P的多少次幂等于单位元E。n &lt;= 1000，保证答案不超过1e9.</p>
<p>如果有一点置换群的知识的话就很好解决了，其实题目也就清楚的告诉你是怎么置换了。我们知道在置换群中有这样一个定理</p>
<ul>
<li>任何一个置换都可以表示成若干循环的乘积</li>
</ul>
<p>关于循环的概念，相信应该不难理解，简单点说就是根据题目，_P_k(x) ＝ x，__则在置换过程中得到的k个数便构成一个k阶的循环。题目要求的答案便是k1, k2…..kn的最小公倍数。显然，对于1～n，每个数字仅会出现在一个循环当中，同一个循环中的数对于的k便是一样的。这样复杂度就可以做到O(nlogn)，由于n只有1000，我就懒得去标记什么的了，直接用O(n^2 logn)的做法。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b == <span class="number">0</span>) ? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f[i];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = f[i], loop = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != i) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans * (loop / gcd(ans, loop));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>期间WA过一次，原因是这个</p>
<ul>
<li>ans = ans * (loop / gcd(ans, loop));</li>
</ul>
<p>写成这样子</p>
<ul>
<li>ans = ans * loop / gcd(ans, loop);</li>
</ul>
<p>但是没用long long 结果就乘爆了，使用上面的式子并用int，以及时候下面的式子并使用long long，后者在时间以及空间上十分微妙的更优一些，这是为什么呢，因为括号的缘故？求科普啊。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>因为题目的编号是2^10，所以决定写一下题解。</p>
<p>题目大意：给出一个n阶的置换P，问P的多少次幂等于单位元E。n &lt;= 1000，保证答案不超过1e9.</p>
<p>如果有一点置换群的知识的话就很好解决了，其实题目也就清楚的告诉你是怎么置换了。我们知道在置换群中有这样一个定理</p>
<ul>
<li>任何一个置换都可以表示成若干循环的乘积</li>
</ul>
<p>关于循环的概念，相信应该不难理解，简单点说就是根据题目，_P_k(x) ＝ x，__则在置换过程中得到的k个数便构成一个k阶的循环。题目要求的答案便是k1, k2…..kn的最小公倍数。显然，对于1～n，每个数字仅会出现在一个循环当中，同一个循环中的数对于的k便是一样的。这样复杂度就可以做到O(nlogn)，由于n只有1000，我就懒得去标记什么的了，直接用O(n^2 logn)的做法。<br>]]>
    
    </summary>
    
      <category term="Math" scheme="https://github.com/sillyplus/tags/Math/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1122_Game]]></title>
    <link href="https://github.com/sillyplus/2014/05/08/timus_1122_game/"/>
    <id>https://github.com/sillyplus/2014/05/08/timus_1122_game/</id>
    <published>2014-05-08T06:30:49.000Z</published>
    <updated>2015-10-19T11:44:47.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意：给出一个4×4的用黑白两色棋子覆盖的棋盘状态，以及选择任意某一棋子以其为中心进行翻转的一个3×3的01翻转规则，1为翻转，0则不翻转，问能否经过若干次操作，是的整个棋盘变成同一种颜色。</p>
<p>其实题目比较简单，类似的题也做过几道了。显然每个棋子以其为中心最多翻转一次。这样总共16个棋子也就是有2ˆ16种状态，然后就直接枚举每一种情况。然后我居然因为一个数组开小了，一直WA。最近真的脑子有点乱乱的=_=，刚才终于让我De完bug了，所以写写题解放松一下。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;, a[<span class="number">8</span>][<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;, b[<span class="number">4</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>][<span class="number">4</span>], dy[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++)</span><br><span class="line">            a[x+dx[i][j]][y+dy[i][j]] = a[x+dx[i][j]][y+dy[i][j]] ^ b[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">            a[i][j] = f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        dy[i][<span class="number">1</span>] = dx[<span class="number">1</span>][i] = -<span class="number">1</span>;</span><br><span class="line">        dy[i][<span class="number">2</span>] = dx[<span class="number">2</span>][i] = <span class="number">0</span>;</span><br><span class="line">        dy[i][<span class="number">3</span>] = dx[<span class="number">3</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'B'</span>) f[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            b[i][j] = c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span> &lt;&lt; <span class="number">17</span>, x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">16</span>); i++) &#123;</span><br><span class="line">        get();</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>, k = i, bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                bit++;</span><br><span class="line">                k /= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = (bit-<span class="number">1</span>)/<span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">            y = (bit % <span class="number">4</span> == <span class="number">0</span>) ? <span class="number">4</span> : bit%<span class="number">4</span>;</span><br><span class="line">            convert(x, y);</span><br><span class="line">            tmp++;</span><br><span class="line">            bit++;</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check()) ans = min(ans, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; (<span class="number">1</span> &lt;&lt; <span class="number">17</span>)) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意：给出一个4×4的用黑白两色棋子覆盖的棋盘状态，以及选择任意某一棋子以其为中心进行翻转的一个3×3的01翻转规则，1为翻转，0则不翻转，问能否经过若干次操作，是的整个棋盘变成同一种颜色。</p>
<p>其实题目比较简单，类似的题也做过几道了。显然每个棋子以其为中心最多翻转一次。这样总共16个棋子也就是有2ˆ16种状态，然后就直接枚举每一种情况。然后我居然因为一个数组开小了，一直WA。最近真的脑子有点乱乱的=_=，刚才终于让我De完bug了，所以写写题解放松一下。<br>]]>
    
    </summary>
    
      <category term="Search" scheme="https://github.com/sillyplus/tags/Search/"/>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_一周做题记录]]></title>
    <link href="https://github.com/sillyplus/2014/05/04/timus-a-week/"/>
    <id>https://github.com/sillyplus/2014/05/04/timus-a-week/</id>
    <published>2014-05-04T03:53:51.000Z</published>
    <updated>2015-10-19T11:44:41.000Z</updated>
    <content type="html"><![CDATA[<p>虽然很多是水题，不过还是记录一下。。。。然后还有好多得做的题目都还没补TAT<br><a id="more"></a><br><strong>1209. 1, 10, 100, 1000…</strong></p>
<p>一个这样的串110100100010000……问第n位是什么。</p>
<p>很明显第n*(n+1)/2位才会是1，其中n为正整数，所以判断一下就行了。</p>
<p><strong>1224. Spiral</strong></p>
<p>给定一个N＊M的矩阵，开始面向左侧，由右上角开始顺时针方向走，每个格子走过一次，为走完整个矩阵需要改变方向多少次。</p>
<p>答案是这个：min(2<em>(n-1), 2</em>(m-1)+1)。至于为什么，仔细想想的话应该就明白了，不过这题虽然简单，我好像还是被坑了好几次。比如说什么 <em>N</em>, <em>M</em> (1 ≤ <em>N</em>, <em>M</em> ≤ 2^31 − 1)，但是乘一下就爆int，得用long long之类的。。。</p>
<p><strong>1225. Flags</strong></p>
<p>用红、白、蓝三种颜色去染一排连续的格子，染色规则是</p>
<ul>
<li>相邻两个格子颜色不能一样</li>
<li>蓝色必须夹在红色和白色的格子中间</li>
</ul>
<p>求给定格子数的染色方案<br>显然，最后一个格子不能染蓝色，就是说，最后一个格子只能是红or白。那个我们就可以得到如下关系</p>
<pre><code>F<span class="string">[N]</span> = F<span class="string">[N-1]</span> + F<span class="string">[N-2]</span>
</code></pre><p>第N－1个，最后是红或者白，那么第N个只能选白或者红。第N－1个是蓝色，即N－2个为红或者白，就是F[N－2]，那么第N个只能是白或者红。然后就是F[1] = F[2] = 2。</p>
<p><strong>1226. esreveR redrO</strong></p>
<p>给定一个文本，把每一段连续的字母翻转，其它字符保持不变。<br>直接做咯，每次看到涉及字符串的题总是会有恐惧感。贴一下代码，安慰一下自己的心灵，有时候字符串的题没有想像中那么多坑。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        c = getchar();</span><br><span class="line">        <span class="keyword">if</span> (c == EOF) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>)) &#123;</span><br><span class="line">            a[++t] = c;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, c);</span><br><span class="line">            t = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>, a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 1227. Rally Championship</strong></p>
<p><a href="http://sillyplus.com/2014/05/389/" target="_blank" rel="external">详情请戳</a></p>
<p><strong>1228. Array</strong></p>
<p>这个读懂题就会做了。。。。</p>
<p><strong>1229. Strong Brickwork</strong></p>
<p><a href="http://sillyplus.com/2014/05/383/" target="_blank" rel="external">详情请戳</a></p>
<p><strong> 1258. Pool</strong></p>
<p>题目可以理解为，给一个矩形，上下左右四条边分别用F、B、L、R表示，给定起始点还有终点的坐标，求一束光由起点到终点的移动距离，给出反射的边的序列。</p>
<p>我们可以把四条边都想像成镜子，然后就是我们学物理时的那点小花招，把求两点间的折线的长度转化成了求两点间的直线距离。我想了好久才理清楚怎么变换坐标。。。。，感觉这还是一道很有趣的题目，一开始以为是变态的计算机何，所以不敢做TAT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> w, d, x1, y1, x2, y2, x, y;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                y1 = -y1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">                y1 = <span class="number">2</span> * d - y1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                x1 = -x1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                x1 = <span class="number">2</span> * w - x1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x1 &lt;&lt; <span class="string">' '</span> &lt;&lt; y1 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ans;</span><br><span class="line">    ans = <span class="built_in">sqrt</span>((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 1259. How to Become Star?</strong></p>
<p>根据给定的定义，求N角星的个数。</p>
<p><strong>Definition.</strong> A <em>star</em> is the closed broken line built by the final amount of steps of the following algorithm:</p>
<ol>
<li>Fix and arbitrary angle α (0 &lt; α &lt; π).</li>
</ol>
<ol>
<li>The first link is (0, 0) — (1, 0).</li>
</ol>
<ol>
<li>The second link is the resultant of the turn by the angle α counter-clockwise with respect to the point (1, 0) of the first one.</li>
</ol>
<ol>
<li>The (<em>i</em> + 2)-nd link is the resultant of the turn by the angle α counter-clockwise of the (<em>i</em> + 1)-st one with respect to the free end (the opposite to the one that is connected to the <em>i</em>-th link) of the (<em>i</em> + 1)-st link.</li>
</ol>
<ol>
<li>The algorithm stops immediately when the broken line is closed.</li>
</ol>
<p><img src="http://acm.timus.ru/image/get.aspx/fd5fa0a0-4cea-47b0-82a0-5ffb61f70b4e" alt="Problem illustration"><img src="http://acm.timus.ru/image/get.aspx/a879b546-2258-4a58-9cf6-d6916cc441ef" alt="Problem illustration"></p>
<p>该怎么证明呢( ´ ▽ ` )ﾉ，自行参见题目的discuss吧或者自行证明，可以用复数。最后答案是Φ(n)/2</p>
<p>好吧，来补个证明，希望没讲错，外加能讲清楚：</p>
<ul>
<li>设 β＝π－α ，则 0 &lt; β &lt; π ;     //N, α为题目描述中的</li>
</ul>
<ul>
<li>有 Nβ mod 2π ＝ 0，则对于该β，N为对应的最小的整数。   //为什么mod 2π等于0，我们可以想像把N角星的各个顶点移动到(1, 0)这点，则每次画一条新边就是上一条边顺时针旋转β，第n条边要刚好跟第一条边重合，且是第一次跟第一条边重合。</li>
</ul>
<ul>
<li>∴β = p * π / N, p为整数, 又为满足上式p要为偶数</li>
</ul>
<ul>
<li>∴β = 2 <em> i </em> π / N ，0 &lt; i &lt; N/2</li>
</ul>
<ul>
<li>上面说到，N为β对应的最小的整数，即不存在整数 k，k &lt; N, 且 kβ mod 2π ＝ 0, 即</li>
</ul>
<ul>
<li>对任意k &lt; N，k <em> 2 </em> i * π / N  mod 2π ≠ 0.</li>
</ul>
<ul>
<li>∴k * i / N 不能为整数，即 i 必须与 N 互质，可得最后的答案为Φ(n)/2</li>
</ul>
<p><strong>1260. Nudnik Photographer</strong></p>
<p>1～n进行排列，第一位为1，相邻两个数字的差不能超过2。求方案数。</p>
<p>F[N]表示N个数的方案数，那么F[N]可由如下方法得到：</p>
<ul>
<li>2放在第二位，则是F[N-1]</li>
</ul>
<ul>
<li>3放在第二位，第三位放2（那么再小一位一定是4），就是F[N-3]</li>
</ul>
<ul>
<li>3放在第二位，第三位不放2，且n &gt;=4,那么就只有一种方案，形如：1、3、5、7、8、6、4、2</li>
</ul>
<p>所以最后可的方程：F[N] = F[N-1] + F[N-3] + 1</p>
<p><strong>1261. Tips</strong></p>
<p>某岛使用的货币的面值是3的幂，3，9，27…..，你要付一笔N元的账单，并且需要给小费，小费需要由不同面值的纸币组成。输出你需要付的最少的钱数sum，以及小费数tips。</p>
<p>显然3进制下，sum以及tips只由1和0组成。然后就是构造出这个最小的tips了，我们可以把N表示成3进制，由最低位开始，如果N在该位为2，tips和N就加上3在该位的幂。好像大概就是这么回事了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">1</span>, x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    x = n;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            y += m;</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        n /= <span class="number">3</span>;</span><br><span class="line">        m *= <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n);</span><br><span class="line">    <span class="keyword">if</span> (!y) y = m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x + y &lt;&lt; <span class="string">' '</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 1262. Pseudo-Roman Number</strong></p>
<p>这题的难度同样在于读题，理解题意后就会发现，对于1～9每个数字都有一个最短的表示方式，然后逐位处理就行了。</p>
<p><strong>1263. Elections</strong></p>
<p>直接做，统计每个数字出现的百分比，不解释</p>
<p><strong>1264. Workdays</strong></p>
<p>这是签到题吧=_=</p>
<p><strong>后记：</strong>终于写完了的说，发现写题解还是很累，很多自己想得明白但还是说不清楚，再也不写这种一点都不过简要的什么一周记录了，以后就挑一些有趣的来写就好了，可是我觉得很多题都很有趣怎么办(°_°)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>虽然很多是水题，不过还是记录一下。。。。然后还有好多得做的题目都还没补TAT<br>]]>
    
    </summary>
    
      <category term="Math" scheme="https://github.com/sillyplus/tags/Math/"/>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1227_Rally Championship]]></title>
    <link href="https://github.com/sillyplus/2014/05/04/timus-1227-rally-championship/"/>
    <id>https://github.com/sillyplus/2014/05/04/timus-1227-rally-championship/</id>
    <published>2014-05-04T02:41:30.000Z</published>
    <updated>2015-10-19T11:43:28.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意：给一个M给节点，N条边的无向图。问是否存在长度 &gt;= S的一条路径。每条边一旦被选择，就只能从固定的一个方向通过。1 ≤ <em>M</em> ≤ 100; 1 ≤ <em>N</em> ≤ 10000; 1 ≤ <em>S</em> ≤ 10^6.</p>
<p>显然，如果存在回路必然可以，且注意可能存在重边。那么我们就可以对每个节点做一遍dfs。在dfs的过程中判断是否存在回到该点的回路，如果不存在就能得到由该点出发的最长路了，注意更新答案就行了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MN][MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> f[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, root;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> ds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ds &gt;= s) &#123;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f[i] &amp;&amp; <span class="built_in">map</span>[rt][i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="built_in">map</span>[rt][i];</span><br><span class="line">            <span class="built_in">map</span>[rt][i] = <span class="built_in">map</span>[i][rt] = <span class="number">0</span>;</span><br><span class="line">            f[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == root) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(i, ds+tmp);</span><br><span class="line">            <span class="built_in">map</span>[rt][i] = <span class="built_in">map</span>[i][rt] = tmp;</span><br><span class="line">            f[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> u, v, dis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;dis);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">map</span>[u][v]) &#123;</span><br><span class="line">            <span class="built_in">map</span>[u][v] = <span class="built_in">map</span>[v][u] = dis;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="literal">false</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        root = i;</span><br><span class="line">        dfs(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意：给一个M给节点，N条边的无向图。问是否存在长度 &gt;= S的一条路径。每条边一旦被选择，就只能从固定的一个方向通过。1 ≤ <em>M</em> ≤ 100; 1 ≤ <em>N</em> ≤ 10000; 1 ≤ <em>S</em> ≤ 10^6.</p>
<p>显然，如果存在回路必然可以，且注意可能存在重边。那么我们就可以对每个节点做一遍dfs。在dfs的过程中判断是否存在回到该点的回路，如果不存在就能得到由该点出发的最长路了，注意更新答案就行了。<br>]]>
    
    </summary>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Timus_1229_Strong Brickwork]]></title>
    <link href="https://github.com/sillyplus/2014/05/04/timus-1229-strong-brickwork/"/>
    <id>https://github.com/sillyplus/2014/05/04/timus-1229-strong-brickwork/</id>
    <published>2014-05-04T01:36:11.000Z</published>
    <updated>2015-10-19T11:43:46.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1229" target="_blank" rel="external">Strong Brickwork</a></p>
<p>题目大意：给一个N＊M(N, M均为偶数，且不超过100)的棋盘，该棋盘有两层，使用1*2的骨牌覆盖，现在给你第一层的覆盖方案，要你求出符合以下要求的任意一个完全覆盖第二层的方案：</p>
<ul>
<li>一块骨牌不能完全放在第一层的某块骨牌上<br>也就是说第二层的每一块骨牌必须同时在第一层的两块不同的骨牌上面<br>看到棋盘还跟骨牌覆盖方案有关，很容易就会想到那个——二分图匹配。构图也很简单，先把格子黑白染色分类，想像一下平时看到的国际象棋棋盘。然后对于每个黑色格子（或白色），如果跟他相邻的格子，如果他们不在同一块骨牌上就连一条边，这样就构图完毕了，跑一边完全匹配，如果刚好有匹配成功(N*M)/2条边就说明有解。<a id="more"></a>
做这道题算是试了一下匈牙利算法的模版，然后写的时候一开始染色分类的时候写错了，纠结了好久=_=。<br><table width="722" style="height: 174px;" class="sample"><br><tbody><br><tr><br>input<br>output<br></tr><tr>

</tr></tbody></table></li>
</ul>
<td><br><br><br>    2 4<br>    1 1 2 2<br>    3 3 4 4<br><br><br><br></td>

<td>


<pre><code><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span>
<span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span>
</code></pre><p></p></td><br><br><br><p></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, tot;</span><br><span class="line"><span class="keyword">int</span> mp1[MN][MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> mp2[MN][MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> from[MN*MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MN*MN];</span><br><span class="line"><span class="keyword">bool</span> use[MN*MN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (!use[g[x][i]]) &#123;</span><br><span class="line">            use[g[x][i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (from[g[x][i]] == -<span class="number">1</span> || match(from[g[x][i]])) &#123;</span><br><span class="line">                from[g[x][i]] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(from, <span class="number">255</span>, <span class="keyword">sizeof</span>(from));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n*m; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span>(use));</span><br><span class="line">        <span class="keyword">if</span> (match(i)) tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp1[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) <span class="keyword">if</span> ((i+j)%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((j+<span class="number">1</span> &lt; m) &amp;&amp; (mp1[i][j] != mp1[i][j+<span class="number">1</span>]))</span><br><span class="line">                g[i*m+j].push_back(i*m+j+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i+<span class="number">1</span> &lt; n) &amp;&amp; (mp1[i][j] != mp1[i+<span class="number">1</span>][j]))</span><br><span class="line">                g[i*m+j].push_back((i+<span class="number">1</span>)*m+j);</span><br><span class="line">            <span class="keyword">if</span> ((j-<span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (mp1[i][j] != mp1[i][j-<span class="number">1</span>]))</span><br><span class="line">                g[i*m+j].push_back(i*m+j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((i-<span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (mp1[i][j] != mp1[i-<span class="number">1</span>][j]))</span><br><span class="line">                g[i*m+j].push_back((i-<span class="number">1</span>)*m+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    ans = hungary();</span><br><span class="line">    <span class="keyword">if</span> (ans == (n*m/<span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(mp2, <span class="number">255</span>, <span class="keyword">sizeof</span>(mp2));</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n*m; i++)</span><br><span class="line">            <span class="keyword">if</span> (from[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                k++;</span><br><span class="line">                mp2[from[i]/m][from[i]%m] = k;</span><br><span class="line">                mp2[i/m][i%m] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, mp2[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>, mp2[i][j]);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; -<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1229">Strong Brickwork</a></p>
<p>题目大意：给一个N＊M(N, M均为偶数，且不超过100)的棋盘，该棋盘有两层，使用1*2的骨牌覆盖，现在给你第一层的覆盖方案，要你求出符合以下要求的任意一个完全覆盖第二层的方案：</p>
<ul>
<li>一块骨牌不能完全放在第一层的某块骨牌上<br>也就是说第二层的每一块骨牌必须同时在第一层的两块不同的骨牌上面<br>看到棋盘还跟骨牌覆盖方案有关，很容易就会想到那个——二分图匹配。构图也很简单，先把格子黑白染色分类，想像一下平时看到的国际象棋棋盘。然后对于每个黑色格子（或白色），如果跟他相邻的格子，如果他们不在同一块骨牌上就连一条边，这样就构图完毕了，跑一边完全匹配，如果刚好有匹配成功(N*M)/2条边就说明有解。]]>
    
    </summary>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="二分图" scheme="https://github.com/sillyplus/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 数论/组合/博弈论 题目列表]]></title>
    <link href="https://github.com/sillyplus/2014/04/29/poj-n-c-g-list/"/>
    <id>https://github.com/sillyplus/2014/04/29/poj-n-c-g-list/</id>
    <published>2014-04-29T08:31:24.000Z</published>
    <updated>2015-10-19T11:43:24.000Z</updated>
    <content type="html"><![CDATA[<p>转自：<a href="http://hi.baidu.com/lydrainbowcat/item/f16e64103f8c5c088fbde44c" target="_blank" rel="external">传送门</a></p>
<a id="more"></a>
<p><strong>博弈论</strong></p>
<p>POJ 2234 Matches Game<br>POJ 2975 Nim<br>POJ 2505 A multiplication game<br>POJ 1067 取石子游戏<br>POJ 2484 A Funny Game<br>POJ 2425 A Chess Game<br>POJ 2960 S-Nim<br>POJ 1704 Georgia and Bob<br>POJ 1740 A New Stone Game<br>POJ 2068 Nim<br>POJ 3480 John<br>POJ 2348 Euclid’s Game<br>POJ 3710 Christmas Game<br>POJ 3533 Light Switching Game<br>POJ 3537 Crosses and Crosses</p>
<p><strong>数论/组合</strong></p>
<p><strong>1.burnside定理，polya计数法</strong><br>这个大家可以看brudildi的《组合数学》，那本书的这一章写的很详细也很容易理解。最好能完全看懂了，理解了再去做题，不要只记个公式。<br><em>简单题：（直接用套公式就可以了）<br>pku2409 Let it Bead<br>pku2154 Color<br>pku1286 Necklace of Beads
</em>强烈推荐：（这题很不错哦，很巧妙）<br>pku2888 Magic Bracelet<br><strong>2.置换，置换的运算</strong></p>
<pre><code>置换的概念还是比较好理解的，《组合数学》里面有讲。对于置换的幂运算大家可以参考一下潘震皓的那篇《置换群快速幂运算研究与探讨》，写的很好。
</code></pre><p><em>简单题：（应该理解概念就可以了）<br>pku3270 Cow Sorting<br>pku1026 Cipher
</em>置换幂运算：<br>pku1721 CARDS<br>pku3128 Leonardo’s Notebook<br><em>推荐：（不错的应用）<br>pku3590 The shuffle Problem<br><em>*3.素数，整数分解，欧拉函数</em></em></p>
<pre><code><span class="xml">素数是可能数论里最永恒，最经典的问题了（我们的队名就叫PrimeMusic</span><span class="keyword">^-</span><span class="xml">^）。素数的判断，筛法求素数，大素数的判断···还有很多其他问题都会用到素数。</span>
</code></pre><p><em>最水最水的：（心情不爽时用来解闷吧）<br>pku1365 Prime Land<br>pku2034 Anti-prime Sequences<br>pku2739 Sum of Consecutive Prime Numbers<br>pku3518 Prime Gap<br>pku3126 Prime Path<br>pku1595 Prime Cuts<br>pku3641 Pseudoprime numbers<br>pku2191 Mersenne Composite Numbers<br>pku1730 Perfect Pth Powers<br>pku2262 Goldbach’s Conjecture<br>pku2909 Goldbach’s Conjecture
</em>筛法：<br>pku2689 Prime Distance（很好的一个应用）<br><em>反素数：<br>zoj2562 More Divisors
</em>素数判断，整数分解：<br>这两题都要用到miller_rabin的素数判断和pollard_rho的整数分解，算法书上都会有，应该是属于模板题吧，不过最好看懂自己敲一遍。<br>pku1811 Prime Test<br>pku2429 GCD &amp; LCM Inverse</p>
<p><em>欧拉函数：<br>数论里很多地方都能用到欧拉函数，很重要的。<br>pku1284 Primitive Roots （关于原根的定理：p的原根为euler(euler(p))，本题中当p为奇素数时euler(p)=p-1，故答案为euler(p-1)）<br>pku2407 Relatives （很水）<br>pku2773 Happy 2006<br>pku2478 Farey Sequence （快速求欧拉函数）<br>pku3090 Visible Lattice Points （法雷级数）
</em>推荐：（欧拉函数，费马小定理）<br>pku3358 Period of an Infinite Binary Expansion<br><em>整数分解<br>这个也很重要的耶，包括大数的表示方法。<br>pku2992 Divisors<br>pku3101 Astronomy （分数的最小公倍数）<br><em>*4.扩展欧几里得，线性同余，中国剩余定理</em></em></p>
<pre><code>这应该是数论里比较重要的一个部分吧，这类的题目也挺多，具体的内容最好先看看数论书，我也整理过一些，可以参考参考：
</code></pre><p><em>简单题：<br>pku1006 Biorhythms<br>pku1061 青蛙的约会<br>pku2891 Strange Way to Express Integers<br>pku2115 C Looooops<br>pku2142 The Balance
</em>强烈推荐：<br>sgu106 The equation<br>pku3708 Recurrent Function （经典）<br><strong> 5.约瑟夫环问题</strong></p>
<pre><code>这个问题还是比较有意思的，不是很难。
</code></pre><p><em>简单题：<br>pku3517 And Then There Was One<br>pku1781 In Danger<br>pku1012 Joseph<br>pku2244 Eeny Meeny Moo
</em>推荐：<br>pku2886 Who Gets the Most Candies?<br><strong>6.高斯消元法解方程</strong></p>
<pre><code>其实解方程并不是很难，就是按线性代数中学的那种方法，把系数矩阵化成上三角矩阵或数量矩阵，不过有些题目要判断是否有解，或枚举所有解。不过这类题目我认为比较难的还是怎么去建立这个方程组，这个理解了，就没什么大问题了。
</code></pre><p><em>简单题：<br>pku1222 EXTENDED LIGHTS OUT<br>pku1681 Painter’s Problem<br>pku1830 开关问题
</em>推荐：<br>pku2947 Widget Factory<br>pku2065 SETI<br><em>强烈推荐：<br>pku1753 Flip Game<br>pku3185 The Water Bowls
</em>变态题：<br>pku1487 Single-Player Games</p>
<p><strong>7.矩阵</strong><br>用矩阵来解决问题确实很常见，但我现在用到还不是很好，很多难题我还不会做。建议大家可以去看Matrix67的那篇关于矩阵的十个问题，确实很经典，但不太好看懂。<br><em>简单：<br>pku3070 Fibonacci<br>pku3233 Matrix Power Series<br>pku3735 Training little cats<br><em>*8.高次同余方程</em></em></p>
<pre><code>有关这个问题我应该是没什么发言权了，A^B%<span class="keyword">C</span>=<span class="keyword">D</span>，我现在只会求<span class="keyword">D</span>和B，唉，很想知道A该怎么求。就先推荐几道题目吧，这里涉及到了一个baby-step，giant-step算法。
</code></pre><p>pku3243 Clever Y<br>pku2417 Discrete Logging<br><strong>9.容斥原理，鸽巢原理</strong></p>
<pre><code>很有用的两个定理，但好像单独考这两个定理的不是很多。
</code></pre><p><em>鸽巢原理：<br>pku2356 Find a multiple<br>pku3370 Halloween treats
</em>容斥原理：<br>hdu1695 GCD<br>hdu2461 Rectangles<br><strong>10.找规律，推公式</strong></p>
<pre><code>这类题目的设计一般都非常巧妙，真的是很难想出来，但只要找到规律或推出公式，就不是很难了。我很多都是在参考别人思路的情况下做的，能自己想出来真的很不容易。
</code></pre><p><em>个人感觉都挺不错的：<br>pku3372 Candy Distribution<br>pku3244 Difference between Triplets<br>pku1809 Regetni<br>pku1831 不定方程组<br>pku1737 Connected Graph<br>pku2480 Longge’s problem<br>pku1792 Hexagonal Routes<br><em>*11.排列组合，区间计数，计数序列</em></em></p>
<pre><code>这些题目可能需要一些组合数学知识，基本上高中的知识就够了。区间计数问题一般不难，但写的时候需要仔细一些，各种情况要考虑到位。至于像卡特兰数，差分序列，斯特灵数···都还挺有意思，可以去看看《组合数学》。
</code></pre><p><em>简单题：<br>pku1850 Code<br>pku1150 The Last Non-zero Digit<br>pku1715 Hexadecimal Numbers<br>pku2282 The Counting Problem<br>pku3286 How many 0’s?
</em>推荐：<br>pku3252 Round Numbers<br><em>计数序列：<br>pku1430 Binary Stirling Numbers<br>pku2515 Birthday Cake<br>pku1707 Sum of powers<br><em>*12.二分法</em></em></p>
<pre><code>二分的思想还是很重要的，这里就简单推荐几个纯粹的二分题。
</code></pre><p><em>简单：<br>pku3273 Monthly Expense<br>pku3258 River Hopscotch<br>pku1905 Expanding Rods<br>pku3122 Pie
</em>推荐：<br>pku1845 Sumdiv<br><strong>13.稳定婚姻问题</strong></p>
<pre><code>无意中接触到这个算法，还蛮有意思的，《组合数学》中有详细的介绍。
</code></pre><p>pku3487 The Stable Marriage Problem<br>zoj1576 Marriage is Stable<br><strong>14.数位类统计问题</strong></p>
<pre><code>在航点月赛中第一次接触到这类问题，scau大牛little龙推荐我看了一篇论文，<span class="number">09</span>年刘聪的《浅谈数位类统计问题》，这篇论文相当精彩，也相当详 细，每道题都有详细的分析和作者的参考代码。所以我也没什么可说的了，这些题的代码我博客里也就不贴了，大家直接去看论文吧。
</code></pre><p>简单：<br>ural1057 Amount of degrees<br>spoj1182 Sorted bit squence<br>hdu3271 SNIBB<br>较难：<br>spoj2319 Sequence<br>sgu390 Tickets</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自：<a href="http://hi.baidu.com/lydrainbowcat/item/f16e64103f8c5c088fbde44c">传送门</a></p>]]>
    
    </summary>
    
      <category term="Poj" scheme="https://github.com/sillyplus/tags/Poj/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 计算几何入门题目列表]]></title>
    <link href="https://github.com/sillyplus/2014/04/19/poj-geometry-list/"/>
    <id>https://github.com/sillyplus/2014/04/19/poj-geometry-list/</id>
    <published>2014-04-19T07:30:20.000Z</published>
    <updated>2015-10-19T11:43:19.000Z</updated>
    <content type="html"><![CDATA[<p>转载自：<a href="http://hi.baidu.com/novosbirsk/item/16330d2b7be6910e42634a13" target="_blank" rel="external">PKKJ @ SCAU - A GISer</a></p>
<p>计算几何题的特点与做题要领：</p>
<p>1.大部分不会很难，少部分题目思路很巧妙<br>2.做计算几何题目，模板很重要，模板必须高度可靠。<br>3.要注意代码的组织，因为计算几何的题目很容易上两百行代码，里面大部分是模板。如果代码一片混乱，那么会严重影响做题正确率。<br>4.注意精度控制。<br>5.能用整数的地方尽量用整数，要想到扩大数据的方法（扩大一倍，或扩大sqrt2）。因为整数不用考虑浮点误差，而且运算比浮点快。<br><a id="more"></a><br>一。点，线，面，形基本关系，点积叉积的理解  </p>
<p>POJ 2318 TOYS（推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2318" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2318</a><br>POJ 2398 Toy Storage（推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2398" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2398</a><br>一个矩形，有被若干直线分成N个格子，给出一个点的坐标，问你该点位于哪个点中。<br>知识点：其实就是点在凸四边形内的判断，若利用叉积的性质，可以二分求解。  </p>
<p>POJ 3304 Segments<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3304" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3304</a><br>知识点：线段与直线相交，注意枚举时重合点的处理  </p>
<p>POJ 1269 Intersecting Lines<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1269" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1269</a><br>知识点：直线相交判断，求相交交点  </p>
<p>POJ 1556 The Doors （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1556" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1556</a><br>知识点：简单图论＋简单计算几何，先求线段相交，然后再用Dij求最短路。  </p>
<p>POJ 2653 Pick-up sticks<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2653" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2653</a><br>知识点：还是线段相交判断  </p>
<p>POJ 1066 Treasure Hunt<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1066" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1066</a><br>知识点：线段相交判断，不过必须先理解“走最少的门”是怎么一回事。  </p>
<p>POJ 1410 Intersection<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1410" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1410</a><br>知识点：线段与矩形相交。正确理解题意中相交的定义。<br>详见：<a href="http://hi.baidu.com/novosbirsk/blog/item/68c682c67e8d1f1d9d163df0.html" target="_blank" rel="external">http://hi.baidu.com/novosbirsk/blog/item/68c682c67e8d1f1d9d163df0.html
</a><br>POJ 1696 Space Ant （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1696" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1696</a><br>德黑兰赛区的好题目。需要理解点积叉积的性质  </p>
<p>POJ 3347 Kadj Squares<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3347" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3347</a><br>本人的方法极度猥琐。复杂的线段相交问题。这个题目是计算几何的扩大数据运算的典型应用，扩大根号2倍之后就避免了小数。  </p>
<p>POJ 2826 An Easy Problem?! （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2826" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2826</a><br>问：两条直线组成一个图形，能容纳多少雨水。很不简单的Easy Problem，要考虑所有情况。你不看discuss看看能否AC。（本人基本不能）提示一下，水是从天空垂直落下的。  </p>
<p>POJ 1039 Pipe<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1039" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1039</a><br>又是线段与直线相交的判断，再加上枚举的思想即可。  </p>
<p>POJ 3449 Geometric Shapes<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3449" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3449</a><br>判断几何体是否相交，不过输入输出很恶心。<br>此外，还有一个知识点，就是给出一个正方形（边不与轴平行）的两个对角线上的顶点，需要你求出另外两个点。必须掌握其方法。  </p>
<p>POJ 1584 A Round Peg in a Ground Hole<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1584" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1584</a><br>知识点：点到直线距离，圆与多边形相交，多边形是否为凸  </p>
<p>POJ 2074 Line of Sight （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2074" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2074</a><br>与视线问题的解法，关键是求过两点的直线方程，以及直线与线段的交点。数据有一个trick，要小心。  </p>
<p>二。凸包问题  </p>
<p>POJ 1113 Wall<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1113" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1113</a><br>知识点：赤裸裸的凸包问题，凸包周长加上圆周。  </p>
<p>POJ 2007 Scrambled Polygon<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2007" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2007</a><br>知识点：凸包，按极角序输出方案  </p>
<p>POJ 1873 The Fortified Forest （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1873" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1873</a><br>World Final的水题，先求凸包，然后再搜索。由于规模不大，可以使用位运算枚举。<br>详见：<a href="http://hi.baidu.com/novosbirsk/blog/item/333abd54c7f22c52574e0067.html" target="_blank" rel="external">http://hi.baidu.com/novosbirsk/blog/item/333abd54c7f22c52574e0067.html</a>  </p>
<p>POJ 1228 Grandpa’s Estate （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1228" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1228</a><br>求凸包顶点数目，很多人求凸包的模板是会多出点的，虽然求面积时能得到正确答案，但是在这个题目就会出问题。此外，还要正确理解凸包的性质。  </p>
<p>POJ 3348 Cows<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3348" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3348</a><br>凸包面积计算  </p>
<p>三。面积问题，公式问题  </p>
<p>POJ 1654 Area<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1654" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1654</a><br>知识点：利用有向面积（叉积）计算多边形面积  </p>
<p>POJ 1265 Area<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1265" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1265</a><br>POJ 2954 Triangle<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2954" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2954</a><br>Pick公式的应用，多边形与整点的关系。（存在一个GCD的关系）  </p>
<p>四。半平面交  </p>
<p>半平面交的主要应用是判断多边形是否存在核，还可以解决一些与线性方程组可行区域相关的问题（就是高中时的那些）。  </p>
<p>POJ 3335 Rotating Scoreboard<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3335" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3335</a><br>POJ 3130 How I Mathematician Wonder What You Are!<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3130" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3130</a><br>POJ 1474 Video Surveillance<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1474" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1474</a><br>知识点：半平面交求多边形的核，存在性判断  </p>
<p>POJ 1279 Art Gallery<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1279" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1279</a><br>半平面交求多边形的核，求核的面积  </p>
<p>POJ 3525 Most Distant Point from the Sea （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3525" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3525</a><br>给出一个多边形，求里面的一个点，其距离离多边形的边界最远，也就是多边形中最大半径圆。<br>可以使用半平面交+二分法解。二分这个距离，边向内逼近，直到达到精度。  </p>
<p>POJ 3384 Feng Shui （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3384" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3384</a><br>半平面交实际应用，用两个圆覆盖一个多边形，问最多能覆盖多边形的面积。<br>解法：用半平面交将多边形的每条边一起向“内”推进R，得到新的多边形，然后求多边形的最远两点。  </p>
<p>POJ 1755 Triathlon （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1755" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1755</a><br>半平面交判断不等式是否有解。注意不等式在转化时正负号的选择，这直接影响到半平面交的方向。  </p>
<p>POJ 2540 Hotter Colder<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2540" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2540</a><br>半平面交求线性规划可行区域的面积。  </p>
<p>POJ 2451 Uyuw’s Concert<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2451" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2451</a><br>Zzy专为他那篇nlogn算法解决半平面交问题的论文而出的题目。  </p>
<p>五。计算几何背景，实际上解题的关键是其他问题（数据结构、组合数学，或者是枚举思想）<br>若干道经典的离散化＋扫描线的题目，ACM选手必做题目  </p>
<p>POJ 1151 Atlantis （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1151" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1151</a><br>POJ 1389 Area of Simple Polygons<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1389" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1389</a><br>矩形离散化，线段树处理，矩形面积求交  </p>
<p>POJ 1177 Picture （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1177" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1177</a><br>矩形离散化，线段树处理，矩形交的周长，这个题目的数据比较强。线段树必须高效。   </p>
<p>POJ 3565 Ants （推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3565" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3565</a><br>计算几何中的调整思想，有点像排序。要用到线段相交的判断。<br>详见：<a href="http://hi.baidu.com/novosbirsk/blog/item/fb668cf0f362bec47931aae2.html" target="_blank" rel="external">http://hi.baidu.com/novosbirsk/blog/item/fb668cf0f362bec47931aae2.html</a>  </p>
<p>POJ 3695 Rectangles<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3695" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3695</a><br>又是矩形交的面积，但是由于是多次查询，而且矩形不多，使用组合数学中的容斥原理解决之最适合。线段树是通法，但是除了线段树，还有其他可行的方法。  </p>
<p>POJ 2002 Squares<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2002" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2002</a><br>枚举思想，求平面上若干个点最多能组成多少个正方形，点的Hash  </p>
<p>POJ 1434 Fill the Cisterns!（推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1434" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1434</a><br>一开始发昏了，准备弄个线段树。其实只是个简单的二分。  </p>
<p>六。随机算法<br>POJ 2420 A Star not a Tree?<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2420" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2420</a><br>多边形的费马点。所谓费马点，就是多边形中一个点P，该点到其他点的距离之和最短。四边形以上的多边形没有公式求费马点，因此可以使用随机化变步长贪心法。<br>详见：<a href="http://hi.baidu.com/novosbirsk/blog/item/75983f138499f825dd54019b.html" target="_blank" rel="external">http://hi.baidu.com/novosbirsk/blog/item/75983f138499f825dd54019b.html</a>  </p>
<p>七。解析几何<br>这种题目本人不擅长，所以做得不多，模板很重要。当然，熟练运用叉积、点积的性质还是很有用的。<br>POJ 1375 Intervals<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1375" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1375</a><br>知识点：过圆外一点求与圆的切线  </p>
<p>POJ 1329 Circle Through Three Points<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1329" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1329</a><br>求三角形外接圆  </p>
<p>POJ 2354 Titanic<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2354" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2354</a><br>求球面上两个点的距离，而且给的是地理经纬坐标。  </p>
<p>POJ 1106 Transmitters<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1106" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1106</a><br>角度排序，知道斜率求角度，使用atan函数。  </p>
<p>POJ 1673 EXOCENTER OF A TRIANGLE<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1673" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1673</a><br>可以转化为三角形的垂心问题。  </p>
<p>八。旋转卡壳  </p>
<p>POJ 2187 Beauty Contest<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2187" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2187</a><br>凸包求最远点对。可以暴力枚举，也可以使用旋转卡壳。  </p>
<p>POJ 3608 Bridge Across Islands（难）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3608" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3608</a><br>两个凸包的最近距离。本人的卡壳始终WA。郁闷。  </p>
<p>九。其他问题<br>POJ 1981 Circle and Points<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1981" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1981</a><br>求单位圆最多能覆盖平面上多少个点</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转载自：<a href="http://hi.baidu.com/novosbirsk/item/16330d2b7be6910e42634a13">PKKJ @ SCAU - A GISer</a></p>
<p>计算几何题的特点与做题要领：</p>
<p>1.大部分不会很难，少部分题目思路很巧妙<br>2.做计算几何题目，模板很重要，模板必须高度可靠。<br>3.要注意代码的组织，因为计算几何的题目很容易上两百行代码，里面大部分是模板。如果代码一片混乱，那么会严重影响做题正确率。<br>4.注意精度控制。<br>5.能用整数的地方尽量用整数，要想到扩大数据的方法（扩大一倍，或扩大sqrt2）。因为整数不用考虑浮点误差，而且运算比浮点快。<br>]]>
    
    </summary>
    
      <category term="Poj" scheme="https://github.com/sillyplus/tags/Poj/"/>
    
      <category term="计算几何" scheme="https://github.com/sillyplus/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 搜索题目列表]]></title>
    <link href="https://github.com/sillyplus/2014/04/17/poj-search-list/"/>
    <id>https://github.com/sillyplus/2014/04/17/poj-search-list/</id>
    <published>2014-04-16T23:24:47.000Z</published>
    <updated>2015-10-19T11:28:11.000Z</updated>
    <content type="html"><![CDATA[<p><strong>声明：</strong></p>
<p>1.这不是我原创的，是从网上找到的，跟大家分享一下。(然后我在从lyd那里转来的)<br><a id="more"></a><br>POJ 1069 -The Bermuda Triangle(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1069" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1069</a><br>题意：用给定三角型填充六边形<br>解法：此题的思想上精华在于坐标化<br>ps:传说中比较bt，确实比较bt，主要很容易写错，我ac了，但程序没完全对….</p>
<p>POJ 1077 - Eight(中等，此题不做人生不完整)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1077" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1077</a><br>题意：八数码问题，超经典题<br>解法：广搜，A*，双向广搜<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/d19758588b89fa95800a1804.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/d19758588b89fa95800a1804.html</a></p>
<p>POJ 1084 - Square Destroyer(中等，经典题)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1084" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1084</a><br>题意：把每个正方型看做集合中的元素，每个木棒看做是一个子集，求最小的子集覆盖<br>解法：dfs，A*，广搜肯定爆空间<a href="http://hi.baidu.com/lydrainbowcat/blog/item/5759d80f6735133e6059f393.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/5759d80f6735133e6059f393.html</a></p>
<p>POJ 1167 - The Buses(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1167" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1167</a><br>题意：这道题综合了很多经典的深搜技巧，狂顶<br>解法：dfs<a href="http://hi.baidu.com/lydrainbowcat/blog/item/4231cba7965a0681d14358f7.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/4231cba7965a0681d14358f7.html</a></p>
<p>POJ 1190 - 生日蛋糕(基础，好题)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1190" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1190</a><br>题意：略<br>解法：dfs，题偏简单，但做出来还是有些感觉的<a href="http://hi.baidu.com/lydrainbowcat/blog/item/41c21823e0748950ad34deb7.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/41c21823e0748950ad34deb7.html</a></p>
<p>POJ 1324 - Holedox Moving(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1324" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1324</a><br>题意：略<br>解法：A*，dfs + 上界剪枝，广搜<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/7fcaba2c3d5425e98a1399cf.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/7fcaba2c3d5425e98a1399cf.html</a><br><a href="http://hi.baidu.com/zfy0701/blog/item/a3c44ecc049b1c1501e92806.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/a3c44ecc049b1c1501e92806.html</a></p>
<p>POJ 1376 - Robot(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1376" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1376</a><br>题意：略<br>解法：bfs，A*….</p>
<p>POJ 1475 - Pushing Boxes(中等，很推荐)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1475" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1475</a><br>题意：推箱子游戏<br>解法：双重bfs(对箱子bfs 时 对人bfs)，A* <a href="http://hi.baidu.com/lydrainbowcat/blog/item/19f2bfd1d09f0e2c9b5027b8.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/19f2bfd1d09f0e2c9b5027b8.html</a></p>
<p>POJ 1945 - Power Hungry Cows(??)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1945" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1945</a><br>题意：略<br>解法：在一份解题报告中被列为难题，不过好好像写了个很简单很暴力的bfs就过了…速度还是有些慢，暂时想不到好的启发函数</p>
<p>POJ 2044 - Weather Forecast(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2044" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2044</a><br>题意：略<br>解法：广搜，dp，深搜<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/a8c86e11f1d52bd2a7ef3f00.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/a8c86e11f1d52bd2a7ef3f00.html</a><br>POJ 2286 - The Rotation Game(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2286" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2286</a><br>题意：略<br>解法：IDA*（迭代加深+上下界强剪<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/36e183d1e3782ac7572c84a8.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/36e183d1e3782ac7572c84a8.html</a><br>POJ 2308 - Dearboy’s Puzzle(中等，但做的人少?)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2308" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2308</a><br>题意：判断连连看是否有解<br>解法：DFS + BFS<br>相关：<a href="http://poj.org/showmessage?message_id=161113" target="_blank" rel="external">http://poj.org/showmessage?message_id=161113</a></p>
<p>POJ 2426 Remainder(较难，=)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2426" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2426</a><br>题意：略，主要是数论部分比较容易让人抓狂<br>解法：bfs<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/7fcaba2c3d5425e98a1399cf.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/7fcaba2c3d5425e98a1399cf.html</a></p>
<p>POJ 2449 Remmarguts’ Date(中等，强烈推荐)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2449" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2449</a><br>题意：经典问题：K短路<br>解法：dijkstra+A*，方法很多<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/df505f8841d1e980a5c2727c.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/df505f8841d1e980a5c2727c.html</a></p>
<p>POJ1072 PuzzleOut（较难，强烈推荐）<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1072" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1072</a><br>题意：有关解密的       解法：Trie+DFS+剪枝<br>相关：本空间有题解<a href="http://hi.baidu.com/lydrainbowcat/blog/item/f12b38355913fb9fa71e1277.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/f12b38355913fb9fa71e1277.html</a></p>
<p>POJ2222 DeeperBlue（中等）<br>题意：一个国际象棋盘上放着几个子，问最少去掉几个可以不互相攻击。主要考察细心，题目跟题号的性质相符（比较2）；<br>解法：dfs、暴力枚举<a href="http://hi.baidu.com/lydrainbowcat/blog/item/2194090a8975ec2ab1351db3.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/2194090a8975ec2ab1351db3.html</a></p>
<p>POJ 2688 - Cleaning Robot(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2688" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2688</a><br>题意：bfs后转换为tsp问题<br>解法：状态压缩BFS。转化为TSP的话极易超时。<br>相关：本空间有题解<a href="http://hi.baidu.com/lydrainbowcat/blog/item/025fa9a48850a8e39052eefa.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/025fa9a48850a8e39052eefa.html</a></p>
<p>POJ 2908 - Quantum(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2908" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2908</a><br>题意：其实就是找单源最短路径<br>解法：优先队列广搜(即dijkstra)，建议用位运算优化</p>
<p>POJ 3074 - Sudoku(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3074" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3074</a><br>题意：数独游戏，数据比2676强很多，但比3076弱<br>解法：用dfs回溯基本可过，不过每次应选择可能填的数字最少的格子搜<br>更快的方法是先转换成exact cover问题，然后用经典dancing links解决，<br>本空间有关于DancingLinks和本题的介绍和题解。<a href="http://hi.baidu.com/lydrainbowcat/blog/item/2194090a2276192ab1351dbc.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/2194090a2276192ab1351dbc.html</a><br>POJ 3322 - Bloxorz I(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3322" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3322</a><br>题意：略，这个游戏本身很好玩（<a href="http://jandan.net/2008/01/24/bloxorz.html）" target="_blank" rel="external">http://jandan.net/2008/01/24/bloxorz.html）</a><br>解法：广搜，双向广搜。朴素的BFS就可以，非常简单，这是我除了A+B以外在poj第一道一次就AC的题目。<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/d7b6490f847948e8ab6457c6.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/d7b6490f847948e8ab6457c6.html</a></p>
<p>POJ 3460 - Booksort(较难，很推荐)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3460" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3460</a><br>题意：略<br>解法：IDA<em>，A</em>，双向BFS<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/26767f24c8aed5278744f99d.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/26767f24c8aed5278744f99d.html</a></p>
<p>POJ 3523 - The Morning after Halloween(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3523" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3523</a><br>题意：把所有机器人移到各自的位置，不能相撞或重合<br>解法：我的状态设计太暴力了：以所有机器人位置表示状态。然后用A*过，排倒数第几，郁闷。谁知道好的状态设计方法告诉我^_^</p>
<p>POJ 3633 - Copying DNA(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3633" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3633</a><br>题意：一个填充字符串的搜索题<br>解法：各种搜法皆宜<br>相关：算法的实现较挑战，我是参考了 <a href="http://www.wiskey86.cn/wordpress/?p=54" target="_blank" rel="external">http://www.wiskey86.cn/wordpress/?p=54</a> 才搞定的</p>
<p>POJ 3635 full tank?(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3635" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3635</a><br>题意：最短路变形<br>解法：广搜<br>相关：<a href="http://hi.baidu.com/lydrainbowcat/blog/item/0fb2503317caee57ad4b5fed.html" target="_blank" rel="external">http://hi.baidu.com/lydrainbowcat/blog/item/0fb2503317caee57ad4b5fed.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>声明：</strong></p>
<p>1.这不是我原创的，是从网上找到的，跟大家分享一下。(然后我在从lyd那里转来的)<br>]]>
    
    </summary>
    
      <category term="资源" scheme="https://github.com/sillyplus/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[New Blog || New Start]]></title>
    <link href="https://github.com/sillyplus/2014/04/17/new-blog-new-start/"/>
    <id>https://github.com/sillyplus/2014/04/17/new-blog-new-start/</id>
    <published>2014-04-16T23:24:18.000Z</published>
    <updated>2015-10-19T11:02:17.000Z</updated>
    <content type="html"><![CDATA[<p>又是一个新的开始，让我们再一次大声喊一声</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print<span class="list">(<span class="keyword">Hello</span> World)</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">writeln<span class="list">(<span class="string">"Helo World"</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>今天突然心血来潮买了个虚拟主机，加上前几天已经手贱买了个域名，所以就。。。。不小心弄了一整天</p>
<p>这个博客里还没什么内容，不过以后会有的，是的，会有的。原来那个blog还在，过几天有空再把它清掉好了。</p>
<p>然后呢，以后还有很多事情要做，关于这个blog我还有好多想法没有实现。(￣▽￣)有谁愿意来帮我弄吗，我知道没有。。。所以，(未完待续……)</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又是一个新的开始，让我们再一次大声喊一声</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="li]]>
    </summary>
    
      <category term="杂记" scheme="https://github.com/sillyplus/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[［转］成为 Linux 终端高手的七种武器]]></title>
    <link href="https://github.com/sillyplus/2014/04/17/linux-weapon/"/>
    <id>https://github.com/sillyplus/2014/04/17/linux-weapon/</id>
    <published>2014-04-16T23:23:31.000Z</published>
    <updated>2015-10-19T11:52:00.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<p>Linux 终端不仅是一个键入命令的地方。如若你能熟谙这些基础技巧，那么你会在绝大多数 Linux 发行版的默认使用的 Bash shell中游刃有余。</p>
<p>这是howtogeek.com 网站特供给初级用户升级打怪时不能忘记携带的七种武器——<br><a id="more"></a></p>
<h3 id="1-Tab_补全">1.Tab 补全</h3><p>这样能节省时间，并且对于输入那些你不很确定其具体名称的文件和命令来说很方便。比如，当前目录下有一个名为“really long file name”的文件，你想要删除它。你可以输入完整的文件名，但是你必须确保正确地输入了空格和每个字母。若当前目录下还有许多以字母“r”开头的文件，(如果你没有正确地输入字符) Bash 将不知道你想要删除哪一个文件。</p>
<p>如果在当前目录下存在着另一个名为“really very long file name”的文件，你敲击了Tab键。Bash 将为所有以“r”开头的文件自动补充“really ”部分。此时继续敲击Tab键，你将得到匹配所有文件名的列表。</p>
<h3 id="2-管道机制">2.管道机制</h3><p>这种机制允许你把一条命令的输出传送到另一条命令。按照 UNIX 哲学，每个程序都足够小，只做一件事并将之做到最好。例如，ls命令列出当前目录下的所有文件，grep命令搜索输入其中的指定检索项。</p>
<p>你可以通过管道机制（|字符）把二者结合起来，在当前目录下搜索文件。以下给出的命令（在当前文件夹下）搜索关键字为“word”的文件：</p>
<pre><code><span class="keyword">ls</span> | grep <span class="literal">word</span>
</code></pre><h3 id="3-通配符">3.通配符</h3><p>“*”（星号）字符是一种匹配任意长度字符的通配符。比如，你想删除当前文件夹下名为“really long file name”和“really very long file name”的两个文件，你可以运行以下命令：</p>
<pre><code>rm really*<span class="property">name</span>
</code></pre><p>这条命令会删除所有以“really”开头以“name”结尾的文件。但是，如果你运行的是 rm * 这条命令，你将会删除文件夹下的所有文件。（译注：使用通配符时要小心，尤其是你的rm没有-f确认时！）</p>
<h3 id="4-输出重定向">4.输出重定向</h3><p>“&gt;”字符可以把一条命令的输出重定向到一个文件或另一条命令。比如，下面这行命令执行完 ls 后会列出当前文件夹下的所有文件，其结果不是在终端显示，而是输出到当前文件夹下一个名为“file1”的文件中去:</p>
<pre><code><span class="keyword">ls</span> &gt; file1
</code></pre><h3 id="5-历史记录">5.历史记录</h3><p>Bash 能记住你以前输入过的命令，上、下方向键可以逐行调出它们。使用 history 命令打印历史记录，以管道机制 grep 选择性地输出你想要的结果。</p>
<pre><code>~
.
..
</code></pre><p>“~”，也叫做波浪符，用来表示当前用户的主目录。相比通过 cd /home/name 到达你的主目录，你可以输入 cd ~ 来达到相同效果。这点也可以在相关路径上使用：比如 cd ~/Desktop 能够到达当前用户的 Desktop 目录。</p>
<p>同样，“.”代表当前目录，“..”代表当前目录的父目录。使用 cd .. 可以返回上一级目录。它们也可以用在相关路径上，举例说明：你当前处在 Desktop 文件夹下，通过 cd ../Documents 命令，你可以转到与 Desktop 共有同一父文件夹的 Documents 文件夹去。</p>
<p>（译注：“-”代表前一个目录，cd - 可以返回到前一个工作目录。）</p>
<h3 id="6-后台命令">6.后台命令</h3><p>Bash 默认情况下会在当前终端下执行你键入的每条命令。通常这样是没有问题的，但是如果你想要在启动某个应用后继续使用终端呢？通过输入 firefox 启动火狐浏览器，你的终端将被错误提示等各种信息输出占据，直到你关闭火狐浏览器为止。在 Bash 中你可以通过在命令结尾添加“&amp;”操作符来后台执行程序。</p>
<pre><code><span class="title">firefox</span> &amp;
</code></pre><h3 id="7-条件执行">7.条件执行</h3><p>Bash 也可以连续执行两条命令。 第二条命令仅在第一条命令成功执行后才会开始执行。如要如此，你可以通过键入“&amp;&amp;”，也就是两个“&amp;”字符进行分隔，在同一行输入两条命令。下面给出的命令会在等待 5 秒后运行 gnome-screenshot 工具:</p>
<pre><code><span class="built_in">sleep</span> <span class="number">5</span> &amp;&amp; gnome-screenshot
</code></pre><p>via: <a href="http://www.efytimes.com/e1/fullnews.asp?edid=123564" target="_blank" rel="external">http://www.efytimes.com/e1/fullnews.asp?edid=123564</a></p>
<p>译者：<a href="https://github.com/SteveArcher">SteveArcher</a> 校对：<a href="https://github.com/wxy">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创翻译，<a href="http://linux.cn/" target="_blank" rel="external">Linux中国</a> 荣誉推出<br>原文及评论：<a href="http://linux.cn/article-2413-1-qqmail.html" target="_blank" rel="external">http://linux.cn/article-2413-1-qqmail.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<p>Linux 终端不仅是一个键入命令的地方。如若你能熟谙这些基础技巧，那么你会在绝大多数 Linux 发行版的默认使用的 Bash shell中游刃有余。</p>
<p>这是howtogeek.com 网站特供给初级用户升级打怪时不能忘记携带的七种武器——<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="https://github.com/sillyplus/tags/Linux/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 3420 Quad Tiling 状压DP＋矩阵]]></title>
    <link href="https://github.com/sillyplus/2014/04/17/poj-3420-quad-tiling/"/>
    <id>https://github.com/sillyplus/2014/04/17/poj-3420-quad-tiling/</id>
    <published>2014-04-16T23:22:39.000Z</published>
    <updated>2015-10-19T11:28:04.000Z</updated>
    <content type="html"><![CDATA[<p>可以理解为2663的加强版，多了些状态，代码基本参考了别人的，各种位运算。。。。因为N比较大，所以，矩阵乘法的优势就体现出来了，不过这个代码感觉速度还不是很快啊<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.cpp</span></span><br><span class="line"><span class="comment">//  p3420</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by Silly on 13-12-26.</span></span><br><span class="line"><span class="comment">//  Copyright (c) 2013年 Silly. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> mt &#123;</span><br><span class="line">    ll ma[<span class="number">16</span>][<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mt res, tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"><span class="keyword">int</span> bit[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res.ma, <span class="number">0</span>, <span class="keyword">sizeof</span>(res.ma));</span><br><span class="line">    <span class="built_in">memset</span>(tmp.ma, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.ma));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        res.ma[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        bit[i] = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_mat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        tmp.ma[i][(~i)&amp;<span class="number">0xF</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ((~i)&amp;bit[j]&amp;<span class="number">0xF</span>) == <span class="number">0</span> &amp;&amp; ((~i)&amp;bit[j+<span class="number">1</span>]&amp;<span class="number">0xF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                tmp.ma[i][((~i)|bit[j]|bit[j+<span class="number">1</span>]) &amp; <span class="number">0xF</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.ma[<span class="number">15</span>][<span class="number">15</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">mt <span class="title">mm</span><span class="params">(mt a, mt b)</span> </span>&#123;</span><br><span class="line">    mt c;</span><br><span class="line">    <span class="built_in">memset</span>(c.ma, <span class="number">0</span>, <span class="keyword">sizeof</span>(c.ma));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">16</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.ma[i][k]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">                    c.ma[i][j] += a.ma[i][k] * b.ma[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">            c.ma[i][j] %= M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mat_pw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            res = mm(res, tmp);</span><br><span class="line">        tmp = mm(tmp, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M) &amp;&amp; N|M) &#123;</span><br><span class="line">        init();</span><br><span class="line">        set_mat();</span><br><span class="line">        mat_pw();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lldn"</span>, res.ma[<span class="number">15</span>][<span class="number">15</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>可以理解为2663的加强版，多了些状态，代码基本参考了别人的，各种位运算。。。。因为N比较大，所以，矩阵乘法的优势就体现出来了，不过这个代码感觉速度还不是很快啊<br>]]>
    
    </summary>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="bitmarks" scheme="https://github.com/sillyplus/tags/bitmarks/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NEERC 2000 Central Subregional 简要题解]]></title>
    <link href="https://github.com/sillyplus/2014/04/17/neerc-2000-central-subregional/"/>
    <id>https://github.com/sillyplus/2014/04/17/neerc-2000-central-subregional/</id>
    <published>2014-04-16T17:07:13.000Z</published>
    <updated>2015-10-19T11:52:43.000Z</updated>
    <content type="html"><![CDATA[<p>题目链接：<a href="http://acm.timus.ru/problemset.aspx?space=1&amp;page=1" target="_blank" rel="external">戳我</a>（1053－1059）</p>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1053" target="_blank" rel="external">Pinocchio</a></p>
<p>题目还比较好理解，每次选两个数，大数减去小数，相等则合并，其实就是求出所有数的最大公约数，然后就是直接做了。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, ans, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        ans = gcd(ans, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1054" target="_blank" rel="external">Hanoi Tower</a></p>
<p>汉诺塔是很经典的一个东西了，但这道题还是比较有意思的。给出当前各个圆盘所在的柱子的一个序列，问你当前状态是最优移动方案里面的第几步，有可能所给状态不是最优方案里的状态，N&lt;=31。如果对汉诺塔得递归性质理解得比较深的话应该很容易就能做出来，我是先打了一个表看看规律的。。。我们可以只考虑最大的圆盘k，如果还没有被移动过就无视，不然ans就加上2ˆ(k-1)，然后逆着递归回去，然后明显就是O(N)了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;, n, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (f[k] == c) &#123;</span><br><span class="line">        ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[k] == b) &#123;</span><br><span class="line">        ans += <span class="number">1</span> &lt;&lt; (k-<span class="number">1</span>);</span><br><span class="line">        sol(k-<span class="number">1</span>, c, b, a);</span><br><span class="line">    &#125; <span class="keyword">else</span> sol(k-<span class="number">1</span>, a, c, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; f[i];</span><br><span class="line">    sol(n, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1055" target="_blank" rel="external">Combinations</a></p>
<p>很裸的数学题了，组合数的计算，对分式上下各个数进行质因数分解，最后统计一下，不过我好像写得比较矬，应该写得更简洁些才是啊。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[MN];</span><br><span class="line"><span class="keyword">int</span> ans[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(valid, <span class="literal">true</span>, <span class="keyword">sizeof</span>(valid));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid[i]) ans[++tot] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ((j &lt;= tot) &amp;&amp; (i*ans[j] &lt;= n)); j++) &#123;</span><br><span class="line">            valid[i*ans[j]] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % ans[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; (n/<span class="number">2</span>)) m = n-m;</span><br><span class="line">    getPrime(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = n-i;</span><br><span class="line">        <span class="keyword">if</span> (valid[t]) &#123;</span><br><span class="line">            f[t]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">while</span> (t % ans[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[ans[j]]++;</span><br><span class="line">                    t /= ans[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (valid[i]) &#123;</span><br><span class="line">            f[i]--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>, t = i;</span><br><span class="line">            <span class="keyword">while</span> (t != <span class="number">1</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">while</span> (t % ans[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[ans[j]]--;</span><br><span class="line">                    t /= ans[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (f[i]) ans++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1056" target="_blank" rel="external">Computer Net</a></p>
<p>N(&lt;=10000)点构成一颗树，要求出树的中心。由树的性质可以知道，中心必定是1 or 2个。求树的中心还有树的直径都是很经典的问题，这道题也有很多做法。我用的是两边DFS，任意选则一个点v做一遍DFS，则离v最远的那个点必定是树的直径的一个端点，然后再由得到的端点做一遍DFS，就找到了另一个端点了，记录路径，然后再找到直径的中点就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a[MN];</span><br><span class="line"><span class="keyword">bool</span> vt[MN];</span><br><span class="line"><span class="keyword">int</span> f[MN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, l, v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> pr, <span class="keyword">int</span> de)</span> </span>&#123;</span><br><span class="line">    vt[x] = <span class="literal">true</span>;</span><br><span class="line">    f[x] = pr;</span><br><span class="line">    <span class="keyword">if</span> (de &gt; l) &#123;</span><br><span class="line">        l = de;</span><br><span class="line">        v = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a[x].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ch = a[x][i];</span><br><span class="line">        <span class="keyword">if</span> (vt[ch]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(ch, x, de+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        a[k].push_back(i);</span><br><span class="line">        a[i].push_back(k);</span><br><span class="line">    &#125;</span><br><span class="line">    v = l = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vt, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vt));</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vt, <span class="literal">false</span>, <span class="keyword">sizeof</span>(vt));</span><br><span class="line">    l = <span class="number">0</span>;</span><br><span class="line">    dfs(v, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l/<span class="number">2</span>; i++)</span><br><span class="line">        v = f[v];</span><br><span class="line">    <span class="keyword">if</span> (l % <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f[v] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(v, f[v]) &lt;&lt; <span class="string">" "</span> &lt;&lt; max(v, f[v]) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1057" target="_blank" rel="external">Amount of Degrees</a></p>
<p>数位统计</p>
<p>题目大意：给出区间［X,Y］,要求算出区间内可以表示为k个不相同的b的幂的和的数字的个数。具体参见：刘聪《浅谈数位类问题》，讲的肯定比我自己说的要好TAT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y, k, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">32</span>][<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dgt[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = c[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            c[i][j] += c[i-<span class="number">1</span>][j-<span class="number">1</span>] + c[i-<span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        dgt[++l] = x % b;</span><br><span class="line">        x /= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dgt[i] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ans += c[i][k-mk];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dgt[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; k-mk) ans += c[i-<span class="number">1</span>][k-mk];</span><br><span class="line">            <span class="keyword">if</span> (++mk &gt; k) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((i == <span class="number">1</span>) &amp;&amp; (mk == k)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; k &gt;&gt; b;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cal(y) - cal(x-<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1058" target="_blank" rel="external">Chocolate</a></p>
<p>比较那个的计算几何，我还不会写计算几何的题目，先留个坑，以后再填</p>
<pre><code><span class="comment">//占位-_-#</span>
</code></pre><p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1059" target="_blank" rel="external">Expression</a></p>
<p>题目大意：输出一个一元N次多项式的最短后缀表达式。然后有</p>
<p><img src="http://upload.wikimedia.org/math/d/2/5/d25290170053cbfe1d467c061e2a3e38.png" alt="f(x)=a_0x^n+a_{1}x^{n-1}+a_{2}x^{n-2}+......+a_{n-2}x^2+a_{n-1}x+a_n">  可以化成</p>
<p><img src="http://upload.wikimedia.org/math/7/5/1/7514d392c909ec6ba2fec54d5e4a7b29.png" alt="f(x)=(((a_nx+a_{n-1})x+a_{n-2})x+......+a_1)x+a_0"></p>
<p>然后规律就很明显了，直接输出就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'X'</span> &lt;&lt; endl &lt;&lt; <span class="string">'*'</span> &lt;&lt; endl &lt;&lt; i+<span class="number">1</span> &lt;&lt; endl &lt;&lt; <span class="string">'+'</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目链接：<a href="http://acm.timus.ru/problemset.aspx?space=1&amp;page=1">戳我</a>（1053－1059）</p>
<p><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1053">Pinocchio</a></p>
<p>题目还比较好理解，每次选两个数，大数减去小数，相等则合并，其实就是求出所有数的最大公约数，然后就是直接做了。<br>]]>
    
    </summary>
    
      <category term="DFS" scheme="https://github.com/sillyplus/tags/DFS/"/>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="Graph" scheme="https://github.com/sillyplus/tags/Graph/"/>
    
      <category term="Math" scheme="https://github.com/sillyplus/tags/Math/"/>
    
      <category term="Timus" scheme="https://github.com/sillyplus/tags/Timus/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[最大/小连续子序列和]]></title>
    <link href="https://github.com/sillyplus/2014/04/15/msl/"/>
    <id>https://github.com/sillyplus/2014/04/15/msl/</id>
    <published>2014-04-15T01:48:02.000Z</published>
    <updated>2015-10-19T11:27:37.000Z</updated>
    <content type="html"><![CDATA[<p>给定一个序列，要求出一段连续的子序列，是的其和最大或最小。<br>这是一个很经典的问题，最近做了相关的题目，在这里总结一下。<br><a id="more"></a><br>最直接的一个想法自然是直接暴力枚举每个子段，O(N³)，用前缀和优化一下，这样做的复杂度是O(n²)。在n比较小的时候自然是这种简单易得的方法最好啦。但是人生就是这样子，总不能让你事事如意。然后呢，我们就需要一些更快的方法。</p>
<p>然后我们就发现呢，可以用简单的DP求解，f[i]表示以第i个数为结尾的最大连续子序列和，则可以得到</p>
<p>f[i] = max{f[i-1]+a[i], a[i]}</p>
<p>求最小值自然也可以用同样的方法，这样做的复杂度是O(n)。</p>
<p>看这道题：Sicily p1888:<a href="http://soj.me/1888" target="_blank" rel="external">Circular Sequence</a></p>
<p>题目大意是：给定一个整数的循环序列，求其最大连续子序列和。</p>
<p>对于循环序列，我们一般用的方法是把整个序列复制一遍加到原序列后面，这样这个问题就转化成求得到的新序列的长度不超过原长n的最大连续子序列和(好绕口。。。。)，这个问题我们在后面讨论。这里其实我们可以不利用序列是循环的这个性质，那就只是普通的最大和问题，我们就可以用上面的方法求一遍得到Ans1，然后考虑一下循环的话，那么最大子序列必定是由原序列的一个前缀和一个后缀组成。然后可以发现，剩下的中间那部分其实就是最小连续子序列，所以我们由第二个数到倒数第二个数求一遍最小和(＊)，得到Ans2。最后的答案就是max(Ans1，Sum－ Ans2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a[MN];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, t;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">max_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LL ret = a[<span class="number">0</span>];</span><br><span class="line">        LL tmp = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmp = a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = max(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">min_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ret = a[<span class="number">1</span>];</span><br><span class="line">        LL tmp = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tmp = a[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = min(ret, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">            LL sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">                sum += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            LL ans = max(max_sum(), sum - min_sum());</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在西西里上一开始用I64d输出，一直WA。。。时不时总要被这样的东西坑一下TAT</span><br><span class="line"></span><br><span class="line">－－－－－－－－－－－－－－－我是华丽的分割线－－－－－－－－－－－－－－－</span><br><span class="line"></span><br><span class="line">接着填一下上面留下的坑。</span><br><span class="line"></span><br><span class="line">在求子序列和的时候，如果给定子序列长度的上下界又该怎么做。</span><br><span class="line"></span><br><span class="line">同样使用动态规划的解法，我们可以列出方程f[i] = max&#123;sum[i] - min(sum[j - <span class="number">1</span>])&#125; ，这样做是O(n²),显然不是我们想要的，然后呢我们就可以用单调队列来优化啦～</span><br><span class="line"></span><br><span class="line">对于长度的上界MX就是直接的来咯，然后下界MI就利用一个小技巧，从MI开始枚举，然后i-MI入队，这样就保证了序列的长度不小于MI了，每次更新完队首就是符合条件的min(sum[j - <span class="number">1</span>])了。如果还是不大理解具体可以看代码理解一下。</span><br><span class="line"></span><br><span class="line">这里求的是最小连续子序列和：Sicily p1800 [Sequence](http:<span class="comment">//soj.me/1800)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">    <span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MN = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> f[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, l, r, mi, mx, ans, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;mi, &amp;mx);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">                sum[i] = sum[i-<span class="number">1</span>] + k;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r = <span class="number">0</span>;</span><br><span class="line">            f[++r] = <span class="number">0</span>;</span><br><span class="line">            ans = <span class="number">2147483647</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = mi; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; i - f[l+<span class="number">1</span>] &gt; mx) l++;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r &amp;&amp; sum[f[r]] &lt;= sum[i-mi]) r--;</span><br><span class="line">                f[++r] = i - mi;</span><br><span class="line">                ans = min(ans, sum[i] - sum[f[l+<span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>给定一个序列，要求出一段连续的子序列，是的其和最大或最小。<br>这是一个很经典的问题，最近做了相关的题目，在这里总结一下。<br>]]>
    
    </summary>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="Sicily" scheme="https://github.com/sillyplus/tags/Sicily/"/>
    
      <category term="单调队列" scheme="https://github.com/sillyplus/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Codeforces 401D Roman and Numbers]]></title>
    <link href="https://github.com/sillyplus/2014/04/15/codeforces-401d-roman-and-numbers/"/>
    <id>https://github.com/sillyplus/2014/04/15/codeforces-401d-roman-and-numbers/</id>
    <published>2014-04-15T01:35:56.000Z</published>
    <updated>2015-10-19T11:27:16.000Z</updated>
    <content type="html"><![CDATA[<p>简要题意：给定n，m，<em>n</em> (1 ≤ <em>n</em> &lt; 10ˆ18) and <em>m</em> (1 ≤ <em>m</em> ≤ 100).求满足以下要求的数x有多少个。</p>
<ul>
<li>x可通过重排n的各位数字获得</li>
<li>x没有前导0</li>
<li>x mod m == 0</li>
</ul>
<p>一开始我被10ˆ18给吓到了，但是其实这里也是一个突破口来着，仔细想想，如果是2ˆ18的话那该多好。<br>如果你往这个方向开始去想了，就会发现很多东西了，然后就是个DP，然后再去一下重，当然，你也可以在DP的过程中去重。<br>不过，感觉我的DP水平实在是不济，这个是赛后搞出来的。。。<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[MN][<span class="number">103</span>];</span><br><span class="line"><span class="keyword">int</span> dig[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> fac[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> l;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; m;</span><br><span class="line">    l = <span class="built_in">strlen</span>(c);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        dig[c[i] - <span class="string">'0'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; l); s++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[s][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (~s &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!s &amp;&amp; c[i] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        f[s | (<span class="number">1</span> &lt;&lt; i)][(j * <span class="number">10</span> + c[i] - <span class="string">'0'</span>) % m] += f[s][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = f[(<span class="number">1</span> &lt;&lt; l) - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ans /= fac[dig[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简要题意：给定n，m，<em>n</em> (1 ≤ <em>n</em> &lt; 10ˆ18) and <em>m</em> (1 ≤ <em>m</em> ≤ 100).求满足以下要求的数x有多少个。</p>
<ul>
<li>x可通过重排n的各位数字获得</li>
<li>x没有前导0</li>
<li>x mod m == 0</li>
</ul>
<p>一开始我被10ˆ18给吓到了，但是其实这里也是一个突破口来着，仔细想想，如果是2ˆ18的话那该多好。<br>如果你往这个方向开始去想了，就会发现很多东西了，然后就是个DP，然后再去一下重，当然，你也可以在DP的过程中去重。<br>不过，感觉我的DP水平实在是不济，这个是赛后搞出来的。。。<br>]]>
    
    </summary>
    
      <category term="Codeforces" scheme="https://github.com/sillyplus/tags/Codeforces/"/>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 2663 Tri Tiling 构造矩阵＋矩阵乘法]]></title>
    <link href="https://github.com/sillyplus/2013/12/26/poj-2663-tri-tiling/"/>
    <id>https://github.com/sillyplus/2013/12/26/poj-2663-tri-tiling/</id>
    <published>2013-12-25T17:36:29.000Z</published>
    <updated>2015-10-19T11:53:22.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意是一个3<em>N的棋盘，用1</em>2的骨牌覆盖的方案数</p>
<p>使用一个三位的二进制数表示状态，则可以有：</p>
<p>n行：000  ……………………………………. 000</p>
<p>n-1行：000  001  010   011…………………  111</p>
<p>为避免状态重复，我们不允许在n-1行上平放骨牌（因为等会由n-1行转移的第n行时，我们可以在n行上平放），所以我们可以构造一个矩阵来表示这些转移（具体自己画一画就知道了），即可以得到以下矩阵A：</p>
<p>0000000100000010000001000000100100010000001000000100000110010010然后求A的n次幂，A^n[7][7]就是我们要的答案啦～<br><a id="more"></a><br>至于矩阵方面的一些知识，可以看一下Matrix67的这篇文章：<a href="http://www.matrix67.com/blog/archives/276" target="_blank" rel="external">十个利用矩阵乘法解决的经典题目</a></p>
<!-- code -->
<pre><code><span class="comment">//</span>
<span class="comment">//  main.cpp</span>
<span class="comment">//  p2663</span>
<span class="comment">//</span>
<span class="comment">//  Created by Silly on 13-12-26.</span>
<span class="comment">//  Copyright (c) 2013年 Silly. All rights reserved.</span>
<span class="comment">//</span>

<span class="preprocessor">#<span class="keyword">include</span></span>
<span class="preprocessor">#<span class="keyword">include</span></span>
<span class="preprocessor">#<span class="keyword">include</span></span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;

<span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span>  ll;

<span class="keyword">const</span> ll  mat[<span class="number">8</span>][<span class="number">8</span>] = {
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>},
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>},
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>},
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>},
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},
    {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>},
    {<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>},
    {<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>},
};

<span class="keyword">struct</span> ma {
    ll a[<span class="number">8</span>][<span class="number">8</span>];
};

ma res, tmp;

<span class="function">ma <span class="title">mm</span><span class="params">(ma x, ma y)</span> </span>{
    ma z;
    <span class="built_in">memset</span>(z.a ,<span class="number">0</span> , <span class="keyword">sizeof</span>(z.a));
    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) {
                z.a[i][j] += x.a[i][k] * y.a[k][j];
            }
        }
    }
    <span class="keyword">return</span> z;
}

<span class="function">ma <span class="title">mp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{
    ma z;
    <span class="keyword">if</span> (x == <span class="number">1</span>) {
        <span class="keyword">return</span> res;
    }
    z = mp(x / <span class="number">2</span>);
    z = mm(z, z);
    <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) {
        z = mm(res, z);
    }
    <span class="keyword">return</span> z;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span>
</span>{
    <span class="keyword">int</span> n;
    <span class="built_in">cin</span> &gt;&gt; n;
    <span class="keyword">while</span> (n != -<span class="number">1</span>) {
        <span class="keyword">if</span> (n == <span class="number">0</span>) {
            <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;
            <span class="built_in">cin</span> &gt;&gt; n;
            <span class="keyword">continue</span>;
        }
        <span class="built_in">memset</span>(res.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(res.a));
        <span class="built_in">memset</span>(tmp.a, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp.a));
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) {
            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) {
                res.a[i][j] = mat[i][j];
            }
        }
        tmp = mp(n);
        <span class="built_in">printf</span>(<span class="string">"%lldn"</span>, tmp.a[<span class="number">7</span>][<span class="number">7</span>]);
        <span class="built_in">cin</span> &gt;&gt; n;
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><!-- endcode -->
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意是一个3<em>N的棋盘，用1</em>2的骨牌覆盖的方案数</p>
<p>使用一个三位的二进制数表示状态，则可以有：</p>
<p>n行：000  ……………………………………. 000</p>
<p>n-1行：000  001  010   011…………………  111</p>
<p>为避免状态重复，我们不允许在n-1行上平放骨牌（因为等会由n-1行转移的第n行时，我们可以在n行上平放），所以我们可以构造一个矩阵来表示这些转移（具体自己画一画就知道了），即可以得到以下矩阵A：</p>
<p>0000000100000010000001000000100100010000001000000100000110010010然后求A的n次幂，A^n[7][7]就是我们要的答案啦～<br>]]>
    
    </summary>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="矩阵乘法" scheme="https://github.com/sillyplus/tags/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 动态规划题目列表 ]]></title>
    <link href="https://github.com/sillyplus/2013/12/23/poj-dp-list/"/>
    <id>https://github.com/sillyplus/2013/12/23/poj-dp-list/</id>
    <published>2013-12-23T06:03:33.000Z</published>
    <updated>2015-10-19T11:26:49.000Z</updated>
    <content type="html"><![CDATA[<p>这份列表当然不是我原创的，从文库里下载了一份，放到这里便于自己浏览和查找题目。（ps：这句话也不是我写的，转自lyd）<br><a id="more"></a><br><strong>※**</strong>最近更新：<strong><strong>Poj</strong></strong>斜率优化题目**</p>
<p>1180，2018，3709</p>
<p><strong>列表一：经典题目题号：**</strong><br>**容易：<br>1018, 1050, 1083, 1088, 1125, 1143, 1157, 1163, 1178, 1179, 1189, 1191,1208, 1276, 1322, 1414, 1456, 1458,</p>
<p>1609, 1644, 1664, 1690, 1699, 1740, 1742, 1887, 1926, 1936, 1952, 1953, 1958, 1959, 1962, 1975, 1989, 2018,</p>
<p>2029, 2039, 2063, 2081, 2082, 2181, 2184, 2192, 2231, 2279, 2329, 2336, 2346, 2353, 2355, 2356, 2385, 2392, 2424,<br>不易：<br>1019, 1037, 1080, 1112, 1141, 1170, 1192, 1239, 1655, 1695, 1707, 1733(区间减法加并查集),</p>
<p>1737, 1837, 1850, 1920(加强版汉罗塔), 1934(全部最长公共子序列), 1964(最大矩形面积，O(n*m)算法), 2138, 2151, 2161, 2178,<br>推荐：<br>1015, 1635, 1636(挺好的), 1671, 1682, 1692(优化), 1704, 1717, 1722, 1726, 1732, 1770,</p>
<p>1821, 1853, 1949, 2019, 2127, 2176, 2228, 2287, 2342, 2374, 2378, 2384, 2411<br><strong>列表二：完整**</strong>DP<strong>**题目列表</strong></p>
<p>1015 Jury Compromise<br>1029 False coin<br>1036 Gangsters<br>1037 A decorative fence<br>1038 Bugs Integrated, Inc.<br>1042 Gone Fishing<br>1050 To the Max<br>1062 昂贵的聘礼<br>1074 Parallel Expectations<br>1080 Human Gene Functions<br>1088 滑雪<br>1093 Formatting Text<br>1112 Team Them Up!<br>1141 Brackets Sequence<br>1143 Number Game<br>1157 LITTLE SHOP OF FLOWERS<br>1159 Palindrome<br>1160 Post Office<br>1163 The Triangle<br>1170 Shopping Offers<br>1178 Camelot<br>1179 Polygon<br>1180 Batch Scheduling<br>1185 炮兵阵地<br>1187 陨石的秘密<br>1189 钉子和小球<br>1191 棋盘分割<br>1192 最优连通子集<br>1208 The Blocks Problem<br>1239 Increasing Sequences<br>1240 Pre-Post-erous!<br>1276 Cash Machine<br>1293 Duty Free Shop<br>1322 Chocolate<br>1323 Game Prediction<br>1338 Ugly Numbers<br>1390 Blocks<br>1414 Life Line<br>1432 Decoding Morse Sequences<br>1456 Supermarket<br>1458 Common Subsequence<br>1475 Pushing Boxes<br>1485 Fast Food<br>1505 Copying Books<br>1513 Scheduling Lectures<br>1579 Function Run Fun<br>1609 Tiling Up Blocks<br>1631 Bridging signals 2分+DP NLOGN<br>1633 Gladiators<br>1635 Subway tree systems<br>1636 Prison rearrangement<br>1644 To Bet or Not To Bet<br>1649 Market Place<br>1651 Multiplication Puzzle<br>1655 Balancing Act<br>1661 Help Jimmy<br>1664 放苹果<br>1671 Rhyme Schemes<br>1682 Clans on the Three Gorges<br>1690 (Your)((Term)((Project)))<br>1691 Painting A Board<br>1692 Crossed Matchings<br>1695 Magazine Delivery<br>1699 Best Sequence<br>1704 Georgia and Bob<br>1707 Sum of powers<br>1712 Flying Stars<br>1714 The Cave<br>1717 Dominoes<br>1718 River Crossing<br>1722 SUBTRACT<br>1726 Tango Tango Insurrection<br>1732 Phone numbers<br>1733 Parity game<br>1737 Connected Graph<br>1740 A New Stone Game<br>1742 Coins P<br>1745 Divisibility<br>1770 Special Experiment<br>1771 Elevator Stopping Plan<br>1776 Task Sequences<br>1821 Fence<br>1837 Balance<br>1848 Tree<br>1850 Code<br>1853 Cat<br>1874 Trade on Verweggistan<br>1887 Testing the CATCHER<br>1889 Package Pricing<br>1920 Towers of Hanoi<br>1926 Pollution<br>1934 Trip<br>1936 All in All<br>1937 Balanced Food<br>1946 Cow Cycling<br>1947 Rebuilding Roads<br>1949 Chores<br>1952 BUY LOW, BUY LOWER<br>1953 World Cup Noise<br>1958 Strange Towers of Hanoi<br>1959 Darts<br>1962 Corporative Network<br>1964 City Game<br>1975 Median Weight Bead<br>1989 The Cow Lineup<br>2018 Best Cow Fences<br>2019 Cornfields<br>2029 Get Many Persimmon Trees<br>2033 Alphacode<br>2039 To and Fro<br>2047 Concert Hall Scheduling<br>2063 Investment<br>2081 Recaman’s Sequence<br>2082 Terrible Sets<br>2084 Game of Connections<br>2127 Greatest Common Increasing Subsequence<br>2138 Travel Games<br>2151 Check the difficulty of problems<br>2152 Fire<br>2161 Chandelier<br>2176 Folding<br>2178 Heroes Of Might And Magic<br>2181 Jumping Cows<br>2184 Cow Exhibition<br>2192 Zipper<br>2193 Lenny’s Lucky Lotto Lists<br>2228 Naptime<br>2231 Moo Volume<br>2279 Mr. Young’s Picture Permutations<br>2287 Tian Ji – The Horse Racing<br>2288 Islands and Bridges<br>2292 Optimal Keypad<br>2329 Nearest number - 2<br>2336 Ferry Loading II<br>2342 Anniversary party<br>2346 Lucky tickets<br>2353 Ministry<br>2355 Railway tickets<br>2356 Find a multiple<br>2374 Fence Obstacle Course<br>2378 Tree Cutting<br>2384 Harder Sokoban Problem<br>2385 Apple Catching<br>2386 Lake Counting<br>2392 Space Elevator<br>2397 Spiderman<br>2411 Mondriaan’s Dream<br>2414 Phylogenetic Trees Inherited<br>2424 Flo’s Restaurant<br>2430 Lazy Cows<br>2915 Zuma<br>3017 Cut the Sequence<br>3028 Shoot-out<br>3124 The Bookcase<br>3133 Manhattan Wiring<br>3345 Bribing FIPA<br>3375 Network Connection<br>3420 Quad Tiling ?</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这份列表当然不是我原创的，从文库里下载了一份，放到这里便于自己浏览和查找题目。（ps：这句话也不是我写的，转自lyd）<br>]]>
    
    </summary>
    
      <category term="Poj" scheme="https://github.com/sillyplus/tags/Poj/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Poj 图论题目列表]]></title>
    <link href="https://github.com/sillyplus/2013/12/23/poj-graph-theory-ist/"/>
    <id>https://github.com/sillyplus/2013/12/23/poj-graph-theory-ist/</id>
    <published>2013-12-23T05:58:45.000Z</published>
    <updated>2015-10-19T11:26:53.000Z</updated>
    <content type="html"><![CDATA[<p>转自别的地方，先放着，激励自己去刷题<br><a id="more"></a><br>1062<em> 昂贵的聘礼 枚举等级限制+dijkstra<br>1087</em> A Plug for UNIX 2分匹配<br>1094 Sorting It All Out floyd 或 拓扑<br>1112<em> Team Them Up! 2分图染色+DP<br>1122 FDNY to the Rescue! 最短路<br>1125 Stockbroker Grapevine FLOYD<br>1128 Frame Stacking 拓扑排序<br>1135 Domino Effect 最短路<br>1149</em> PIGS 网络流<br>1161<em> Walls Floyd<br>1192 最优连通子集<br>1201 Intervals 差分约束<br>1236</em> Network of Schools 强联通<br>1251 Jungle Roads MST<br>1258 Agri-Net MST<br>1270 Following Orders 拓扑排序<br>1273 Drainage Ditches 最大流<br>1274 The Perfect Stall 2分匹配<br>1275<em> Cashier Employment 差分约束<br>1287 Networking MST<br>1300 Door Man 欧拉路<br>1324 Holedox Moving BFS<br>1325 Machine Schedule 2分匹配(最小点覆盖)<br>1364 King 差分约束<br>1386 Play on Words 欧拉路<br>1422 Air Raid 2分匹配<br>1459 Power Network 网络流<br>1466 Girls and Boys 2分图(最大独立团)<br>1469 COURSES 2分匹配<br>1502 MPI Maelstrom floyd<br>1511</em> Invitation Cards 最短路<br>1556 The Doors 最短路<br>1562 Oil Deposits DFS<br>1603 Risk 最短路<br>1613 Cave Raider 最短路<br>1637<em> Sightseeing tour 混合图欧拉回路-网络流<br>1659 Frogs’ Neighborhood Havel-Hakimi定理<br>1679 The Unique MST MST唯一性<br>1716 Integer Intervals 差分约束<br>1724</em> ROADS 最短路-拆点<br>1751 Highways MST<br>1780<em> Code 欧拉回路<br>1789 Truck History MST<br>1797 Heavy Transportation 最小生成树<br>1847 Tram 最短路<br>1861 Network MST<br>1904</em> King’s Quest 强联通<br>1949 Chores 最短路<br>1979 Red and Black DFS<br>2031 Building a Space Station MST<br>2060 Taxi Cab Scheme 2分匹配<br>2075 Tangled in Cables 最小生成树<br>2112 Optimal Milking 网络流<br>2125 Destroying The Graph 最小割<br>2135 Farm Tour 费用流<br>2139 Six Degrees of Cowvin Bacon floyd<br>2226 Muddy Fields 2分匹配<br>2230 Watchcow 欧拉回路<br>2239 Selecting Courses 2分匹配<br>2240 Arbitrage 最短路<br>2253 Frogger 最短路<br>2263 Heavy Cargo 最短路<br>2267<em> From Dusk till Dawn or: Vladimir the Vampire 最短路<br>2289 Jamie’s Contact Groups 网络流<br>2337 Catenyms 欧拉通路<br>2349 Arctic Network 最小生成树<br>2367 Genealogical tree 拓扑排序<br>2387 Til the Cows Come Home 最短路<br>2391</em> Ombrophobic Bovines 最大流<br>2394 Checking an Alibi 最短路<br>2396<em> Budget 网络流<br>2421</em> Constructing Roads 最小生成树<br>2446 Chessboard 2分匹配<br>2455 Secret Milking Machine 网络流<br>2457 Part Acquisition 最短路<br>2472 106 miles to Chicago 最短路<br>2485 Highways 最小生成树<br>2513 Colored Sticks 欧拉路<br>2516 Minimum Cost 费用流<br>2536 Gopher II 2分匹配<br>2553<em> The Bottom of a Graph 强联通<br>2570 Fiber Network 最短路<br>2584 T-Shirt Gumbo 网络流<br>2585 Window Pains 拓扑排序<br>2594</em> Treasure Exploration 2分匹配<br>2607 FireStation 最短路<br>2723 Get Luffy Out 2-sat<br>2724 Purifying Machine 2分匹配<br>2728 Desert King 最优比例生成树<br>2749<em> Building roads 2-sat<br>2762 Going from u to v or from v to u? 强联通<br>2935 Basic Wall Maze BFS<br>2942 Knights of the Round Table 点双连通分量+二分图判定<br>2949</em> Word Rings 差分约束<br>2983 Is the Information Reliable? 差分约束<br>2987 Firing 最小割(求解正确性??)<br>3020 Antenna Placement 2分匹配<br>3026 Borg Maze MST<br>3041 Asteroids 2分匹配<br>3072<em> Robot 最短路<br>3159 Steady Cow Assignment差分约束<br>3160 Father Christmas flymouse 强联通<br>3164 Command Network 最小树形图<br>3169 Layout 差分约束<br>3177 Redundant Paths 双联通分量<br>3189 Steady Cow Assignment 网络流<br>3204 Ikki’s Story I - Road Reconstruction 最大流<br>3207 Ikki’s Story IV - Panda’s Trick 2sat<br>3216 Repairing Company 2分匹配<br>3228 Gold Transportation 网络流<br>3255 Roadblocks 最短路<br>3259 Wormholes 最短路<br>3268 Silver Cow Party 最短路<br>3275 Ranking the Cows floyd<br>3281 Dining 最大流<br>3308 Paratroopers 最小割<br>3310 Caterpillar<br>3311 Hie with the Pie floyd<br>3328 Cliff Climbing 最短路<br>3343 Against Mammoths 2分匹配<br>3352 Road Construction 桥<br>3439 Server Relocation 最短路<br>3463 Sightseeing 最短路<br>3469 Dual Core CPU 最小割<br>3487 The Stable Marriage Problem 稳定婚姻<br>3522 Slim Span 最小生成树<br>3594 Escort of Dr. Who How 最短路<br>3615 Cow Hurdles 最短路<br>3621 Sightseeing Cows 二分枚举+判负环<br>3648 Wedding 2-sat<br>3653 Here We Go(relians) Again 最短路<br>3659</em> Cell Phone Network 最小支配集<br>3660 Cow Contest 拓扑排序<br>3662<em> Telephone Lines 最短路<br>3678 Katu Puzzle 2-sat<br>3683</em> Priest John’s Busiest Day 2-sat求解<br>3687 Labeling Balls 差分约束 或 拓扑排序<br>3692 Kindergarten 2分匹配<br>3694 Network 无向图缩点</p>
<p>POJ 2449 Remmarguts’ Date(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2449" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2449</a><br>题意：经典问题：K短路<br>解法：dijkstra+A<em>(rec)，方法很多<br>相关：<a href="http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1144" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/showcontest?contest_id=1144</a><br>该题亦放在搜索推荐题中<br>POJ 3013 – Big Christmas Tree(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3013" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3013</a><br>题意：最简单最短路，但此题要过，需要较好的程序速度和，还要注意精度<br>解法：Dijkstra<br>POJ 3463 – Sightseeing(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3463" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3463</a><br>题意：最短路和比最短路大1的路的数量<br>解法：需要真正理解dijkstra<br>POJ 3613 – Cow Relays(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3613" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3613</a><br>题意：求经过N条边的最短路<br>解法：floyd + 倍增，贪心<br>POJ 3621 – Sightseeing Cows(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3621" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3621</a><br>题意：求一个环路，欢乐值 / 总路径最大<br>解法：参数搜索 + 最短路(ms 原始的bellman tle, 用spfa才过)<br>POJ 3635 – full tank?(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3635" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3635</a><br>题意：最短路变形<br>解法：广搜<br>相关：<a href="http://hi.baidu.com/hnu_reason/blog/item/086e3dccfc8cb21600e9286b.html" target="_blank" rel="external">http://hi.baidu.com/hnu_reason/blog/item/086e3dccfc8cb21600e9286b.html</a><br>生成树问题<br>基本的生成树就不放上来了<br>POJ 1639 – Picnic Planning(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1639" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1639</a><br>题意：顶点度数有限制的最小生成树<br>解法：贪心 + prim/kruskal<br>POJ 1679 – The Unique MST(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1679" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1679</a><br>题意：判断MST是否唯一<br>解法：prim就行，不过还是易错的题<br>POJ 2728 – Desert King(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2728" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2728</a><br>题意：所谓最优比率生成树<br>解法：参数搜索 + prim<br>POJ 3164 – Command Network(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3164" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3164</a><br>题意：最小树形图<br>解法：刘朱算法，这个考到的可能性比较小吧？<br>POJ 3522 – Slim Span(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3522" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3522</a><br>题意：求一颗生成树，让最大边最小边差值最小<br>解法：kruskal活用<br>连通性，度数，拓扑问题<br>此类问题主要牵扯到DFS，缩点等技巧<br>POJ 1236 – Network of Schools(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1236" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1236</a><br>题意：问添加多少边可成为完全连通图<br>解法：缩点，看度数<br>POJ 1659 – Frogs’ Neighborhood(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1659" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1659</a><br>题意：根据度序列构造图<br>解法：贪心，详细证明参见havel定理<br>POJ 2553 – The Bottom of a Graph(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2553" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2553</a><br>POJ 2186 – Popular Cows(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2186" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2186</a><br>题意：强连通分量缩点图出度为0的点<br>POJ 2762 – Going from u to v or from v to u?(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2762" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2762</a><br>题意：单向连通图判定<br>解法：缩点 + dp找最长链<br>POJ 2914 – Minimum Cut(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2914" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2914</a><br>题意：无向图最小割<br>解法：Stoer-Wagner算法，用网络流加枚举判定会挂<br>POJ 2942 – Knights of the Round Table(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2942" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2942</a><br>题意：求双联通分量(或称块)中是否含奇圈<br>解法：求出双连通分量后做黑白染色进行二分图图判定<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/57ada7ed104ce9d2b31cb104.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/57ada7ed104ce9d2b31cb104.html</a><br>POJ 3177 – Redundant Paths(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3177" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3177</a><br>POJ 3352 – Road Construction(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3352" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3352</a><br>题意：添加多少条边可成为双向连通图<br>解法：把割边分开的不同分量缩点构树，看入度<br>建议对比下1236，有向图添加多少条边变成强连通图<br>POJ 3249 – Test for Job(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3249" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3249</a><br>解法：bfs / dfs + dp<br>POJ 3592 – Instantaneous Transference(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3592" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3592</a><br>解法：缩点，最长路，少人做的水题，注意细节<br>POJ 3687 – Labeling Balls(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3687" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3687</a><br>解法：拓扑排序<br>POJ 3694 – Network(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3694" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3694</a><br>解法：双连通分量+并查集<br>2-SAT问题<br>此类问题理解合取式的含义就不难<br>POJ 2723 – Get Luffy Out(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2723" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2723</a><br>POJ 2749 – Building roads(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2749" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2749</a><br>解法：二分 + 2-SAT判定<br>POJ 3207 – Ikki’s Story IV – Panda’s Trick(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3207" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3207</a><br>解法：简单的2-sat，不过其他方法更快<br>POJ 3648- Wedding(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3648" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3648</a><br>解法：用2-sat做会比较有意思，但是暴搜照样0ms<br>POJ 3678 – Katu Puzzle(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3678" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3678</a><br>解法：直接按合取式构图验证就行了<br>POJ 3683 – Priest John’s Busiest Day(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3683" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3683</a><br>解法：n^2枚举点之间的相容性构图，求解2-SAT<br>最大流问题<br>变形很多，最小割最大流定理的理解是关键<br>POJ 1149 – PIGS(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1149" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1149</a><br>绝对经典的构图题<br>POJ 1273 – Drainage Ditches(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1273" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1273</a><br>最大流入门<br>POJ 1459 – Power Network(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1459" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1459</a><br>基本构图<br>POJ 1637 – Sightseeing tour(Crazy)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1637" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1637</a><br>题意：求混合图的欧拉迹是否存在<br>解法：无向边任意定向，构图，详建黑书P324<br>POJ 1815 – Friendship(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1815" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1815</a><br>题意：求最小点割<br>解法：拆点转换为边割<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/a521f230b06dea9fa9018e0e.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/a521f230b06dea9fa9018e0e.html</a><br>POJ 1966 – Cable TV Network(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1966" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1966</a><br>题意：去掉多少点让图不连通<br>解法：任定一源点，枚举汇点求点割集(转换到求边割)，求其中最小的点割<br>POJ 2112 – Optimal Milking(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2112" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2112</a><br>二分枚举，最大流<br>POJ 2391 – Ombrophobic Bovines(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2391" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2391</a><br>题意：floyd, 拆点，二分枚举<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/3e0006c4f73f0eaf8226acff.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/3e0006c4f73f0eaf8226acff.html</a><br>POJ 2396 – Budget(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2396" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2396</a><br>题意：有源汇的上下界可行流<br>解法：用矩阵-网络流模型构图，然后拆边<br>相关：<a href="http://hi.baidu.com/zfy0701/blog/item/6449d82a64e15e3e5343c1ba.html" target="_blank" rel="external">http://hi.baidu.com/zfy0701/blog/item/6449d82a64e15e3e5343c1ba.html</a><br>，最小割模型在竞赛中的应用<br>POJ 2455 – Secret Milking Machine(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2455" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2455</a><br>二分枚举，一般来说需要写对边容量的更新操作而不是每次全部重新构图<br>POJ 2699 – The Maximum Number of Strong Kings(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2699" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2699</a><br>解法：枚举人数 + 最大流(感谢xpcnq_71大牛的建图的提示)<br>POJ 2987 – Firing(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2987" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2987</a><br>题意：最大权闭包<br>解法：先边权放大，第一问总量-最大流，第二问求最小割<br>相关：<a href="http://wywcgs.spaces.live.com/blog/cns!4D861A02A3382142!1109.entry?&amp;_c02_owner=1" target="_blank" rel="external">http://wywcgs.spaces.live.com/blog/cns!4D861A02A3382142!1109.entry?&amp;_c02_owner=1</a><br>Profit(中等)<br><a href="http://www.vijos.cn/Problem_Show.asp?id=1352" target="_blank" rel="external">http://www.vijos.cn/Problem_Show.asp?id=1352</a><br>最大权闭包图的特殊情况<br>ZOJ 2071 – Technology Trader 也是此类型，懒了没做<br><a href="http://acm.zju.edu.cn/show_problem.php?pid=2071" target="_blank" rel="external">http://acm.zju.edu.cn/show_problem.php?pid=2071</a><br>POJ 3084 – Panic Room(中等，好题)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3084" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3084</a><br>题意：略<br>解法：根据最小割建模<br>POJ 3155 – Hard Life(很挑战一题)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3155" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3155</a><br>题意：最大密度子图<br>解法：参数搜索 + 最大权闭合图，A.V.Goldberg的论文(nb解法)<br>最小割模型在信息学竞赛中的应用 一文中也有讲<br>POJ 3189 – Steady Cow Assignment(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3189" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3189</a><br>题意：寻找最小的区间完成匹配<br>解法：这题充分说明SAP的强大，纯暴力可过。更好的方法是在枚举区间的过程中不断删边和加边继续网络流过程<br>POJ 3204 – Ikki’s Story I – Road Reconstruction(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3204" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3204</a><br>ZOJ 2532 – Internship(基础)<br><a href="http://acm.zju.edu.cn/show_problem.php?pid=2532" target="_blank" rel="external">http://acm.zju.edu.cn/show_problem.php?pid=2532</a><br>题意：确定边是否是某个割中的边<br>解法：两边dfs求割, 或暴力枚举(需要写取消某条增广路的操作(但数据弱，也许不取消也能混过))<br>POJ 3308 – Paratroopers(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3308" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3308</a><br>POJ 2125 – Destroying The Graph(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2125" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2125</a><br>题意：最小点权覆盖<br>POJ 3469 – Dual Core CPU(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3469" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3469</a><br>题意：最小割<br>POJ 3498 – March of the Penguins(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3498" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3498</a><br>题意：满足点容量限制的网络流<br>解法：拆点把点容量转换为边容量，枚举汇点<br>ZOJ 2587 – Unique Attack(较难)<br><a href="http://acm.zju.edu.cn/show_problem.php?pid=2587" target="_blank" rel="external">http://acm.zju.edu.cn/show_problem.php?pid=2587</a><br>题意：确定最小割是否是唯一的<br>解法：得理解dfs求最小割算法的本质<br>SPOJ 839 – Optimal Marks(难)<br><a href="http://www.spoj.pl/problems/OPTM/" target="_blank" rel="external">http://www.spoj.pl/problems/OPTM/</a><br>题意：略<br>解法：很经典哦，见amber的集训队论文，根据标号的每一位求最小割<br>SGU 326 – Perspective(中等)<br><a href="http://acm.sgu.ru/problem.php?c0&amp;problem=326" target="_blank" rel="external">http://acm.sgu.ru/problem.php?c0&amp;problem=326</a><br>比较经典的构图法<br>费用流问题<br>可以KM解的就不放在这里，另外，感觉除非很特殊的图，一般用连续增广路的算法就够了<br>POJ 2175 – Evacuation Plan(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2175" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2175</a><br>题意：判断是否给定解是最优解，比较阴的一题<br>解法：根据给出的计划构造流，然后消且只消一次负圈<br>POJ 3422 – Kaka’s Matrix Travels(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3422" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3422</a><br>题意：略<br>解法：拆点<br>POJ 3680 – Intervals(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3680" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3680</a><br>题意：略，这题还是蛮经典<br>解法：discuss中比较详细<br>SPOJ 371 – Boxes(简单)<br><a href="http://www.spoj.pl/problems/BOXES/" target="_blank" rel="external">http://www.spoj.pl/problems/BOXES/</a><br>题意：略<br>解法：费用流，但似乎有比网络流更好的做法<br>SGU 185 – Two shortest(中等)<br><a href="http://acm.sgu.ru/problem.php?c0&amp;problem=185" target="_blank" rel="external">http://acm.sgu.ru/problem.php?c0&amp;problem=185</a><br>题意：求两条不想交的最短路径<br>解法：费用流，也可以最短路 + 最大流。<br>匹配问题<br>正确理解KM算法是很重要的<br>这里我还要说几句：最正确解最小权匹配的办法是用一个很大的数-当前边权值，而不是直接对边权取反(这样只能处理左右点相等的完全二分图，即K(n, n)<br>以上有可能还是说的有点问题，以后补充<br>POJ 1486 – Sorting Slides(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1486" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1486</a><br>题意：二分图的必须边<br>解法：需正真理解最大匹配算法，详见<a href="http://hi.baidu.com/kevin0602/blog/item/1d5be63b5bec9bec14cecb44.html" target="_blank" rel="external">http://hi.baidu.com/kevin0602/blog/item/1d5be63b5bec9bec14cecb44.html</a><br>POJ 1904 – King’s Quest(中等，好题)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1904" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1904</a><br>题意：求二分图所有可能的匹配边<br>解法：虽然最终不是用匹配算法，但需要理解匹配的思想转换成强连通分量问题。<br>POJ 2060 -Taxi Cab Scheme(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2060" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2060</a><br>题意：最小路径覆盖<br>POJ 2594 -Treasure Exploration(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2594" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2594</a><br>题意：可相交最小路径覆盖<br>解法：先传递闭包转化下<br>POJ 3041 – Asteroids(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3041" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3041</a><br>POJ 2226 – Muddy Fields(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2226" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2226</a><br>题意：行列的覆盖<br>解法：最小点集覆盖 = 最大匹配<br>POJ 2195 – Going Home(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2195" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2195</a><br>题意：最小权值匹配<br>解法：KM算法<br>POJ 2400 – Supervisor, Supervisee(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2400" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2400</a><br>题意：输出所有最小权匹配<br>解法：KM, 然后回溯解，汗，输入的两个矩阵居然是反过来的<br>POJ 2516 -Minimum Cost(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2516" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2516</a><br>题意：最小权值匹配或最小费用流<br>解法：拆点 + KM算法(只有正确的才能过)，费用流(ms错的可能也能过)<br>POJ 3686 – The Windy’s(较难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=3686" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=3686</a><br>题意：最小权值匹配<br>解法：拆点,然后尽管用KM算法去水吧，数据其实弱得不得了 O(50 </em> 50 * 2500) -&gt; 16ms<br>相关：<a href="http://hi.baidu.com/kevin0602/blog/item/2829dc01d7143b087bec2c97.html" target="_blank" rel="external">http://hi.baidu.com/kevin0602/blog/item/2829dc01d7143b087bec2c97.html</a><br>SPOJ 412 – K-path cover(较难)<br><a href="https://www.spoj.pl/problems/COVER/" target="_blank" rel="external">https://www.spoj.pl/problems/COVER/</a><br>题意：略<br>解法：很牛叉的一道匹配<br>相关：<a href="http://hi.baidu.com/roba/blog/item/c842fdfac10d24dcb48f31d7.html" target="_blank" rel="external">http://hi.baidu.com/roba/blog/item/c842fdfac10d24dcb48f31d7.html</a><br>SGU 206. Roads(较难)<br><a href="http://acm.sgu.ru/problem.php?c0&amp;problem=206" target="_blank" rel="external">http://acm.sgu.ru/problem.php?c0&amp;problem=206</a><br>解法：经典题目，也可以使用spoj 412那题的优化<br>NP问题<br>一般是搜索或dp解的<br>POJ 1419 – Graph Coloring(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1419" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1419</a><br>题意：图的着色<br>解法：搜索，可惜题目的数据真是太弱了<br>POJ 2989 – All Friends(难)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2989" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=2989</a><br>题意：极大团数量<br>解法：开始狂tle, 后来找了论文：Finding All Cliques of an Undirected Graph（Coen Bron &amp; Joep Kerboscht）<br>ZOJ 1492 – Maximum Clique(基础)<br><a href="http://acm.zju.edu.cn/show_problem.php?pid=1492" target="_blank" rel="external">http://acm.zju.edu.cn/show_problem.php?pid=1492</a><br>题意：图的最大团<br>解法：搜索，如果要求速度，可参考下相应论文<br>其他<br>不能成大类的<br>POJ 1470 – Closest Common Ancestors(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1470" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1470</a><br>题意：LCA问题<br>解法：tarjan或RMQ，另外输入很恶心<br>POJ 1985 – Cow Marathon(基础)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1985" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1985</a><br>题意：树上的最长路径<br>解法：dp<br>POJ 1986 – Distance Queries(中等)<br><a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1986" target="_blank" rel="external">http://acm.pku.edu.cn/JudgeOnline/problem?id=1986</a><br>题意：LCA<br>解法：tarjan或RMQ</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转自别的地方，先放着，激励自己去刷题<br>]]>
    
    </summary>
    
      <category term="Poj" scheme="https://github.com/sillyplus/tags/Poj/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Codeforces 358D Dima and Hares]]></title>
    <link href="https://github.com/sillyplus/2013/10/26/codeforces-358d-dima-and-hares/"/>
    <id>https://github.com/sillyplus/2013/10/26/codeforces-358d-dima-and-hares/</id>
    <published>2013-10-25T16:00:00.000Z</published>
    <updated>2015-10-19T11:26:37.000Z</updated>
    <content type="html"><![CDATA[<p>题目大意：Dima送给他女友N只兔子，编号1-n（n&lt;=3000）,当给兔子喂食时，它们会产生joy值，joy的取值有三种状态：<br>1.当前兔子左右两边都没有已经喂过的兔子；<br>2.当前兔子左右两边有且仅有一边有已经喂过的兔子；<br>3.当前兔子左右两边的兔子均已喂过。（编号1，n的兔子显然无法满足）<br>现给出每只兔子三种状态下的joy值，希望你帮助Dima的女友有Inna选择某种喂食顺序，使得总的joy值最大，仅输出最大的joy值。<br><a id="more"></a><br>这个问题可以采用动态规划的方法来解决，为什么呢？<br>注意到，每只兔子选取的joy值仅与它左右两边的兔子的状态有关，当前兔子的状态也仅影响到它左右两边的兔子（-.-||好吧，这是显然的)<br>我们用f[i]来表示前i只兔子喂完时的最大joy值，但是i的状态跟i+1有关，我们应该如何表示呢？这里有个我觉得很巧妙的办法，就是我们先假设出i+1的状态进行求解。因此，我们增加一维，用f[i][0]表示喂食第i只兔子时第i+1只兔子还没有喂过,f[i][1]表示喂食第i只兔子时第i+1只兔子已经喂过了，这样我们就能很容易从f[i][]跟f[i-1][]得出喂食i时 i-1, i+1,处于的状态了。自然的就得到状态转移方程。</p>
<p>状态转移：<br>f[i][0] = max(f[i-1][0]+a[i][1], f[i-1][1]+a[i][0])<br>f[i][1] = max(f[i-1][0]+a[i][2], f[i-1][1]+a[i][1])</p>
<p>显然最后的答案就是f[n][0]<br>复杂度应该是O(N)吧</p>
<p>总结：感觉这道题目还是很有趣的（对我这种傻×来说）。可说到底这还是一道水题，虽然比赛的时候我看到题目就想到了DP，但显然DP能力太弱了（真的是跪到不行T^T），没有想出来给怎么表示状态，然后我选择了放弃思考。。。（提醒自己：可以放弃治疗，决不能放弃思考。说不定就想出来了）果然是智商问题，外加做过的题太少。。。最后是看了liympanda大神的代码,然后理解出来上面那堆东西，能力有限，写得不好望见谅。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">3200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MN][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[MN][<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][<span class="number">2</span>]);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = a[<span class="number">0</span>][<span class="number">0</span>]; f[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            f[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (f[i - <span class="number">1</span>][k] + a[i][<span class="number">1</span> - k + j] &gt; f[i][j])</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][k] + a[i][<span class="number">1</span> - k + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = f[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>题目大意：Dima送给他女友N只兔子，编号1-n（n&lt;=3000）,当给兔子喂食时，它们会产生joy值，joy的取值有三种状态：<br>1.当前兔子左右两边都没有已经喂过的兔子；<br>2.当前兔子左右两边有且仅有一边有已经喂过的兔子；<br>3.当前兔子左右两边的兔子均已喂过。（编号1，n的兔子显然无法满足）<br>现给出每只兔子三种状态下的joy值，希望你帮助Dima的女友有Inna选择某种喂食顺序，使得总的joy值最大，仅输出最大的joy值。<br>]]>
    
    </summary>
    
      <category term="Codeforces" scheme="https://github.com/sillyplus/tags/Codeforces/"/>
    
      <category term="DP" scheme="https://github.com/sillyplus/tags/DP/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj P1405 节水问题加强版]]></title>
    <link href="https://github.com/sillyplus/2013/10/25/tyvj-p1405/"/>
    <id>https://github.com/sillyplus/2013/10/25/tyvj-p1405/</id>
    <published>2013-10-25T05:06:02.000Z</published>
    <updated>2015-10-19T11:26:30.000Z</updated>
    <content type="html"><![CDATA[<p>传送门：<a href="https://www.tyvj.cn/Problem_Show.aspx?id=1405" target="_blank" rel="external">题目</a><br>怎么说呢，水题一道，直接用小根堆解决<br>主要是想通过这道题学习C++STL里面heap的用法<br>最后还是没有纠结出来，然后发现手写也不会了，就在网上找了一段，挺简洁的，以后就用这个做模板<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MN = <span class="number">100100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[MN * <span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[MN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span> (p = ++s; p &gt; <span class="number">1</span> &amp;&amp; f[p &gt;&gt; <span class="number">1</span>] &gt; x; f[p] = f[p &gt;&gt; <span class="number">1</span>], p &gt;&gt;= <span class="number">1</span>);</span><br><span class="line">    f[p] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, c, tp;</span><br><span class="line">    <span class="keyword">for</span> (tp=f[p=<span class="number">1</span>],c=<span class="number">2</span>;c&lt;s&amp;&amp;(f[c+=(c+<span class="number">1</span>&lt;s&amp;&amp;f[c + <span class="number">1</span>]&lt;f[c])?<span class="number">1</span>:<span class="number">0</span>]&lt;f[s]);f[p]=f[c],p=c,c&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    f[p] = f[s--];</span><br><span class="line">    <span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) push(w[i] + pop());</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) mx = max(mx, pop());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>传送门：<a href="https://www.tyvj.cn/Problem_Show.aspx?id=1405">题目</a><br>怎么说呢，水题一道，直接用小根堆解决<br>主要是想通过这道题学习C++STL里面heap的用法<br>最后还是没有纠结出来，然后发现手写也不会了，就在网上找了一段，挺简洁的，以后就用这个做模板<br>]]>
    
    </summary>
    
      <category term="Heap" scheme="https://github.com/sillyplus/tags/Heap/"/>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++指针备忘]]></title>
    <link href="https://github.com/sillyplus/2013/06/30/cpp-pointer/"/>
    <id>https://github.com/sillyplus/2013/06/30/cpp-pointer/</id>
    <published>2013-06-29T16:53:50.000Z</published>
    <updated>2015-05-19T03:23:37.000Z</updated>
    <content type="html"><![CDATA[<p>摘录自 C++ Primer Plus</p>
<p><strong>指针的危险</strong></p>
<p>一定要在对指针应用解除引用操作符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于是使用指针的金科玉律。</p>
<p>如下代码：</p>
<p>long * fellow;                 //create a pointer-to-long</p>
<p>*fellow = 223323;       //place a value in never-never land</p>
<p>fellow确实是一个指针，但它指向哪里呢？上述代码没有将地址赋给fellow。那么223323将会被放在哪里呢？我们不知道。由于fellow 没有被初始化，它可能有任何值。不管是什么，程序都将把它解释为储存223323的地址。如果fellow的值碰巧为1200，计算机将把数据放在地址1200上，即使这恰巧是程序代码的地址。fellow指向的地方很可能并不是要存储223323的地方。这种错误可能会导致一些最隐匿、最难以跟踪的bug。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘录自 C++ Primer Plus</p>
<p><strong>指针的危险</strong></p>
<p>一定要在对指针应用解除引用操作符（*）之前，将指针初始化为一个确定的、适当的地址。这是关于是使用指针的金科玉律。</p>
<p>如下代码：</p>
<p>lon]]>
    </summary>
    
      <category term="Cpp" scheme="https://github.com/sillyplus/tags/Cpp/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态内存分配]]></title>
    <link href="https://github.com/sillyplus/2013/06/29/dynamic-memory-allocation/"/>
    <id>https://github.com/sillyplus/2013/06/29/dynamic-memory-allocation/</id>
    <published>2013-06-29T05:43:18.000Z</published>
    <updated>2015-10-19T11:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>摘自Matrix67 C语言速成手册</p>
<p>四种动态内存分配函数，使用它们前需要在程序最前面包含头文件stdlib.h（C++应该是cstdlib）。四种函数的格式分别为：</p>
<p>void <em>malloc ( size );<br>void </em>calloc ( n, size );<br>void free ( pointer );<br>void *realloc( pointer, size );<br><a id="more"></a><br>函数malloc 将在内存里寻找一个大小为size 的连续空间，把分配到的内存地址作为一个指向void 类型的指针（默认的无类型指针）返回。如果空间分配失败，函数返回NULL。</p>
<p>函数calloc 将在内存里寻找一个大小为n * size 的连续空间，并且把这段内存的数据全部清0，返回数据和malloc 一样。如果空间分配失败，函数返回NULL。</p>
<p>函数free 用于释放内存空间，释放后的空间被回收，可以用于以后的malloc 或calloc 操作。</p>
<p>函数realloc 在保证已有数据不变的情况下改变已有指针的空间大小，返回重新分得的空间的内存地址（有可能和原来不同）。如果空间重新分配失败，函数返回NULL。</p>
<p>Pascal 中的new 语句可以用前两个函数代替，free 语句则相当于Pascal 中的dispose。</p>
<p>注意，malloc 和calloc 函数所返回的指针还没确定类型，理论上需要用类型转换。下面的程序合法地为p指针分配空间：</p>
<p>int<em>p;<br>p = (int </em>) malloc( sizeof(int) );<br>*p = 520;</p>
<p>事实上，由于赋值时C 语言自动转换类型，因此那个类型转换是没有必要的（去掉(int *)没有影响）。</p>
<p>本人在用codeblocks时，发现去掉（int*）编译不过，maybe是版本问题吧……</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>摘自Matrix67 C语言速成手册</p>
<p>四种动态内存分配函数，使用它们前需要在程序最前面包含头文件stdlib.h（C++应该是cstdlib）。四种函数的格式分别为：</p>
<p>void <em>malloc ( size );<br>void </em>calloc ( n, size );<br>void free ( pointer );<br>void *realloc( pointer, size );<br>]]>
    
    </summary>
    
      <category term="Cpp" scheme="https://github.com/sillyplus/tags/Cpp/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[分块思想学习]]></title>
    <link href="https://github.com/sillyplus/2013/06/17/think-with-piece/"/>
    <id>https://github.com/sillyplus/2013/06/17/think-with-piece/</id>
    <published>2013-06-16T20:00:07.000Z</published>
    <updated>2015-10-19T11:26:06.000Z</updated>
    <content type="html"><![CDATA[<p>早上看了一下七中王迪大神写的一篇论文，学习了一下分块思想，只看了一点点，基本上是看着代码，再自己脑补的。</p>
<p>所谓分块就是把规模为n的问题分割成k块，每块规模为s，为了使对块内和整个范围的操作的复杂度平均些，令k = s = √n。利用这个思想就能把O(n)的复杂度降到O(√n),从而达到优化算法的目的。论文中如是说。</p>
<p>只看了一个简单的问题，如有一长度为n的正整数数列，完成m次操作（1≤n，m≤10 ˆ5<em>），M x y:把第x个数字修改为y；Q x y：询问区间 [x,y] 中的最大值Max。</em></p>
<p>这个问题相当经典，有多种算法可解，因为在学分块，自然采用块状解决之。<br><a id="more"></a><br>我补充完整的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100100</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">100100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,m,t,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    s = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    t = (n + s - <span class="number">1</span>) / s;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">         <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            modify(x-<span class="number">1</span>,y);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query(x-<span class="number">1</span>,y-<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lb = (x / s) * s, rb = min(n, lb + s) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == rb) b[x] = a[x], x--;</span><br><span class="line">    <span class="keyword">for</span> (;x &gt;= lb; x--) b[x] = max(b[x+<span class="number">1</span>], a[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++)</span><br><span class="line">        maintain(min(n, i * s) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    a[x] = y;</span><br><span class="line">    maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x_pos = x / s, y_pos = y / s;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x_pos == y_pos) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x;i &lt;= y; i++)</span><br><span class="line">            ret = max(ret, a[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = b[x];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x_pos + <span class="number">1</span>; i &lt; y_pos; i++)</span><br><span class="line">            ret = max(ret,b[i * s]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = y_pos * s; i &lt;= y; i++)</span><br><span class="line">            ret = max(ret, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>早上看了一下七中王迪大神写的一篇论文，学习了一下分块思想，只看了一点点，基本上是看着代码，再自己脑补的。</p>
<p>所谓分块就是把规模为n的问题分割成k块，每块规模为s，为了使对块内和整个范围的操作的复杂度平均些，令k = s = √n。利用这个思想就能把O(n)的复杂度降到O(√n),从而达到优化算法的目的。论文中如是说。</p>
<p>只看了一个简单的问题，如有一长度为n的正整数数列，完成m次操作（1≤n，m≤10 ˆ5<em>），M x y:把第x个数字修改为y；Q x y：询问区间 [x,y] 中的最大值Max。</em></p>
<p>这个问题相当经典，有多种算法可解，因为在学分块，自然采用块状解决之。<br>]]>
    
    </summary>
    
      <category term="块状数组" scheme="https://github.com/sillyplus/tags/%E5%9D%97%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="技术" scheme="https://github.com/sillyplus/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tyvj P1565 Warcraft III 守望者的烦恼]]></title>
    <link href="https://github.com/sillyplus/2013/06/12/tyvj-p1565-warcraft-III/"/>
    <id>https://github.com/sillyplus/2013/06/12/tyvj-p1565-warcraft-III/</id>
    <published>2013-06-12T00:31:24.000Z</published>
    <updated>2015-10-19T11:26:00.000Z</updated>
    <content type="html"><![CDATA[<p>这道题显然有，矩阵乘法可解（由数据范围可得）</p>
<p>显然有题目要求: f[n]=∑f[i] (n-k&lt;i&lt;n-1),矩阵乘法相关知识自行google，推荐阅读<a href="http://www.matrix67.com/" target="_blank" rel="external">Matrix67</a>写的一篇文章。</p>
<p>所以构造有数组A(k*k):</p>
<p>000…1</p>
<p>100…1</p>
<p>010…1</p>
<p>001…1</p>
<p>因为看k&lt;10,我们可以先计算出f[1]~f[k],然后用矩阵乘法加速，计算出A^(n-k),最后再f*A^(n-k)乘一下就得出了。</p>
<p>我用的是递归式的矩阵二分取幂，后来才知道这样写会显得你很弱智……我也不知道为什么，然后就顺便再复习了一下，快速幂的非递归写法。<br><a id="more"></a><br>果断C++没学好，还是用pascal写的，这是这道题的代码：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr=<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">12</span>,-<span class="number">1</span>..<span class="number">12</span>] <span class="keyword">of</span> int64;</span><br><span class="line"><span class="keyword">const</span> md=<span class="number">7777777</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  k,i,j:longint;</span><br><span class="line">  n,ans:int64;</span><br><span class="line">  t,q:arr;</span><br><span class="line">  f:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">12</span>] <span class="keyword">of</span> int64;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span><span class="params">(a,b:arr)</span>:</span>arr;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  c:arr;</span><br><span class="line">  i,j,p:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  fillchar(c,sizeof(c),<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">for</span> p:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">        c[i,j]:=(c[i,j]+(a[i,p]*b[p,j] <span class="keyword">mod</span> md)) <span class="keyword">mod</span> md;</span><br><span class="line">  <span class="keyword">exit</span>(c);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dv</span><span class="params">(x:int64)</span>:</span>arr;</span><br><span class="line"><span class="keyword">var</span> tp:arr;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> x=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">exit</span>(t);</span><br><span class="line">  tp:=dv(x <span class="keyword">div</span> <span class="number">2</span>);</span><br><span class="line">  tp:=mul(tp,tp);</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">mod</span> <span class="number">2</span>)&lt;&gt;<span class="number">0</span> <span class="keyword">then</span> tp:=mul(tp,t);</span><br><span class="line">  <span class="keyword">exit</span>(tp);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  readln(k); readln(n);</span><br><span class="line">  fillchar(t,sizeof(t),<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k-<span class="number">1</span> <span class="keyword">do</span> t[i+<span class="number">1</span>,i]:=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> t[i,k]:=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span> f[i]:=<span class="number">0</span>; f[<span class="number">0</span>]:=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">0</span> <span class="keyword">to</span> i-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">      f[i]:=f[i]+f[j];</span><br><span class="line">  <span class="keyword">if</span> n&lt;=k <span class="keyword">then</span> <span class="keyword">begin</span> writeln(f[n]); halt; <span class="keyword">end</span>;</span><br><span class="line">  q:=dv(n-k); ans:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> k <span class="keyword">do</span></span><br><span class="line">    ans:=(ans+(f[i]*q[i,k] <span class="keyword">mod</span> md)) <span class="keyword">mod</span> md;</span><br><span class="line">  writeln(ans);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这道题显然有，矩阵乘法可解（由数据范围可得）</p>
<p>显然有题目要求: f[n]=∑f[i] (n-k&lt;i&lt;n-1),矩阵乘法相关知识自行google，推荐阅读<a href="http://www.matrix67.com/">Matrix67</a>写的一篇文章。</p>
<p>所以构造有数组A(k*k):</p>
<p>000…1</p>
<p>100…1</p>
<p>010…1</p>
<p>001…1</p>
<p>因为看k&lt;10,我们可以先计算出f[1]~f[k],然后用矩阵乘法加速，计算出A^(n-k),最后再f*A^(n-k)乘一下就得出了。</p>
<p>我用的是递归式的矩阵二分取幂，后来才知道这样写会显得你很弱智……我也不知道为什么，然后就顺便再复习了一下，快速幂的非递归写法。<br>]]>
    
    </summary>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在高考前]]></title>
    <link href="https://github.com/sillyplus/2013/06/04/writed-before-cee/"/>
    <id>https://github.com/sillyplus/2013/06/04/writed-before-cee/</id>
    <published>2013-06-03T18:35:56.000Z</published>
    <updated>2015-10-19T11:25:39.000Z</updated>
    <content type="html"><![CDATA[<p>保送生的颓废生活……就快完结，可惜这并不是我想要的生活。<br>本来回家是为了学习，可如今C++还没学好，日子就快结束了。整天被传召回学校，一个早上就轻松地没了……<br>因为承诺过会去高考，所以剩下这两天是否要复习呢，本来决定要的，可又彷徨了<br>踏进六月，终于能上网了，可还是没能认真学习，感觉还是先过完高考这关再说吧，虽然现在对高考没什么感觉，我总是太在乎别人的感受了吗。<br>混乱的语言，也正表明我现在的心境。也许是最近没有好好感受算法的魅力了吧，在题库闲逛，想code时却才发现自己的语言还没学好……，pascal又在本能上抑制去使用它。<br>算了，明后两天复习下，再考两天试，就不用管了。<br>还有我的足球赛啊，好想参加啊……我应该去写份计划表吗，感觉自制力不行写了也没用对吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>保送生的颓废生活……就快完结，可惜这并不是我想要的生活。<br>本来回家是为了学习，可如今C++还没学好，日子就快结束了。整天被传召回学校，一个早上就轻松地没了……<br>因为承诺过会去高考，所以剩下这两天是否要复习呢，本来决定要的，可又彷徨了<br>踏进六月，终于能上网了]]>
    </summary>
    
      <category term="杂记" scheme="https://github.com/sillyplus/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我的第一个C++程序~~]]></title>
    <link href="https://github.com/sillyplus/2013/05/08/my-first-cpp-program/"/>
    <id>https://github.com/sillyplus/2013/05/08/my-first-cpp-program/</id>
    <published>2013-05-07T21:28:16.000Z</published>
    <updated>2015-10-19T10:56:09.000Z</updated>
    <content type="html"><![CDATA[<p>嘛~回家了……</p>
<p>开始学习下C++咯，刚才乱搞，居然会用code::blocks了……</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!!!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于现在还不能整天上网，博客只能慢慢改了，效果不好请吐槽（虽然没人会看到我的blog……）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>嘛~回家了……</p>
<p>开始学习下C++咯，刚才乱搞，居然会用code::blocks了……</p>
<p>上代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span ]]>
    </summary>
    
      <category term="Cpp" scheme="https://github.com/sillyplus/tags/Cpp/"/>
    
      <category term="杂记" scheme="https://github.com/sillyplus/categories/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TYVJ 打鼹鼠 二维树状数组]]></title>
    <link href="https://github.com/sillyplus/2012/08/25/tyvj-p1474/"/>
    <id>https://github.com/sillyplus/2012/08/25/tyvj-p1474/</id>
    <published>2012-08-25T00:39:48.000Z</published>
    <updated>2015-10-28T01:21:27.000Z</updated>
    <content type="html"><![CDATA[<p>☆打鼹鼠<br>SuperBrother在机房里闲着没事干(再对比一下他的NOIP,真是讽刺啊……),于是便无聊地开始玩“打鼹鼠”……<br>描述 Description<br>在这个“打鼹鼠”的游戏中，鼹鼠会不时地从洞中钻出来，不过不会从洞口钻进去（鼹鼠真胆大……）。洞口都在一个大小为n(n&lt;=1024)的正 方形中。这个正方形在一个平面直角坐标系中，左下角为(0,0)，右上角为(n-1,n-1)。洞口所在的位置都是整点，就是横纵坐标都为整数的点。而 SuperBrother也不时地会想知道某一个范围的鼹鼠总数。这就是你的任务。<br><a id="more"></a><br>输入格式 Input Format<br>每个输入文件有多行。<br>第一行，一个数n，表示鼹鼠的范围。<br>以后每一行开头都有一个数m，表示不同的操作：<br>m=1，那么后面跟着3个数x,y,k(0&lt;=x,y&lt;n)，表示在点(x,y)处新出现了k只鼹鼠；<br>m=2，那么后面跟着4个数x1,y1,x2,y2(0&lt;=x1&lt;=x2&lt;n,0&lt;=y1&lt;=y2&lt;n)，表示询问矩形(x1,y1)-(x2,y2)内的鼹鼠数量；<br>m=3，表示老师来了，不能玩了。保证这个数会在输入的最后一行。<br>询问数不会超过10000，鼹鼠数不会超过maxlongint。<br>对于每个m=2，输出一行数，这行数只有一个数，即所询问的区域内鼹鼠的个数。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">  n,m,x1,y1,x2,y2,x,y,k,s:longint;</span><br><span class="line">  t:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">1024</span>,-<span class="number">1</span>..<span class="number">1024</span>] <span class="keyword">of</span> longint;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lowbit</span><span class="params">(i:longint)</span>:</span>longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  lowbit:=i <span class="keyword">and</span> (i <span class="keyword">xor</span> (i-<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">change</span><span class="params">(i,jj,k:longint)</span>;</span></span><br><span class="line"><span class="keyword">var</span> j:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">while</span> i&lt;=n <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">     j:=jj;   <span class="comment">//就是这里啊  少了这一句</span></span><br><span class="line">     <span class="keyword">while</span> j&lt;=n <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        t[i,j]:=t[i,j]+k;</span><br><span class="line">        j:=j+lowbit(j);</span><br><span class="line">      <span class="keyword">end</span>;</span><br><span class="line">     i:=i+lowbit(i)</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(i,jj:longint)</span>:</span>longint;</span><br><span class="line"><span class="keyword">var</span> sum,j:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sum:=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> i&gt;<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">     j:=jj;</span><br><span class="line">     <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        sum:=sum+t[i,j];</span><br><span class="line">        j:=j-lowbit(j);</span><br><span class="line">      <span class="keyword">end</span>;</span><br><span class="line">     i:=i-lowbit(i)</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line">  <span class="keyword">exit</span>(sum);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  readln(n);</span><br><span class="line">  fillchar(t,sizeof(t),<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">begin</span></span><br><span class="line">     <span class="keyword">read</span>(m);</span><br><span class="line">     <span class="keyword">if</span> m=<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        readln(x,y,k);</span><br><span class="line">        change(x+<span class="number">1</span>,y+<span class="number">1</span>,k);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> m=<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        readln(x1,y1,x2,y2);</span><br><span class="line">        s:=find(x2+<span class="number">1</span>,y2+<span class="number">1</span>)+find(x1,y1)-find(x1,y2+<span class="number">1</span>)-find(x2+<span class="number">1</span>,y1);</span><br><span class="line">        writeln(s);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">else</span> halt;</span><br><span class="line">   <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>☆打鼹鼠<br>SuperBrother在机房里闲着没事干(再对比一下他的NOIP,真是讽刺啊……),于是便无聊地开始玩“打鼹鼠”……<br>描述 Description<br>在这个“打鼹鼠”的游戏中，鼹鼠会不时地从洞中钻出来，不过不会从洞口钻进去（鼹鼠真胆大……）。洞口都在一个大小为n(n&lt;=1024)的正 方形中。这个正方形在一个平面直角坐标系中，左下角为(0,0)，右上角为(n-1,n-1)。洞口所在的位置都是整点，就是横纵坐标都为整数的点。而 SuperBrother也不时地会想知道某一个范围的鼹鼠总数。这就是你的任务。<br>]]>
    
    </summary>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="树状数组" scheme="https://github.com/sillyplus/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TYVJ 忠诚2 线段树]]></title>
    <link href="https://github.com/sillyplus/2012/08/25/tyvj-p1039/"/>
    <id>https://github.com/sillyplus/2012/08/25/tyvj-p1039/</id>
    <published>2012-08-24T23:03:59.000Z</published>
    <updated>2015-10-26T06:51:23.000Z</updated>
    <content type="html"><![CDATA[<p>忠诚2<br>描述 Description<br>老管家是一个聪明能干的人。他为财主工作了整整10年，财主为了让自已账目更加清楚。要求管家每天记k次账，由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按1，2，3…编号，然后不定时的问管家问题，问题是这样的：在a到b号账中最少的一笔是多少？为了让管家没时间作假他总是一次问多个问题。<br>在询问过程中账本的内容可能会被修改<br>输入格式 Input Format<br>输入中第一行有两个数m,n表示有m(m&lt;=100000)笔账,n表示有n个问题，n&lt;=100000。<br>接下来每行为3个数字，第一个p为数字1或数字2，第二个数为x，第三个数为y<br>当p=1 则查询x,y区间<br>当p=2 则改变第x个数为y</p>
<a id="more"></a>
<p>输出格式 Output Format<br>输出文件中为每个问题的答案。具体查看样例。<br>典型的线段树。只能说我是蒟蒻，只能做做这种题。第一次写线段树，写的不好请多包涵。</p>
<p>话说一开始时T数组只开到200000，结果就悲剧了，后来想着就算不过，也把忠诚1给提了，还是一样有两个点没过。<br>最后抱着试一试的态度，随便把数组改大，结果就过了。还是那个结论，蒟蒻啊，对数据范围的估计的能力都没有啊。<br>废话说完了。还是上代码吧。希望对一些有需要的同学有帮助。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uses</span> math;</span><br><span class="line"><span class="keyword">type</span></span><br><span class="line">tr=<span class="keyword">record</span></span><br><span class="line">　　 a,b,mi:longint;</span><br><span class="line">　  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">　　n,m,i,k,x,y,j:longint;</span><br><span class="line">　　t:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">800000</span>] <span class="keyword">of</span> tr;</span><br><span class="line">　　a,s:<span class="keyword">array</span>[-<span class="number">1</span>..<span class="number">200000</span>] <span class="keyword">of</span> longint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">build</span><span class="params">(p,l,r:longint)</span>;</span></span><br><span class="line"><span class="keyword">var</span> mid:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">　mid:=(l+r) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">　t[p].a:=l; t[p].b:=r;</span><br><span class="line">　<span class="keyword">if</span> l&lt;&gt;r <span class="keyword">then</span></span><br><span class="line">　　<span class="keyword">begin</span></span><br><span class="line">　　　build(<span class="number">2</span>*p,l,mid);</span><br><span class="line">　　　build(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">　　　t[p].mi:=min(t[<span class="number">2</span>*p].mi,t[<span class="number">2</span>*p+<span class="number">1</span>].mi);</span><br><span class="line">　　<span class="keyword">end</span> <span class="keyword">else</span></span><br><span class="line">　　<span class="keyword">begin</span></span><br><span class="line">　　　t[p].mi:=a[l];</span><br><span class="line">　　　s[l]:=p;</span><br><span class="line">　　<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">change</span><span class="params">(x,y:longint)</span>;</span><span class="comment">//把这个去掉，改一下输入就可以过忠诚1了</span></span><br><span class="line"><span class="keyword">var</span> ss:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">　ss:=s[x];</span><br><span class="line">　t[ss].mi:=y;</span><br><span class="line">　<span class="keyword">while</span> ss&gt;<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">　　<span class="keyword">begin</span></span><br><span class="line">　　　ss:=ss <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">　　　t[ss].mi:=min(t[<span class="number">2</span>*ss].mi,t[<span class="number">2</span>*ss+<span class="number">1</span>].mi);</span><br><span class="line">　　<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span><span class="params">(p,l,r:longint)</span>:</span>longint;</span><br><span class="line"><span class="keyword">var</span> mid:longint;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">　mid:=(t[p].a+t[p].b) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">　<span class="keyword">if</span> (t[p].a=l) <span class="keyword">and</span> (t[p].b=r) <span class="keyword">then</span> <span class="keyword">exit</span>(t[p].mi)</span><br><span class="line">　<span class="keyword">else</span> <span class="keyword">if</span> r&lt;=mid <span class="keyword">then</span> <span class="keyword">exit</span>(find(<span class="number">2</span>*p,l,r))</span><br><span class="line">　　<span class="keyword">else</span> <span class="keyword">if</span> l&gt;=mid+<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">exit</span>(find(<span class="number">2</span>*p+<span class="number">1</span>,l,r))</span><br><span class="line">　　　<span class="keyword">else</span> <span class="keyword">exit</span>(min(find(<span class="number">2</span>*p,l,mid),find(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,r)));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">　readln(m,n);</span><br><span class="line">　<span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> m <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);</span><br><span class="line">　build(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">　<span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">　　<span class="keyword">begin</span></span><br><span class="line">　　　<span class="keyword">read</span>(k,x,y);</span><br><span class="line">　　　<span class="keyword">if</span> k=<span class="number">1</span> <span class="keyword">then</span> <span class="keyword">write</span>(find(<span class="number">1</span>,x,y),<span class="string">' '</span>)</span><br><span class="line">　　　<span class="keyword">else</span></span><br><span class="line">　　　change(x,y);</span><br><span class="line">　　<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>忠诚2<br>描述 Description<br>老管家是一个聪明能干的人。他为财主工作了整整10年，财主为了让自已账目更加清楚。要求管家每天记k次账，由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按1，2，3…编号，然后不定时的问管家问题，问题是这样的：在a到b号账中最少的一笔是多少？为了让管家没时间作假他总是一次问多个问题。<br>在询问过程中账本的内容可能会被修改<br>输入格式 Input Format<br>输入中第一行有两个数m,n表示有m(m&lt;=100000)笔账,n表示有n个问题，n&lt;=100000。<br>接下来每行为3个数字，第一个p为数字1或数字2，第二个数为x，第三个数为y<br>当p=1 则查询x,y区间<br>当p=2 则改变第x个数为y</p>]]>
    
    </summary>
    
      <category term="Tyvj" scheme="https://github.com/sillyplus/tags/Tyvj/"/>
    
      <category term="线段树" scheme="https://github.com/sillyplus/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="题解" scheme="https://github.com/sillyplus/categories/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[模版]]></title>
    <link href="https://github.com/sillyplus/1970/01/01/1970-1-1-templates/"/>
    <id>https://github.com/sillyplus/1970/01/01/1970-1-1-templates/</id>
    <published>1969-12-31T16:00:00.000Z</published>
    <updated>2015-10-28T01:31:35.000Z</updated>
    <content type="html"><![CDATA[<p>这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。</p>
<!-- toc -->
<h3 id="树链剖分">树链剖分</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一颗树,将它划分成若干条互不相交的路径,满足:从节点u-&gt;v最多经过logN条路径以及logN条不在路径上的边.</span><br><span class="line">*</span><br><span class="line">*我们使用以下几个数组来描述剖分出来的路径:</span><br><span class="line">*Bolong<span class="comment">[v]</span> 		节点v所属的路径编号</span><br><span class="line">*Idx<span class="comment">[v]</span>			节点v在其路径中的编号,节点按深度由深到浅依次标号</span><br><span class="line">*Head<span class="comment">[p]</span>		编号为p的路径的顶端节点</span><br><span class="line">*Len<span class="comment">[p]</span> 		路径p的长度</span><br><span class="line">*Dep<span class="comment">[v]</span>			节点v的深度</span><br><span class="line">*Father<span class="comment">[v]</span>		节点v的父亲节点</span><br><span class="line">*Size<span class="comment">[v]</span>		以节点v为根的子树的节点个数</span><br><span class="line">*划分操作采用BFS以避免栈空间溢出.按照BFS的发现顺序逆序处理,对于每一个节点v,找到它的size最大的子节点u.如果u不存在,</span><br><span class="line">*那么给v分配一条新的路径,否则v就延续u所属的路径.</span><br><span class="line">*查询两个节点u,v之间的路径时,首先判断它们是否属于同一条路径.如果是则直接在这条路经上查询并返回,否则选择所属路径顶端</span><br><span class="line">*节点h的深度较大的节点(不妨设是v),查询v到h,并令v=father<span class="comment">[h]</span>继续查询,直到u,v属于同一条路径.</span><br><span class="line">*</span><br><span class="line">*void insert(int x, int y);</span><br><span class="line">*输入:		x,y			添加一条x到y的边</span><br><span class="line">*void split();</span><br><span class="line">*复杂度:		O(nlogn)</span><br><span class="line">*输入:		Prev		Prev<span class="comment">[i]</span>表示邻接表中,第i条边在链表中的下一条边</span><br><span class="line">*			info		info<span class="comment">[v]</span>表示邻接表中,从点v出发的边链表的头节点</span><br><span class="line">*输出:		Belong		Belong<span class="comment">[v]</span>表示节点v所属的路径编号</span><br><span class="line">*			Idx			Idx<span class="comment">[v]</span>表示节点v在其路径中的编号,按深度由深到浅依次标号</span><br><span class="line">*			Head		Head<span class="comment">[p]</span>表示编号为p的路径的顶端节点</span><br><span class="line">*			Len			Len<span class="comment">[p]</span>表示路径p的长度</span><br><span class="line">*			Dep			Dep<span class="comment">[v]</span>表示节点v的深度</span><br><span class="line">*			Father		Father<span class="comment">[v]</span>表示节点v的父亲节点</span><br><span class="line">*			Size		Size<span class="comment">[v]</span>表示以节点v为根的子树的节点个数</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const int maxn = 100000 + 5;</span><br><span class="line">const int maxm = maxn + maxn;</span><br><span class="line">int v<span class="comment">[maxm]</span>;</span><br><span class="line">int Prev<span class="comment">[maxm]</span>;</span><br><span class="line">int info<span class="comment">[maxn]</span>;</span><br><span class="line">int Q<span class="comment">[maxn]</span>;</span><br><span class="line">int idx<span class="comment">[maxn]</span>;</span><br><span class="line">int dep<span class="comment">[maxn]</span>;</span><br><span class="line">int size<span class="comment">[maxn]</span>;</span><br><span class="line">int belong<span class="comment">[maxn]</span>;</span><br><span class="line">int father<span class="comment">[maxn]</span>;</span><br><span class="line">bool vis<span class="comment">[maxn]</span>;</span><br><span class="line">int head<span class="comment">[maxn]</span>;</span><br><span class="line">int len<span class="comment">[maxn]</span>;</span><br><span class="line">int l, r, ans, cnt = 0;</span><br><span class="line">int N, nedge = 0;</span><br><span class="line"></span><br><span class="line">inline void insert(int x, int y) &#123;</span><br><span class="line">    nedge++;</span><br><span class="line">    v<span class="comment">[nedge]</span> = y;</span><br><span class="line">    Prev<span class="comment">[nedge]</span> = info<span class="comment">[x]</span>;</span><br><span class="line">    info<span class="comment">[x]</span> = nedge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void split() &#123;</span><br><span class="line">    memset(dep, -1, sizeof(dep));</span><br><span class="line">    l = 0;</span><br><span class="line">    dep<span class="comment">[ Q<span class="comment">[ r=1 ]</span> =1 ]</span>=0;</span><br><span class="line">    father<span class="comment">[1]</span> = -1;</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        int x = Q<span class="comment">[++l]</span>;</span><br><span class="line">        vis<span class="comment">[x]</span> = false;</span><br><span class="line">        for (int y = info<span class="comment">[x]</span>; y; y = Prev<span class="comment">[y]</span>)</span><br><span class="line">            if (dep<span class="comment">[v<span class="comment">[y]</span>]</span> == -1) &#123;</span><br><span class="line">                dep<span class="comment">[ Q<span class="comment">[++r]</span> = v<span class="comment">[y]</span> ]</span> = dep<span class="comment">[x]</span> = 1;</span><br><span class="line">                father<span class="comment">[v<span class="comment">[y]</span>]</span> = x;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = N; i; i--) &#123;</span><br><span class="line">        int x = Q<span class="comment">[i]</span>, p = -1;</span><br><span class="line">        size<span class="comment">[x]</span> = 1;</span><br><span class="line">        for (int y = info<span class="comment">[x]</span>; y; y = Prev<span class="comment">[y]</span>)</span><br><span class="line">            if (vis<span class="comment">[v<span class="comment">[y]</span>]</span>) &#123;</span><br><span class="line">                size<span class="comment">[x]</span> == size<span class="comment">[v<span class="comment">[y]</span>]</span>;</span><br><span class="line">                if (p == -1 || size<span class="comment">[v<span class="comment">[y]</span>]</span> &gt; size<span class="comment">[p]</span>)</span><br><span class="line">                    p = v<span class="comment">[y]</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        if (p == -1) &#123;</span><br><span class="line">            idx<span class="comment">[x]</span> = len<span class="comment">[++cnt]</span> = 1;</span><br><span class="line">            belong<span class="comment">[head<span class="comment">[cnt]</span> = x]</span> = cnt;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            idx<span class="comment">[x]</span> = ++len<span class="comment">[belong<span class="comment">[x]</span> = belong<span class="comment">[p]</span>]</span>;</span><br><span class="line">            head<span class="comment">[belong<span class="comment">[x]</span>]</span> = x;</span><br><span class="line">        &#125;</span><br><span class="line">        vis<span class="comment">[x]</span> = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用inset函数建图,然后点哟内split就可以完成剖分.点从1开始编号,并假设根节点是1.</span><br></pre></td></tr></table></figure>
<h3 id="ST表">ST表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一个数组A[n],动态查询数组元素A[l],A[l+1],...,A[r]的最小值。</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*我们首先使用O(nlogn)的时间预处理出数组st[<span class="link_label">i</span>][<span class="link_reference">j</span>],代表从A[i]开始连续2^j个元素中的最小值。</span><br><span class="line">*可以使用动态规划，状态转移方程如下:</span><br><span class="line"><span class="bullet">*    </span>边界条件为st[<span class="link_label">i</span>][<span class="link_reference">0</span>] = A[i]。</span><br><span class="line">*对于一个查询[L,R]，我们令k=floor(log(R-L+1))，那么[L,R]中的最小值就是</span><br><span class="line">*min(st[<span class="link_label">L</span>][<span class="link_reference">k</span>], st[<span class="link_label">R-2^i+1</span>][<span class="link_reference">k</span>])。</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span><span class="emphasis">*void st_prepare(int n, int *</span>array);</span><br><span class="line">*复杂度: O(nlogn)</span><br><span class="line">*输 入:  n        数组长度</span><br><span class="line"><span class="bullet">*       </span>array    数组</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int query_min(int l, int r);</span><br><span class="line">*复杂度: O(1)</span><br><span class="line">*输 入:  l,r    查询区间的两个端点</span><br><span class="line">*输 出:  A[l],A[l+1],...,A[r]的最小值</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*/</span><br><span class="line"></span><br><span class="line">const int MAX = 100000;</span><br><span class="line">int stTable[<span class="link_label">MAX</span>][<span class="link_reference">32</span>];</span><br><span class="line">int preLog2[MAX];</span><br><span class="line"></span><br><span class="line">void st_prepare(int n, int *array) &#123;</span><br><span class="line"><span class="code">    preLog2[1] = 0;</span></span><br><span class="line"><span class="code">    for (int i = 2; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="code">        preLog2[i] = preLog2[i-1];</span></span><br><span class="line"><span class="code">        if ((1 &lt;&lt; preLog2[i] + 1) == i) &#123;</span></span><br><span class="line"><span class="code">            ++preLog2[i];</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line"><span class="code">    for (int i = n-1; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="code">        stTable[i][0] = array[i];</span></span><br><span class="line"><span class="code">        for (int j = 1; (i + (1 &lt;&lt; j) - 1) &lt; n; j++) &#123;</span></span><br><span class="line"><span class="code">            stTable[i][j] = min(stTable[i][j-1], stTable[i+(1 &lt;&lt; j-1)][j-1]);</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query_min(int l, int r) &#123;</span><br><span class="line"><span class="code">    int len = r - l + 1, k = preLog2[len];</span></span><br><span class="line"><span class="code">    return min(stTable[l][k], stTable[r - (1 &lt;&lt; k) + 1][k]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA">SPFA</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*用SPFA算法求单源最短路.</span><br><span class="line">*</span><br><span class="line">*SPFA其实是Bellman-Ford的队列优化.我们用数组dist记录每个结点的最短路径估计值,并用邻接表</span><br><span class="line">*来存储图g.我们采用的方法是松弛:设立一个先进先出的队列用来保持优化的结点,优化时每次取出</span><br><span class="line">*队首结点u,并且用u点当前的最短路径估计值对u点所指向的结点v进行松弛操作,如果v点的最短</span><br><span class="line">*路径估计值有所调整,且v点不在当前队列中,就将v点放入队尾.这样不断从队列中取出结点来进行</span><br><span class="line">*松弛操作,直至队列空为止.</span><br><span class="line">*只要最短路存在,上述SPFA算法必定能求出最小值.因为每次将点放入队尾,都是经过松弛操作达到</span><br><span class="line">*的.换言之,每次的优化将会有某个点v的最短路径估计值d[v]变小.所以算法的执行会使d越来越小.</span><br><span class="line">*由于我们假定图中不存在负权回路,所以每个结点都有最短路径.因此,算法不会无限执行下去,随着</span><br><span class="line">*d值的逐渐变小,直到到达最短路径值时,算法结束,这时的最短路径估计值就是对应结点的最短路径</span><br><span class="line">*值.</span><br><span class="line">*</span><br><span class="line">*void spfa();</span><br><span class="line">*复杂度:	最坏情况O(|V|*|X|)</span><br><span class="line">*输  入:	n		全局变量,图的点数</span><br><span class="line">*			src		全局变量,表示源点</span><br><span class="line">*			g		全局变量,邻接表存储所有边</span><br><span class="line">*					g[i][j].first表示节点i的第j条边的节点编号</span><br><span class="line">*					g[i][j].second表示边的长度</span><br><span class="line">*输  出:	dist	全局变量,dist[i]表示源点src到i的最短距离</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int maxn = 1000;</span><br><span class="line"></span><br><span class="line">int <span class="keyword">n</span>, <span class="keyword">m</span>, src;</span><br><span class="line">vector&lt;pair&lt;int, int&gt; &gt; <span class="keyword">g</span>[maxn + 10];</span><br><span class="line"></span><br><span class="line">int dist[maxn + 10];</span><br><span class="line">bool inQue[maxn + 10];</span><br><span class="line">queue&lt;int&gt; <span class="keyword">que</span>;</span><br><span class="line"></span><br><span class="line">void spfa() &#123;</span><br><span class="line">	memset(dist, 63, sizeof(dist));</span><br><span class="line">	dist[src] = 0;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="keyword">que</span>.empty()) <span class="keyword">que</span>.pop();</span><br><span class="line">	<span class="keyword">que</span>.push(src);</span><br><span class="line">	inQue[src] = true;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="keyword">que</span>.empty()) &#123;</span><br><span class="line">		int <span class="keyword">u</span> = <span class="keyword">que</span>.front();</span><br><span class="line">		<span class="keyword">que</span>.pop();</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">g</span>[<span class="keyword">u</span>].size(); i++)</span><br><span class="line">			<span class="keyword">if</span> (dist[<span class="keyword">u</span>] + <span class="keyword">g</span>[<span class="keyword">u</span>][i].second &lt; dist[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first]) &#123;</span><br><span class="line">				dist[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first] = dist[<span class="keyword">u</span>] + <span class="keyword">g</span>[<span class="keyword">u</span>][i].second;</span><br><span class="line">				<span class="keyword">if</span> (!inQue[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first]) &#123;</span><br><span class="line">					inQue[<span class="keyword">g</span>[<span class="keyword">u</span>][i].first] = true;</span><br><span class="line">					<span class="keyword">que</span>.push(<span class="keyword">g</span>[<span class="keyword">u</span>][i].first);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		inQue[<span class="keyword">u</span>] = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序">拓扑排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*对一个有向无环图拓扑排序.</span><br><span class="line">*</span><br><span class="line">*用一个队列实现,先吧入度为0的点放入队列.然后考虑不断从图中删除队列中的点,每次删除</span><br><span class="line">*一个点会产生一些新的入度为0的点.把这些点插入队列.</span><br><span class="line">*</span><br><span class="line">*bool toposort();</span><br><span class="line">*复杂度: O(|V|+|E|)</span><br><span class="line">*输  入: n	全局变量,表示点数</span><br><span class="line">*        g	全局变量,g[i]表示从点i连出去的边</span><br><span class="line">*输  出: 返回对给定的图,是否可以拓扑排序</span><br><span class="line">*        L	全局变量,拓扑排序的结果</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn];</span><br><span class="line"><span class="keyword">int</span> du[maxn], n, m, L[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">toposort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(du, <span class="number">0</span>, <span class="keyword">sizeof</span>(du));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[i].size(); j++)</span><br><span class="line">			du[g[i][j]]++;</span><br><span class="line">	<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="keyword">if</span> (!du[i]) Q.push(i);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		L[tot++] = x;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; g[x].size(); j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = g[x][j];</span><br><span class="line">			du[t]--;</span><br><span class="line">			<span class="keyword">if</span> (!du[t])</span><br><span class="line">				Q.push(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (tot == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan">Tarjan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个有向图,找出图中的极大强联通分量,并将属于同一个强联通分量内的点染同样的颜色.</span><br><span class="line">*</span><br><span class="line">*dfn[i]记录的是节点i在深度优先遍历中的访问次序;</span><br><span class="line">*low[i]记录的是点i可以到达的访问时间最早的祖先;</span><br><span class="line">*Stack是记录节点的栈.</span><br><span class="line">*深度优先遍历整个图,一路上标记dfn并把新节点压入栈.对于一个节点i,如果它的dfn值与low值</span><br><span class="line">*相等,说明它无法到达它的任何一个祖先.而在栈里面i与i之后的点一定能够与i互达的(否则在</span><br><span class="line">*之前就会被弹出栈),所以i与栈里i之后的点形成了一个极大强联通分量.这一部分可以作为一个</span><br><span class="line">*整体弹出.</span><br><span class="line">*现在考虑low值的求法.这个可以根据定义来:如果点i访问一个新点j,那么j的low值i也一定能够</span><br><span class="line">*达到,可以用low[j]尝试更新low[i];如果点i访问一个祖先k,那么则直接用dfn[k]尝试更新low[i]</span><br><span class="line">*</span><br><span class="line">*strongly_connected_components(const vector&lt;pair&lt;int,int&gt; &gt; &amp;edgeList, int n, vector&lt;int&gt; &amp;ans);</span><br><span class="line">*复杂度:	O(|V|+|E|)</span><br><span class="line">*输  入:	&amp;edgList	图中所有的边,其中边用pair&lt;int, int&gt;表示</span><br><span class="line">*		  n  			图中点的数目</span><br><span class="line">*		  &amp;ans	  	染色结果</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> strongly_connected_components &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;color;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Stack;</span><br><span class="line">	<span class="keyword">int</span> colorCnt, curr, *instack, *dfn, *low, *info, *next, *to;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		dfn[x] = low[x] = ++curr;</span><br><span class="line">		Stack.push_back(x);</span><br><span class="line">		instack[x] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = info[x]; j; j = next[j])</span><br><span class="line">			<span class="keyword">if</span> (!instack[to[j]]) &#123;</span><br><span class="line">				dfs(to[j]);</span><br><span class="line">				low[x] = <span class="built_in">std</span>::min(low[x], low[to[j]]);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (instack[to[j]] == <span class="number">1</span>)</span><br><span class="line">					low[x] = <span class="built_in">std</span>::min(low[x], dfn[to[j]]);</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">			<span class="keyword">while</span> (Stack.back() != xs) &#123;</span><br><span class="line">				color[Stack.back()] = colorCnt;</span><br><span class="line">				instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">				Stack.pop_back();</span><br><span class="line">			&#125;</span><br><span class="line">			color[Stack.back()] = colorCnt++;</span><br><span class="line">			instack[Stack.back()] = <span class="number">2</span>;</span><br><span class="line">			Stack.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	strongly_connected_components(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &amp;edgeList,</span><br><span class="line">										<span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans): color(ans) &#123;</span><br><span class="line">		color.resize(n);</span><br><span class="line">		instack = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		dfn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		low = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		info = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		next = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edgeList.size() + <span class="number">5</span>];</span><br><span class="line">		to = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>)edgeList.size() + <span class="number">5</span>];</span><br><span class="line">		<span class="built_in">std</span>::fill_n(info, n, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edgeList.size(); i++) &#123;</span><br><span class="line">			to[i+<span class="number">1</span>] = edgeList[i].second;</span><br><span class="line">			next[i+<span class="number">1</span>] = info[edgeList[i].first];</span><br><span class="line">			info[edgeList[i].first] = i+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">std</span>::fill_n(instack, n, <span class="number">0</span>);</span><br><span class="line">		colorCnt = <span class="number">0</span>;</span><br><span class="line">		curr = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!instack[i]) &#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span>[] instack;</span><br><span class="line">		<span class="keyword">delete</span>[] dfn;</span><br><span class="line">		<span class="keyword">delete</span>[] low;</span><br><span class="line">		<span class="keyword">delete</span>[] info;</span><br><span class="line">		<span class="keyword">delete</span>[] next;</span><br><span class="line">		<span class="keyword">delete</span>[] to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Tire">Tire</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*设计一种数据结构,支持两种操作:插入一个字符串; 查询一个字符串是否存在.</span><br><span class="line">*</span><br><span class="line">*我们采用2个数组实现一个Trie树. child[i][j]代表以i为根的子树,字符j代表的边连向哪</span><br><span class="line">*一个节点(如果child[i][j] = 0, 则说明没有对应的节点).初始时根节点为1.flag[i]代表节点</span><br><span class="line">*i是否为一个单词的结尾.</span><br><span class="line">*插入时,我们从根节点沿着字符串的每个字符走向下一层节点,如果该节点不存在则分配一个</span><br><span class="line">*新节点.对于最后插入的节点i,我们令flag[i] = true.</span><br><span class="line">*查找和插入的过程基本相同,区别是:如果我们走到一个不存在的节点那么返回查找失败.</span><br><span class="line">*如果最后我们停留在某个节点i,那么返回flag[i]即可.</span><br><span class="line">*</span><br><span class="line">*结构体:	Trie</span><br><span class="line">*成员函数:</span><br><span class="line">*	void insert(cosnt char *str);	插入字符串str</span><br><span class="line">*	复杂度:		O(Length)</span><br><span class="line">*	bool query(const char *str):	查询字符串是否出现</span><br><span class="line">*	复杂度:		O(Length)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CHARSET为字符集的大小</span></span><br><span class="line"><span class="comment">//BASE为字符集ASCII最小字符</span></span><br><span class="line"><span class="comment">//MAX_NODE最大点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CHARSET = <span class="number">26</span>, BASE = <span class="string">'a'</span>, MAX_NODE = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">struct</span> Trie &#123;</span><br><span class="line">	<span class="keyword">int</span> tot, root, child[MAX_NODE][CHARSET];</span><br><span class="line">	<span class="keyword">bool</span> flag[MAX_NODE];</span><br><span class="line">	Trie() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(child[<span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(child[<span class="number">1</span>]));</span><br><span class="line">		flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">		root = tot = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *cur = &amp;root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = str; *p; p++) &#123;</span><br><span class="line">			cur = &amp;child[*cur][*p-BASE];</span><br><span class="line">			<span class="keyword">if</span> (*cur == <span class="number">0</span>) &#123;</span><br><span class="line">				*cur = ++tot;</span><br><span class="line">				<span class="built_in">memset</span>(child[tot], <span class="number">0</span>, <span class="keyword">sizeof</span>(child[tot]));</span><br><span class="line">				flag[tot] = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		flag[*cur] = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> *cur = &amp;root;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *p = str; *p &amp;&amp; *cur; p++)</span><br><span class="line">			cur = &amp;child[*cur][*p-BASE];</span><br><span class="line">		<span class="keyword">return</span> (*cur &amp;&amp; flag[*cur]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Dijkstra">Dijkstra</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*用Dijkstra算法求单源最短路.图中不能有负权的边.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*Dijkstra算法按从源点src到其他各点的最短路长度递增的顺序,依次确定src到每个点的最短路.</span><br><span class="line">*首先将dis[src]赋为0,其余各点赋为正无穷,此时所有点的最短路都还未确定.之后,每次在还未</span><br><span class="line">*确定最短路的点中,取一个当前已得的所有可能的路径长度中最短的那个点确定,设此点为mark.</span><br><span class="line">*然后对所有与mark相连的点进行松弛操作,即对于边(mark, v),判断dis[<span class="link_label">v</span>]是否大于dis[<span class="link_label">mark</span>]+g[<span class="link_label">mark</span>][<span class="link_reference">v</span>],</span><br><span class="line">*若是,则更新dis[<span class="link_label">v</span>]为dis[<span class="link_label">mark</span>]+g[<span class="link_label">mark</span>][<span class="link_reference">v</span>].如此做N遍后,即确定了src到所有N个点的最短距离.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*void dijksta();</span><br><span class="line">*复杂度:	O(N^2)</span><br><span class="line">*输  入:	N		全局变量,图中的点数</span><br><span class="line"><span class="bullet">*			</span>g		全局变量,g[<span class="link_label">i</span>][<span class="link_reference">j</span>]表示i到j之间边的距离</span><br><span class="line">*输  出:	dis		全局变量,dis[i]表示节点1到i的最短距离</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*/</span><br><span class="line"></span><br><span class="line">const int MN = 1000;</span><br><span class="line">int dis[<span class="link_label">MN</span>], g[<span class="link_label">MN</span>][<span class="link_reference">MN</span>], N;</span><br><span class="line">bool v[MN];</span><br><span class="line"></span><br><span class="line">void dijkstra() &#123;</span><br><span class="line"><span class="code">	for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line"><span class="code">		dis[i] = INF;</span></span><br><span class="line"><span class="code">	dis[1] = 0;</span></span><br><span class="line"><span class="code">	memset(v, 0, sizeof(v));</span></span><br><span class="line"><span class="code">	for (int i = 1; i &lt;= N; i++) &#123;</span></span><br><span class="line"><span class="code">		int mark = -1, mindis = INF;</span></span><br><span class="line"><span class="code">		for (int j = 1; j &lt;= N; j++)</span></span><br><span class="line"><span class="code">			if (!v[j] &amp;&amp; dis[j] &lt; mindis) &#123;</span></span><br><span class="line"><span class="code">				mindis = dis[j];</span></span><br><span class="line"><span class="code">				mark = j;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		v[mark] = 1;</span></span><br><span class="line"><span class="code">		for (int j = 1; j &lt;= N; j++)</span></span><br><span class="line"><span class="code">			if (!v[j])</span></span><br><span class="line"><span class="code">				dis[j] = min(dis[j], dis[mark] + g[mark][j]);</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Matching">Matching</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">    &gt; File Name: Matching.cpp</span><br><span class="line">    &gt; Author: sillyplus</span><br><span class="line">    &gt; Mail: oi_boy<span class="comment">@sina.cn</span></span><br><span class="line">    &gt; Created Time: Tue May 12 11:52:05 2015</span><br><span class="line"></span><br><span class="line">    给出一个无向图，求最大匹配。</span><br><span class="line"></span><br><span class="line">    不断在图中寻找路径增广，直到不存在增广路径。</span><br><span class="line"></span><br><span class="line">    在寻在路径的过程中，可能出现一个奇环，这时候把奇环收缩，成为一朵“花”，并在新图</span><br><span class="line">    上进行增广。可以发现，每一条增广路径都可以通过把“花”展开还原回去（因为一个奇环</span><br><span class="line">    的两段路径必然是一奇一偶，总能找到一段时满足的）。</span><br><span class="line"></span><br><span class="line">    void matching();</span><br><span class="line">    复杂度：    O(n^3)</span><br><span class="line">    输入：      n           全局变量，图的点数</span><br><span class="line">               a           全局变量，图的邻接矩阵</span><br><span class="line">    输出：      ans         全局变量，最大匹配数</span><br><span class="line">               match       全局变量，match[i]表示和i匹配的点</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>/</span><br><span class="line"></span><br><span class="line">const int MAXN = 222 + 10;</span><br><span class="line">int n, x, y, fore, rear, cnt, ans;</span><br><span class="line">int father[MAXN], f[MAXN], path[MAXN], tra[MAXN], que[MAXN], match[MAXN];</span><br><span class="line">bool a[MAXN][MAXN], check[MAXN], treec[MAXN], pathc[MAXN];</span><br><span class="line"></span><br><span class="line">inline void push(int x) &#123;</span><br><span class="line">    que[++rear] = x;</span><br><span class="line">    check[x] = true;</span><br><span class="line">    if (!treec[x]) &#123;</span><br><span class="line">        tra[++cnt] = x;</span><br><span class="line">        treec[x] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int root(int x) &#123;</span><br><span class="line">    return f[x] ? f[x] = root(f[x]) : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clear() &#123;</span><br><span class="line">    for (int i = 1, j; i <span class="variable">&lt;= cnt; ++i) &#123;</span><br><span class="line">        j = tra[i];</span><br><span class="line">        check[j] = treec[j] = false;</span><br><span class="line">        father[j] = 0, f[j] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int u, int v) &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    for (; u; u = father[match[u]]) &#123;</span><br><span class="line">        u = root(u);</span><br><span class="line">        path[++len] = u;</span><br><span class="line">        pathc[u] = true;</span><br><span class="line">    &#125;</span><br><span class="line">    for (;;v = father[match[v]]) &#123;</span><br><span class="line">        v = root(v);</span><br><span class="line">        if (pathc[v]) break;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt; len; ++i)</span><br><span class="line">        pathc[path[i]] = false;</span><br><span class="line">    return v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reset(int u, int p) &#123;</span><br><span class="line">    for (int v; root(u) != p;) &#123;</span><br><span class="line">        if (!check[v=match[u]]) push(v);</span><br><span class="line">        if (f[u] == 0) f[u] = p;</span><br><span class="line">        if (f[v] == 0) f[v] = p;</span><br><span class="line">        u = father[v];</span><br><span class="line">        if (root(u) != p) father[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flower(int u, int v) &#123;</span><br><span class="line">    int p = lca(u, v);</span><br><span class="line">    if (root(u) != p) father[u] = v;</span><br><span class="line">    if (root(v) != p) father[v] = u;</span><br><span class="line">    reset(u, p), reset(v, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool find(int x) &#123;</span><br><span class="line">    fore = rear = cnt = 0, push(x);</span><br><span class="line">    while (fore++ &lt; rear) &#123;</span><br><span class="line">        int i = que[fore];</span><br><span class="line">        for (int j = 1; j &lt;= n; j++)</span><br><span class="line">            if (a[i][j] &amp;&amp; root(i) != root(j) &amp;&amp; match[j] != i)</span><br><span class="line">                if (match[j] &amp;&amp; father[match[j]])</span><br><span class="line">                    flower(i, j);</span><br><span class="line">                else if (father[j] == 0) &#123;</span><br><span class="line">                    father[j] = i;</span><br><span class="line">                    tra[++cnt] = j;</span><br><span class="line">                    treec[j] = true;</span><br><span class="line">                    if (match[j])</span><br><span class="line">                        push(match[j]);</span><br><span class="line">                    else &#123;</span><br><span class="line">                        for (int k = i, l = j, p; k; l = p, k = father[l]) &#123;</span><br><span class="line">                            p = match[k];</span><br><span class="line">                            match[k] = l;</span><br><span class="line">                            match[l] = k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void matching() &#123;</span><br><span class="line">    for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">    if (match[i] == 0) &#123;</span><br><span class="line">        if (find(i))</span><br><span class="line">            ++ans;</span><br><span class="line">    clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="匈牙利算法">匈牙利算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个二分图,用匈牙利算法求这个二分图的最大匹配数.</span><br><span class="line">*</span><br><span class="line">*求最大匹配数,那么我们希望每一个在左边的点都尽量找到右边的一个点和它匹配.我们</span><br><span class="line">*依次枚举左边的点x的所有出边指向的y,若y之前没有被匹配,那么(x, y)就是一对合法的</span><br><span class="line">*匹配,我们将匹配数加一,否则我们试图给原来匹配y的x'重新找一个匹配,如果x'匹配成功,</span><br><span class="line">*那么就可以新增为一对合法的匹配.给x'寻找匹配的过程可以递归解决.</span><br><span class="line">*</span><br><span class="line">*int hungary();</span><br><span class="line">*复杂度:	O(|E|sqrt(|V|))</span><br><span class="line">*输  入:	n		全局变量,一侧的点数</span><br><span class="line">*		  g	 	  全局变量,g[i]表示与左边点i相连的右边的点</span><br><span class="line">*输	 出:	最大匹配数</span><br><span class="line">*		  from	  全局变量,mx[i]表示最大匹配中与左边点i相连的边</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">555</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="keyword">int</span> from[MAXN], tot;</span><br><span class="line"><span class="keyword">bool</span> use[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[x].size(); i++)</span><br><span class="line">		<span class="keyword">if</span> (!use[g[x][i]]) &#123;</span><br><span class="line">			use[g[x][i]] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (from[g[x][i]] == -<span class="number">1</span> || match(from[g[x][i]])) &#123;</span><br><span class="line">				from[g[x][i]] = x;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(from, <span class="number">255</span>, seizeof(from));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(use, <span class="number">0</span>, <span class="keyword">sizeof</span>(use));</span><br><span class="line">		<span class="keyword">if</span> (match(i))</span><br><span class="line">			tot++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双联通分量">双联通分量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个无向图,求出它的双联通分量.</span><br><span class="line">*双联通分量是指图中不包含割点的联通分量.</span><br><span class="line">*</span><br><span class="line">*和求割点的方法类似,在对图DFS的时候记录low和dfn.由于一个点可以属于多个双联通分量,而一条边属于唯一的双</span><br><span class="line">*联通分量,所以我们用一个边集来描述一个双联通分量.即:属于这个边集的所有边加上这些边的端点构成一个双联通分</span><br><span class="line">*量.每次我们发现一条树边(从父节点指向未被访问的子节点)和回边(从子节点指向父节点),就将它压入栈中.当DFS</span><br><span class="line">*从一个点u返回到点v时,如果low[u]&gt;=dfn[v],那么我们就不断地将栈顶的边弹出,直到弹出边(v,u)为止.所有弹</span><br><span class="line">*出的边构成一个双联通分量.</span><br><span class="line">*</span><br><span class="line">*void biconnect(int v);</span><br><span class="line">*复杂度: O(|E|+|V|)</span><br><span class="line">*输入:	 v			DFS到的当前节点</span><br><span class="line">*		 edge		全局变量,edge[i]表示从点i连出去的边</span><br><span class="line">*输出:	connect		全局变量,表示各个双联通分量</span><br><span class="line">*					connect内的每个元素为一个双联通分量,用属于这个双联通分量的点的编号组成的vector表示</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; connect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[maxn], low[maxn], in_seq[maxn];</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxn], <span class="built_in">list</span>[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt, top, pop, len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biconnect</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">stack</span>[++top] = v;</span><br><span class="line">	dfn[v] = low[v] = pop++;</span><br><span class="line">	<span class="keyword">int</span> i, succ;</span><br><span class="line">	<span class="keyword">for</span> (i = edge[v].size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		succ = edge[v][i];</span><br><span class="line">		<span class="keyword">if</span> (dfn[succ] == -<span class="number">1</span>) &#123;</span><br><span class="line">			biconnect(succ);</span><br><span class="line">			<span class="keyword">if</span> (low[succ] &gt;= dfn[v]) &#123;</span><br><span class="line">				cnt++;</span><br><span class="line">				len = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					in_seq[<span class="built_in">stack</span>[top]] = cnt;</span><br><span class="line">					<span class="built_in">list</span>[len++] = <span class="built_in">stack</span>[top];</span><br><span class="line">					top--;</span><br><span class="line">				&#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[top+<span class="number">1</span>] != succ);</span><br><span class="line">				in_seq[v] = cnt;</span><br><span class="line">				<span class="built_in">list</span>[len++] = v;</span><br><span class="line">				<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp(<span class="built_in">list</span>, <span class="built_in">list</span>+len);</span><br><span class="line">				connect.push_back(tmp);</span><br><span class="line">			&#125;</span><br><span class="line">			low[v] = min(low[v], low[succ]);</span><br><span class="line">		&#125; <span class="keyword">else</span> low[v] = min(low[v], dfn[succ]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于每个联通块取一个x调用disconnect(x).</span></span><br></pre></td></tr></table></figure>
<h3 id="堆">堆</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*由于堆是完全二叉树,我们使用下标从1开始的数组来表示这棵树,1代表根节点,对于每个节点i,它的左儿子为i*2,又儿子为2*i+1,父亲为i/2.</span><br><span class="line">*我们使用数组heap[]来记录队中的元素.为了实现修改和删除操作我们额外使用id[]记录堆中位置为i的元素是第几个插入的,pos[]记录第i个</span><br><span class="line">*插入元素在堆中的位置.</span><br><span class="line">*实现堆核心函数up(i)和down(i),up(i)将堆中的位置为i的节点不断"上浮"(与父亲节点相比较,如果小于父亲节点则与父亲节点交换),down(i)</span><br><span class="line">*将堆中位置为i的节点不断"下沉"(与两个儿子节点比较,如果大于较小的儿子节点则与之交换).</span><br><span class="line">*在插入一个值value时,我们将它加入堆的最底层(heap[++size] = value),然后将其上浮;删除栈顶元素时,我们将栈顶与最后一个元素交换,</span><br><span class="line">*然后下沉;修改元素时我们先利用pos数组找到它当前在堆中的位置,然后直接修改并调用up()及down()维护堆的性质即可;删除元素时我们将它修改</span><br><span class="line">*为负无穷大,上浮到根,最后删除堆顶即可.</span><br><span class="line">*</span><br><span class="line">*结构体:		BinaryHeap</span><br><span class="line">*成员变量:</span><br><span class="line">*			int n			堆中当前元素个数</span><br><span class="line">*			int counter		加入堆中的元素个数</span><br><span class="line">*			int heap[]		堆中的元素</span><br><span class="line">*			int id[]		堆中位置为i的元素是第几个插入堆中的</span><br><span class="line">*			int pos[]		第i个插入堆中的元素在堆中的位置</span><br><span class="line">*成员函数:</span><br><span class="line">*			BinaryHeap();							构造出的一个空堆</span><br><span class="line">*			BinaryHeap(int array[]; int offset);	将数组中的元素按顺序插入所构造的堆</span><br><span class="line">*			复杂度: O(n)</span><br><span class="line">*			输入:	array[]							创建堆的元素所在的数组</span><br><span class="line">*					offset							数组中需要用作创建堆的元素的个数</span><br><span class="line">*			void push(int v);						插入键值v</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*			int pop();								删除栈顶元素</span><br><span class="line">*			复杂度:	O(logn)</span><br><span class="line">*			输出:	堆顶元素插入堆中的次序编号</span><br><span class="line">*			int get(int i);							获取第i个插入堆中的元素值</span><br><span class="line">*			复杂度: O(1)</span><br><span class="line">*			void change(int i, int value);			修改第i个元素为value</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*			void erase(int i);						删除第i个元素</span><br><span class="line">*			复杂度: O(logn)</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSIZE = <span class="number">100000</span>;			<span class="comment">//二叉堆的大小</span></span><br><span class="line">Struct BinaryHeap &#123;</span><br><span class="line">	<span class="keyword">int</span> heap[MAXSIZE], id[MAXSIZE], pos[MAXSIZE], n, counter;</span><br><span class="line"></span><br><span class="line">	BinaryHeap() : n(<span class="number">0</span>), counter(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	BinaryHeap(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> offset) : n(<span class="number">0</span>), counter(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; offset; i++) &#123;</span><br><span class="line">			heap[++n] = <span class="built_in">array</span>[i];</span><br><span class="line">			id[n] = pos[n] = n;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">			down(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		heap[++n] = v;</span><br><span class="line">		id[n] = ++counter;</span><br><span class="line">		pos[id[n]] = n;</span><br><span class="line">		up(n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		swap(heap[<span class="number">1</span>], heap[n]);</span><br><span class="line">		swap(id[<span class="number">1</span>], id[n--]);</span><br><span class="line">		pos(id[<span class="number">1</span>]) = <span class="number">1</span>;</span><br><span class="line">		down(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> id[n+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> heap[pos[i]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		heap[pos[i]] = value;</span><br><span class="line">		down(pos[i]);</span><br><span class="line">		up(pos[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		heap[pos[i]] = INT_MIN;</span><br><span class="line">		up(pos[i]);</span><br><span class="line">		pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = heap[i], y = id[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i/<span class="number">2</span>; j &gt;=<span class="number">1</span>; j /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>	(heap[j] &gt; x) &#123;</span><br><span class="line">				heap[i] = heap[j];</span><br><span class="line">				id[i] = id[j];</span><br><span class="line">				pos[id[i]] = i;</span><br><span class="line">				i = j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		heap[i] = x;</span><br><span class="line">		id[i] = x;</span><br><span class="line">		pos[y] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x = heap[i], y = id[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = i*<span class="number">2</span>; j &lt;= n; j *= <span class="number">2</span>) &#123;</span><br><span class="line">			j += j &lt; n &amp;&amp; heap[j] &gt; heap[j + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>	(heap[j] &lt; x) &#123;</span><br><span class="line">				heap[i] = heap[j];</span><br><span class="line">				id[i] = id[j];</span><br><span class="line">				pos[id[i]] = i;</span><br><span class="line">				i = j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		heap[i] = x;</span><br><span class="line">		id[i] = y;</span><br><span class="line">		pos[y] = i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="常系数线性齐次递推">常系数线性齐次递推</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*常系数线性齐次递推</span><br><span class="line">*已知f(x) = a0f(x-1) + a1f(x-2) +...+ an-1f(x-n)和f(0),f(1),...f(n-1), 给定t,求f(t).</span><br><span class="line">*</span><br><span class="line">*f的递推可以看成一个n*n的矩阵A乘以一个n维列向量B,因为矩阵乘法满足结合率,用快速幂可以加速.</span><br><span class="line">*	|0	1	0   ...   0|</span><br><span class="line">*	|0	0	1   ...   0|</span><br><span class="line">*A =|	:		':.	  :|</span><br><span class="line">*	|0	0	0	...	  1|</span><br><span class="line">*	|an-1............a0|</span><br><span class="line">*</span><br><span class="line">*	|f(x-n)	 |</span><br><span class="line">*	|f(x-n+1)|</span><br><span class="line">*B =|	:	 |</span><br><span class="line">*	|f(x-2)	 |</span><br><span class="line">*	|f(x-1)  |</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*int slove(int a[], int b[], int n, int t);</span><br><span class="line">*复杂度: O(n^3logt)</span><br><span class="line">*输入:</span><br><span class="line">		a	常系数数组</span><br><span class="line">		b	初值数组</span><br><span class="line">		n	数组大小</span><br><span class="line">		t	要求解的项数</span><br><span class="line">*输出:  函数在第t项的值f(t)</span><br><span class="line">*调用外部函数:</span><br><span class="line">*		矩阵类</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">int solve(int a[], int b[], int <span class="keyword">n</span>, int t) &#123;</span><br><span class="line">	<span class="keyword">Matrix</span> <span class="keyword">M</span>, F, <span class="keyword">E</span>;</span><br><span class="line">	<span class="keyword">M</span>.<span class="keyword">clear</span>(), F.<span class="keyword">clear</span>(), <span class="keyword">E</span>.<span class="keyword">clear</span>();</span><br><span class="line">	<span class="keyword">M</span>.<span class="keyword">n</span> = <span class="keyword">M</span>.<span class="keyword">m</span> = <span class="keyword">n</span>;</span><br><span class="line">	<span class="keyword">E</span>.<span class="keyword">n</span> = <span class="keyword">E</span>.<span class="keyword">m</span> = <span class="keyword">n</span>;</span><br><span class="line">	F.<span class="keyword">n</span> = <span class="keyword">n</span>, f.<span class="keyword">m</span> = 1;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>-1; i++)</span><br><span class="line">		<span class="keyword">M</span>.a[i][i+1] = 1;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">M</span>.a[<span class="keyword">n</span>-1][i] = a[i];</span><br><span class="line">		F.a[i][0] = b[i];</span><br><span class="line">		<span class="keyword">E</span>.a[i][i] = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="keyword">n</span>)</span><br><span class="line">		<span class="keyword">return</span> F.a[t][0];</span><br><span class="line">	<span class="keyword">for</span>	(t -= <span class="keyword">n</span> - 1; t; t /= 2) &#123;</span><br><span class="line">		<span class="keyword">if</span> (t &amp; 1)</span><br><span class="line">			<span class="keyword">E</span> = <span class="keyword">M</span> * <span class="keyword">E</span>;</span><br><span class="line">		<span class="keyword">M</span> = <span class="keyword">M</span> * <span class="keyword">M</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	F = <span class="keyword">E</span> * F;</span><br><span class="line">	<span class="keyword">return</span> F.a[<span class="keyword">n</span>-1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割点和桥">割点和桥</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*给定一个无向图,找出图中的割点和桥.</span><br><span class="line">*</span><br><span class="line">*我们使用三个数组来完成这个算法:</span><br><span class="line">*vis<span class="string">[v]</span>记录的是节点v当前的访问状态:<span class="number">1</span>表示在栈中,<span class="number">0</span>表示未访问,<span class="number">2</span>表示已经访问过;</span><br><span class="line">*dfn<span class="string">[v]</span>记录的是节点v被访问时的深度;</span><br><span class="line">*low<span class="string">[v]</span>记录的是节点v可以到达的访问时间最早的祖先.</span><br><span class="line">*在深度遍历图的过程中,记录下每个节点的深度.对当前节点cur,以及和它相连的节点i,有两种情况:</span><br><span class="line">*(<span class="number">1</span>)i没被访问过,这时递归访问节点i,并用i的可以到达的最早的祖先来更新cur的low值.</span><br><span class="line">*(<span class="number">2</span>)i在当前栈中,说明图中有一个环,用i的深度更新cur的low值.</span><br><span class="line">*cur是割点的条件:cur是根且有大于一个的儿子,或者cur不是根,且cur有一个儿子使得low<span class="string">[v]</span> &gt;= dfn<span class="string">[cur]</span>.</span><br><span class="line">*(cur, i)是桥的条件:low<span class="string">[i]</span> &gt; dfn<span class="string">[cur]</span>.</span><br><span class="line">*</span><br><span class="line">*void cut_bridge(int cur, int father, int dep, int n);</span><br><span class="line">*复杂度: O(|E|+|V|)</span><br><span class="line">*输入:   cur			当前节点</span><br><span class="line">*		 father		当前节点的父亲节点</span><br><span class="line">*		 dep 		当前节点被访问时的深度</span><br><span class="line">*		 n 			图的总点数</span><br><span class="line">*		 edge 		全局变量,图的邻接矩阵(点从<span class="number">0</span>开始编号)</span><br><span class="line">*输出:	 bridge		全局变量,bridge<span class="string">[u]</span><span class="string">[v]</span>表示边(u,v)是否是一个桥</span><br><span class="line">*		 cut 		全局变量,cut<span class="string">[v]</span>表示节点v是否是一个割点</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">const int V = <span class="number">1000</span>;</span><br><span class="line">int edge<span class="string">[V]</span><span class="string">[V]</span>;</span><br><span class="line">int bridge<span class="string">[V]</span><span class="string">[V]</span>, cut<span class="string">[V]</span>;</span><br><span class="line">int low<span class="string">[V]</span>, dfn<span class="string">[V]</span>, vis<span class="string">[V]</span>;</span><br><span class="line"></span><br><span class="line">void cut_bridge(int cur, int father, int dep, int n) &#123;		//vertex: <span class="number">0</span> ~ n-<span class="number">1</span></span><br><span class="line">	vis<span class="string">[cur]</span> =  <span class="number">1</span>;</span><br><span class="line">	dfn<span class="string">[cur]</span> = low<span class="string">[cur]</span> = dep;</span><br><span class="line">	int children = <span class="number">0</span>;</span><br><span class="line">	for (int i = <span class="number">0</span>; i &lt; n; i++) if (edge<span class="string">[cur]</span><span class="string">[i]</span>) &#123;</span><br><span class="line">		if (i != father &amp;&amp; <span class="number">1</span> == vis<span class="string">[i]</span>) &#123;</span><br><span class="line">			if (dfn<span class="string">[i]</span> &lt; low<span class="string">[cur]</span>)</span><br><span class="line">				low<span class="string">[cur]</span> = dfn<span class="string">[i]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		if (<span class="number">0</span> == vis<span class="string">[i]</span>) &#123;</span><br><span class="line">			cut_bridge(i, cur, dep+<span class="number">1</span>, n);</span><br><span class="line">			children++;</span><br><span class="line">			if (low<span class="string">[i]</span> &lt; low<span class="string">[cur]</span>) low<span class="string">[cur]</span> = low<span class="string">[i]</span>;</span><br><span class="line">			if ((father == -<span class="number">1</span> &amp;&amp; children &gt; <span class="number">1</span>) || (father != -<span class="number">1</span> &amp;&amp; low<span class="string">[i]</span> &gt;= dfn<span class="string">[cur]</span>))</span><br><span class="line">				cut<span class="string">[cur]</span> = true;</span><br><span class="line">			if (low<span class="string">[i]</span> &gt; dfn<span class="string">[cur]</span>) &#123;</span><br><span class="line">				bridge<span class="string">[cur]</span><span class="string">[i]</span> = bridge<span class="string">[i]</span><span class="string">[cur]</span> = true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	vis<span class="string">[cur]</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于每一个联通块取一个点x调用cut_bridge(x, -<span class="number">1</span>, <span class="number">0</span>, n),其中n为点数</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*维护一个森林,每一棵树代表一个集合,树根元素为这个集合的代表元.利用数组father[]记录维护每个元素的父节点.</span><br><span class="line">*查询一个元素所处的集合时,只需不断需找父亲节点,即可找到该元素所处集合的代表元.</span><br><span class="line">*合并两个集合时,先找到两个集合的代表元x,y,然后令father[x] = y即可.</span><br><span class="line">*优化<span class="number">1</span>: 路径压缩,即沿着树根的路径找到元素a所在集合的代表元b之后,对这条路径上的所有元素x(包括a),直接令father[x] = b.</span><br><span class="line">*优化<span class="number">2</span>: 按<span class="built_in">rank</span>启发合并,即对于每个集合维护一个<span class="built_in">rank</span>值,每次将<span class="built_in">rank</span>较小的集合合并到<span class="built_in">rank</span>较大的集合,合并两个<span class="built_in">rank</span>相同的集合时<span class="built_in">rank</span> = <span class="built_in">rank</span> + <span class="number">1.</span></span><br><span class="line">*</span><br><span class="line">*结构体: 	DisjoinSet</span><br><span class="line">*成员变量:	vector&lt;<span class="typename">int</span>&gt; father			元素的父节点,树根元素的父亲为本身</span><br><span class="line">*			vector&lt;<span class="typename">int</span>&gt; <span class="built_in">rank</span>			树根元素代表集合的<span class="built_in">rank</span></span><br><span class="line">*成员函数:</span><br><span class="line">*			DisjointSet(<span class="typename">int</span> n);			初始化,n个元素,处于单独集合</span><br><span class="line">*			复杂度:	O(n)</span><br><span class="line">*			<span class="typename">int</span> find(<span class="typename">int</span> v);			查找v所在的集合的代表元</span><br><span class="line">*			复杂度:	均摊O(<span class="number">1</span>)</span><br><span class="line">*			void merge(<span class="typename">int</span> x, <span class="typename">int</span> y);	合并x所在的集合与y所在的集合</span><br><span class="line">*			复杂度:	均摊O(<span class="number">1</span>)</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">struct DisjointSet &#123;</span><br><span class="line">	std::vector&lt;<span class="typename">int</span>&gt; father, <span class="built_in">rank</span>;</span><br><span class="line"></span><br><span class="line">	DisjointSet (<span class="typename">int</span> n) : father(n), <span class="built_in">rank</span>(n) &#123;</span><br><span class="line">		for (<span class="typename">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			father[i] = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="typename">int</span> find(<span class="typename">int</span> v) &#123;</span><br><span class="line">		return father[v] = father[v] == v ? v : find(father[v]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void merge(<span class="typename">int</span> x, <span class="typename">int</span> y) &#123;</span><br><span class="line">		<span class="typename">int</span> a = find(x), b = find(y);</span><br><span class="line">		if (<span class="built_in">rand</span>[a] &lt; <span class="built_in">rank</span>[b]) &#123;</span><br><span class="line">			father[a] = b;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			father[b] = a;</span><br><span class="line">			if (<span class="built_in">rank</span>[b] == <span class="built_in">rank</span>[a]) &#123;</span><br><span class="line">				<span class="built_in">rank</span>[a]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="高斯消元">高斯消元</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*高斯消元</span><br><span class="line">*给一个n元一次方程组,求其解集</span><br><span class="line">*将方程组做成矩阵形式,再利用三种初等矩阵变换,得到上三角矩阵,最后回代得到解集</span><br><span class="line">*</span><br><span class="line">*int solve(double a[][MAXN], bool l[], double ans[], const int &amp;n);</span><br><span class="line">*</span><br><span class="line">*复杂度(N^3)</span><br><span class="line">*输入:</span><br><span class="line">		a		方程组对应的矩阵</span><br><span class="line">		n		未知数的个数</span><br><span class="line">		l, ans	l[]表示是否为自由元,储存解</span><br><span class="line">*输出:	解空间的维数</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">inline <span class="keyword">int</span> <span class="title">solve</span>(<span class="params"><span class="keyword">double</span> a[][MAXN], <span class="keyword">bool</span> l[], <span class="keyword">double</span> ans[], <span class="keyword">const</span> <span class="keyword">int</span> &amp;n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		l[i] = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = r; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (fabs(a[j][i]) &gt; EPS) &#123;</span><br><span class="line">				<span class="keyword">for</span>	(<span class="keyword">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">					swap(a[j][k], a[r][k]);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span> (fabs(a[r][i]) &lt; EPS) &#123;</span><br><span class="line">			res++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>	(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			<span class="keyword">if</span> (j != r &amp;&amp; fabs(a[j][i]) &gt; EPS) &#123;</span><br><span class="line">				<span class="keyword">double</span> tmp = a[j][i] / a[r][i];</span><br><span class="line">				<span class="keyword">for</span>	(<span class="keyword">int</span> k = i; k &lt;= n; k++)</span><br><span class="line">					a[j][k] -= tmp * a[r][k];</span><br><span class="line">			&#125;</span><br><span class="line">		l[i] = <span class="keyword">true</span>;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l[i])</span><br><span class="line">			<span class="keyword">for</span>	(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">				<span class="keyword">if</span>	(fabs(a[j][i]) &gt; <span class="number">0</span>)</span><br><span class="line">					ans[i] = a[j][n] / a[j][i];</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧几里德">欧几里德</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里德">扩展欧几里德</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*求出A,B的最大公约数,且求出X,Y满足AX+BY = GCD(A, B).</span><br><span class="line">*</span><br><span class="line">*要求X,Y,满足: AX+BY = GCD(A, B).</span><br><span class="line">*当B = 0时,有X = 1, Y = 0时等式成立.</span><br><span class="line">*当B &gt; 0时,在欧几里德算法的基础上,已知:</span><br><span class="line">*			GCD(A, B) = GCD(B, A mod B)</span><br><span class="line">*先递归求出X', Y'满足:</span><br><span class="line">*	BX' + (A mod B)Y' = GCD(B, A mod B) = GCD(A, B)</span><br><span class="line">*然后可以回推,我们将上式化简得:</span><br><span class="line">*		BX' + (A - A/B * B)Y' = GCD(A, B)</span><br><span class="line">*		AY' + BX' - (A/B) * BY' = GCD(A, B)</span><br><span class="line">*这里除法指整除.把含B的因式提取一个B,可得:</span><br><span class="line">*		AY' + B(X' - A/B * Y') = GCD(A, B)</span><br><span class="line">*故X = Y', Y = X' - A/B * Y'.</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*int estend_gcd(int a, int b, int &amp;x, int &amp;y);</span><br><span class="line">*复杂度:	O(logN)		其中N和a,b同阶</span><br><span class="line">*输  入:	a, b 		两个整数</span><br><span class="line">*			&amp;x, &amp;y		引用,ax + by = GCD(a, b)的一组解</span><br><span class="line">*输  出:	a和b的最大公约数</span><br><span class="line">*调用后x, y满足方程ax + by = GCD(a, b).</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ectend_gcd(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y) &#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">		x = <span class="number">1</span>;</span><br><span class="line">		y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">int</span> r = extend_gcd(b, a % b, y, x);</span><br><span class="line">		y -= x*(a/b);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度整数">高精度整数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*完成高精度整数的加减乘除以及取模运算。</span><br><span class="line">*</span><br><span class="line">*结构体：BigNumber</span><br><span class="line">*成员变量：</span><br><span class="line">*    int d[maxl] d[0]表示当前的位数</span><br><span class="line">*                其余d[i]表示第i位上的数(每四位压成一个万进制)</span><br><span class="line">*构造函数：</span><br><span class="line">*    BigNumber(string s)   从字符串s构造</span><br><span class="line">*成员函数：</span><br><span class="line">*    string toString()     输出字符串</span><br><span class="line">*重载运算符：+、-、*、/、&lt;、==</span><br><span class="line">*</span><br><span class="line">*运算过程中和结果都不能包含负数。答案最长长度为(maxl-1)*4。做除法的时候保存在全局变量d里面</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ten[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> BigNumber&#123;</span><br><span class="line">    <span class="keyword">int</span> d[maxl];</span><br><span class="line">    BigNumber(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        d[<span class="number">0</span>] = (len-<span class="number">1</span>)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; maxl; i++) d[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            j = (len-<span class="number">1</span>-i)/<span class="number">4</span>+<span class="number">1</span>;</span><br><span class="line">            k = (len-<span class="number">1</span>-i)%<span class="number">4</span>;</span><br><span class="line">            d[j] += ten[k] * (s[i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d[<span class="number">0</span>] &gt; <span class="number">1</span> &amp;&amp; d[d[<span class="number">0</span>]] == <span class="number">0</span>) d[<span class="number">0</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    BigNumber() &#123;</span><br><span class="line">        *<span class="keyword">this</span> = BigNumber(<span class="built_in">string</span>(<span class="string">"0"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i, j, temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (d[d[<span class="number">0</span>]] &gt;= ten[i]) <span class="keyword">break</span>;</span><br><span class="line">        temp = d[d[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            s = s + (<span class="keyword">char</span>)(temp/ten[j]+<span class="string">'0'</span>);</span><br><span class="line">            temp %= ten[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = d[<span class="number">0</span>]-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            temp = d[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">3</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                s = s + (<span class="keyword">char</span>)(temp/ten[j]+<span class="string">'0'</span>);</span><br><span class="line">                temp %= ten[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; zero(<span class="string">"0"</span>), d, temp, mid1[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] != b.d[<span class="number">0</span>]) <span class="keyword">return</span> a.d[<span class="number">0</span>] &lt; b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = a.d[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (a.d[i] != b.d[i]) <span class="keyword">return</span> a.d[i] &lt; b.d[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> + (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = max(a.d[<span class="number">0</span>], b.d[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= c.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = a.d[i] + b.d[i] + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[++c.d[<span class="number">0</span>]] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> - (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= c.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = <span class="number">10000</span> + a.d[i] - b.d[i] + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x = x / <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> * (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>] + b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, j, x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= b.d[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">            x = a.d[i] * b.d[j] + x + cd[i+j-<span class="number">1</span>];</span><br><span class="line">            c.d[i+j-<span class="number">1</span>] = x % <span class="number">10000</span>;</span><br><span class="line">            x /= <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.d[i+b.d[<span class="number">0</span>]] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">smaller</span> <span class="params">(<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] + delta != b.d[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> a.d[<span class="number">0</span>] + delta &lt; b.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.d[<span class="number">0</span>]; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (a.d[i] != b.d[i+delta])</span><br><span class="line">            <span class="keyword">return</span> a.d[i] &lt; b.d[i+delta];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Minus</span><span class="params">(BigNumber &amp;a, <span class="keyword">const</span> BigNumer &amp;b, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]-delta; i++) &#123;</span><br><span class="line">        x = <span class="number">10000</span> + a.d[i+delta] - b.d[i] + x;</span><br><span class="line">        a.d[i+delta] = x % <span class="number">10000</span>;</span><br><span class="line">        x = x / <span class="number">10000</span> - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((a.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (a.d[a.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        a.d[<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> * (<span class="keyword">const</span> bigNumber &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    c.d[<span class="number">0</span>] = a.d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> i, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        x = a.d[i] * k + x;</span><br><span class="line">        c.d[i] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c.d[++c.d[<span class="number">0</span>]] = x % <span class="number">10000</span>;</span><br><span class="line">        x /= <span class="number">10000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigNumber <span class="keyword">operator</span> / (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    BigNumber c;</span><br><span class="line">    d = a;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    mid1[<span class="number">0</span>] = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++) &#123;</span><br><span class="line">        mid1[i] = mid1[i-<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = a.d[<span class="number">0</span>] - b.d[<span class="number">0</span>]; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = <span class="number">8192</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">13</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (smaller(mid1[j], i)) &#123;</span><br><span class="line">                Minus(d, mid1[j], i);</span><br><span class="line">                c.d[i+<span class="number">1</span>] += temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c.d[<span class="number">0</span>] = max(<span class="number">1</span>, a.d[<span class="number">0</span>]-b.d[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> ((c.d[<span class="number">0</span>] &gt; <span class="number">1</span>) &amp;&amp; (c.d[c.d[<span class="number">0</span>]] == <span class="number">0</span>))</span><br><span class="line">        c.d[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> BigNumber &amp;a, <span class="keyword">const</span> BigNumber &amp;b) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (a.d[<span class="number">0</span>] != b.d[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= a.d[<span class="number">0</span>]; i++)</span><br><span class="line">        <span class="keyword">if</span> (a,d[i] != b.d[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛法求素数">筛法求素数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个正整数N,求出[2,N]中所有的素数.</span><br><span class="line">*</span><br><span class="line">*数组valid[i]记录i是否为素数.初始所有的valid[i]都为true.从2开始从小到大枚举;若valid[i] = true,则把从i^2开始的</span><br><span class="line">*每一个i的倍数的valid赋为false.</span><br><span class="line">*结束之后valid[i] = true的就是素数.</span><br><span class="line">*</span><br><span class="line">*void getPrime(int n, int &amp;tot, int ans[maxn]);</span><br><span class="line">*复杂度: O(NlogN), O(N),	 两种实现</span><br><span class="line">*输入:	 N				 所需素数的范围</span><br><span class="line">*输出:	 &amp;tot			 引用,素数总数</span><br><span class="line">*		 ans 			 素数表</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 素数筛法 O(NlogN) */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> maxn <span class="number">1000000</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> ans[maxn])</span> </span>&#123;</span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) valid[i] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (valid[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n/i &lt; i) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt;= n; j += i) valid[j] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span> (valid[i]) ans[++tot] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 素数筛法 O(N) */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrime</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> &amp;tot, <span class="keyword">int</span> ans[maxn])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(valid, <span class="literal">true</span>, <span class="keyword">sizeof</span>(valid));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (valid[i]) ans[++tot] = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ((j &lt;= tot) &amp;&amp; (i*ans[j] &lt;= n)); j++) &#123;</span><br><span class="line">			valid[i*ans[j]] = <span class="literal">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % ans[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉函数">欧拉函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*计算N的欧拉函数Phi(N)。</span><br><span class="line">*</span><br><span class="line">*定义：欧拉函数Phi(N)，表示小于或等于n的数中与n互质的数的数目。</span><br><span class="line">*欧拉函数求值的方法是：</span><br><span class="line">*(1) Phi(1) ＝ 1</span><br><span class="line">*(2) 若n是素数p的k次幂，Phi(n)＝p^k-p^(k-1)=(p-1)p^(k-1)</span><br><span class="line">*(3) 若n，m互质，Phi(nm) = Phi(n)*Phi(m)</span><br><span class="line">*</span><br><span class="line">*根据欧拉函数的定义，可以推出欧拉函数的递推式：</span><br><span class="line">*</span><br><span class="line">*令p为N的最小质因数，若p^2|N,Phi(N)=Phi(N/p)*p;否则Phi(N)=Phi(N)*(p-1)。</span><br><span class="line">*</span><br><span class="line">*void genPhi();</span><br><span class="line">*复杂度：  O(NlogN)</span><br><span class="line">*输 出：   phi 全局变量，存储了1～max中每个数的欧拉函数。</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">111111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minDiv[max], phi[max], sum[max];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genPhi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max; i++) &#123;</span><br><span class="line">        minDiv[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; max; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minDiv[i] == i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i*i; j &lt; max; j += i) &#123;</span><br><span class="line">                minDiv[j] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; max; i++) &#123;</span><br><span class="line">        phi[i] = phi[i / minDiv[i]];</span><br><span class="line">        <span class="keyword">if</span> ((i / minDiv[i]) % minDiv[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            phi[i] *= minDiv[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            phi[i] *= minDiv[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前向星">前向星</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*以前向星方式存储一个有向图的基本信息.</span><br><span class="line">*使用链表方式存储图的边.info[i]为节点i的边集所对应的链表的头指针,next[j]为第j条边的指向下一条边的指针,to[j]表示第j条边</span><br><span class="line">*所指向的节点编号.即:令addr = info[i],之后不断用addr = next[addr]即可得到链表中节点i的所有边集的编号,其中to[addr]表示</span><br><span class="line">*对应边指向的节点编号.</span><br><span class="line">*</span><br><span class="line">*结构体:graph</span><br><span class="line">*成员变量:</span><br><span class="line">*		vector&lt;int&gt; info 	由该点出发的所有边构成的链表的表</span><br><span class="line">*		vector&lt;int&gt; next 	链表中下一条边在to数组中的位置</span><br><span class="line">*		vector&lt;int&gt; to		to[i]表示编号为i的边指向的节点</span><br><span class="line">*成员函数:</span><br><span class="line">*		graph(int n, int m);	初始化图为n个点,m条边</span><br><span class="line">*		void add(int i, int j); 添加(i,j)之间的边</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> graph &#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; VI;</span><br><span class="line">	VI info, next, to;</span><br><span class="line">	graph(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>) : to(<span class="number">0</span>), next(<span class="number">0</span>) &#123;</span><br><span class="line">		info.resize(n);</span><br><span class="line">		next.reserve(m);</span><br><span class="line">		to.reserve(m);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">edge_size</span><span class="params">()</span> </span>&#123;					<span class="comment">//返回边的数量</span></span><br><span class="line">		<span class="keyword">return</span> to.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">vertex_size</span><span class="params">()</span> </span>&#123;					<span class="comment">//返回值为最大点的编号+1</span></span><br><span class="line">		<span class="keyword">return</span> info.size();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (info.size() &lt; i + <span class="number">1</span>)</span><br><span class="line">			info.resize(i + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;			<span class="comment">//添加一条i到j的边</span></span><br><span class="line">		expand(i), expand(j);</span><br><span class="line">		to.push_back(j);</span><br><span class="line">		next.push_back(info[i]);</span><br><span class="line">		info[i] = to.size() - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del_back</span><span class="params">()</span> </span>&#123;					<span class="comment">//删除最后一次添加的边</span></span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>	(i = <span class="number">0</span>; i &lt; info.size(); i++)</span><br><span class="line">			<span class="keyword">if</span> (info[i] == to.size() - <span class="number">1</span>) &#123;</span><br><span class="line">				info[i] = next.back();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		to.pop_back();</span><br><span class="line">		next.pop_back();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;						<span class="comment">//清空图类</span></span><br><span class="line">		info.clear();</span><br><span class="line">		next.resize(<span class="number">0</span>);</span><br><span class="line">		tp.resize(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树">线段树</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*要求实现一种数据结构,使得它能够在O(logN)时间复杂度内动态维护一段序列:修改一个元素的权值,查询一段区间的最小(最大)值.</span><br><span class="line">*</span><br><span class="line">*线段树是一个二叉树,树上每个节点表示一段区间,每个节点的左右儿子分别是该节点表示的区间从中间断开后分成的左区间和右区间.</span><br><span class="line">*每个区间记录一个当前子树的最小/最大值Top[i].</span><br><span class="line">*查询[a,b]区间的话也很简单,对于当前节点i,如果[a,b]能够完全覆盖i表示的区间,则直接返回Top[i],否则判断与左右区间是否有交</span><br><span class="line">*递归进入访问,取两者之间的最大值即可.</span><br><span class="line">*</span><br><span class="line">*(假设这里维护的是最大值)</span><br><span class="line">*类: IntervalTree</span><br><span class="line">*成员函数:</span><br><span class="line">*		IntervalTree(int size);		构造一颗维护区间[1..size]的线段树</span><br><span class="line">*		Int Query(int a, int b);	查询[a..b]区间内的最大值</span><br><span class="line">*		复杂度:	O(logN)</span><br><span class="line">*		void Modify(int a, int d);	把第a个元素的值改成d</span><br><span class="line">*		复杂度:	O(logN)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TREE_SIZE (i&lt;&lt;(<span class="number">20</span>))</span></span><br><span class="line"><span class="keyword">class</span> IntervalTree&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> Cover[TREE_SIZE], Top[TREE_SIZE];</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">int</span> _Query(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Ind) &#123;</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= l &amp;&amp; b &gt;= r) <span class="keyword">return</span> Top[Ind];</span><br><span class="line">	<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>, ret = Cover[Ind];</span><br><span class="line">	<span class="keyword">if</span> (a &lt;= mid) ret = max(ret, _Query(a, b, l, mid, Ind &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (b &gt; mid) ret = max(ret, _Query(a, b, mid+<span class="number">1</span>, r, (Ind &lt;&lt; <span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> _Modify(<span class="keyword">int</span> a, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> Ind, <span class="keyword">int</span> d) &#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r &amp;&amp; l == a) &#123;</span><br><span class="line">			Cover[Ind] = Top[Ind] = d;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (a &lt;= mid) _Modify(a, l, mid, Ind &lt;&lt; <span class="number">1</span>, d);</span><br><span class="line">		<span class="keyword">else</span> _Modify(a, mid+<span class="number">1</span>, r, (Ind&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>, d);</span><br><span class="line">		Top[Ind] = max(Top[Ind&lt;&lt;<span class="number">1</span>], Top[(Ind&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	IntervalTree() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(Cover, <span class="number">0</span>, <span class="keyword">sizeof</span>(Cover));</span><br><span class="line">		<span class="built_in">memset</span>(Top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Top));</span><br><span class="line">		size = (TREE_SIZE&gt;&gt;<span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	IntervalTree(<span class="keyword">int</span> size):size(size) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(Cover, <span class="number">0</span>, <span class="keyword">sizeof</span>(Cover));</span><br><span class="line">		<span class="built_in">memset</span>(Top, <span class="number">0</span>, <span class="keyword">sizeof</span>(Top));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Query(a, b, <span class="number">1</span>, size, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> _Modify(a, <span class="number">1</span>, size, <span class="number">1</span>, d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵的逆">矩阵的逆</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*求矩阵的逆</span><br><span class="line">*将原矩阵<span class="keyword">A</span>和一个单位矩阵E作成大矩阵(<span class="keyword">A</span>,E),用初等行变换将大矩阵中的<span class="keyword">A</span>变成E,</span><br><span class="line">*则会得到(E,<span class="keyword">A</span>')的形式</span><br><span class="line">*</span><br><span class="line">*void inverse(vector&lt;double&gt; <span class="keyword">A</span>[], vector&lt;double&gt; C[], int N)<span class="comment">;</span></span><br><span class="line">*复杂度(n^3)</span><br><span class="line">*输入:</span><br><span class="line">*		<span class="keyword">A</span>	原矩阵</span><br><span class="line">*		C	逆矩阵</span><br><span class="line">*		N	矩阵的阶数</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">inline vector&lt;double&gt; operator * (vector&lt;double&gt; a, double b) &#123;</span><br><span class="line">	int N = a.size()<span class="comment">;</span></span><br><span class="line">	vector&lt;double&gt; res(N, 0)<span class="comment">;</span></span><br><span class="line">	for (int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		res[i] = a[i] * b<span class="comment">;</span></span><br><span class="line">	return res<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline vector&lt;double&gt; operator - (vector&lt;double&gt; a, vector&lt;double&gt; b) &#123;</span><br><span class="line">	int N = a.size()<span class="comment">;</span></span><br><span class="line">	vector&lt;double&gt; res(N, 0)<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		res[i] = a[i] - b[i]<span class="comment">;</span></span><br><span class="line">	return res<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void inverse(vector&lt;double&gt; <span class="keyword">A</span>[], vector&lt;double&gt; C[], int N) &#123;</span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		C[i] = vector&lt;double&gt;(N,0)<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++)</span></span><br><span class="line">		C[i][i] = 1<span class="comment">;</span></span><br><span class="line">	for	(int i = 0<span class="comment">; i &lt; N; i++) &#123;</span></span><br><span class="line">		for	(int j = i<span class="comment">; j &lt; N; j++)</span></span><br><span class="line">			if (fabs(<span class="keyword">A</span>[j][i]) &gt; 0) &#123;</span><br><span class="line">				swap(<span class="keyword">A</span>[i], <span class="keyword">A</span>[j])<span class="comment">;</span></span><br><span class="line">				swap(C[i], C[j])<span class="comment">;</span></span><br><span class="line">				break<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">		C[i] = C[i] * (1 / <span class="keyword">A</span>[i][i])<span class="comment">;</span></span><br><span class="line">		<span class="keyword">A</span>[i] = <span class="keyword">A</span>[i] * (1 / <span class="keyword">A</span>[i][i])<span class="comment">;</span></span><br><span class="line">		for	(int j = 0<span class="comment">; j &lt; N; j++)</span></span><br><span class="line">			if (j != i &amp;&amp; fabs(<span class="keyword">A</span>[j][i]) &gt; 0) &#123;</span><br><span class="line">				C[j] = C[j] - C[i] * <span class="keyword">A</span>[j][i]<span class="comment">;</span></span><br><span class="line">				<span class="keyword">A</span>[j] = <span class="keyword">A</span>[j] - <span class="keyword">A</span>[i] * <span class="keyword">A</span>[j][i]<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LCA">LCA</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*对于每个节点v,记录anc[<span class="link_label">v</span>][<span class="link_reference">k</span>],表示从它向上走2^k步之后达到的节点(如果越过了根节点,那么anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]就是根节点)</span><br><span class="line">*dfs函数对树进行dfs,先求出anc[<span class="link_label">v</span>][<span class="link_reference">0</span>],再利用anc[<span class="link_label">v</span>][<span class="link_reference">k</span>] = anc[<span class="link_label">anc[v</span>][<span class="link_reference">k-1</span>]][<span class="link_reference">k-1</span>]求出其他anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]的值</span><br><span class="line">*swim(x,k)函数从节点x向上走k步,并将x赋为新走到的节点</span><br><span class="line">*find(x,y)函数需找x和y的LCA.首先利用swin,将x,y调整到同一高度.如果此时x和y重合,那么这就是我们要找的LCA.</span><br><span class="line">*如果它们不重合,不断地寻找一个最小的k,使得anc[<span class="link_label">x</span>][<span class="link_reference">k</span>] = anc[<span class="link_label">y</span>][<span class="link_reference">k</span>](说明向上走2^k越过了x,y的LCA),然后x,y同时</span><br><span class="line">*向上移动2^(k-1)步,显然新的x,y和原来的x,y有相同的LCA.直到k = 0,说明此时x,y的父节点anc[<span class="link_label">x</span>][<span class="link_reference">0</span>]和anc[<span class="link_label">y</span>][<span class="link_reference">0</span>]重合</span><br><span class="line">*并且就是我们要寻找的LCA.</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int lca(int root);</span><br><span class="line">*复杂度: O(N)</span><br><span class="line">*输入:</span><br><span class="line"><span class="bullet">*		</span>root	树的根节点</span><br><span class="line"><span class="bullet">*		</span>head	全局变量,存储边的信息,head[i]表示第i个节点的头指针</span><br><span class="line"><span class="bullet">*		</span>point	全局变量,point[i]表示第i条边指向的节点</span><br><span class="line"><span class="bullet">*		</span>next	全局变量,next[i]表示第i条边的下一个指针</span><br><span class="line">*输出:</span><br><span class="line"><span class="bullet">*		</span>anc		全局变量,anc[<span class="link_label">v</span>][<span class="link_reference">k</span>]表示节点v向上走2^k步后到达的节点</span><br><span class="line"><span class="bullet">*</span><br><span class="line"></span>*int find(int x, int y);</span><br><span class="line">*复杂度: O(logN)</span><br><span class="line">*输入:</span><br><span class="line"><span class="bullet">*		</span>x,y 	询问x和y的LCA</span><br><span class="line">*输出:</span><br><span class="line"><span class="bullet">*		</span>点x和y的LCA</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">void dfs(int root) &#123;</span><br><span class="line"><span class="code">	static int Stack[maxn];</span></span><br><span class="line"><span class="code">	int top = 0;</span></span><br><span class="line"><span class="code">	dep[root] = 1;</span></span><br><span class="line"><span class="code">	for	(int i = 0; i &lt; maxh; i++)</span></span><br><span class="line"><span class="code">		ans[root][i] = root;</span></span><br><span class="line"><span class="code">	Stack[++top] = root;</span></span><br><span class="line"><span class="code">	memcpy(head, info, szieof(head));</span></span><br><span class="line"><span class="code">	while (top) &#123;</span></span><br><span class="line"><span class="code">		int x = Stack[top];</span></span><br><span class="line"><span class="code">		if	(x != root) &#123;</span></span><br><span class="line"><span class="code">			for	(int i = 1; i &lt; maxh; i++) &#123;</span></span><br><span class="line"><span class="code">				int y = anc[x][i-1];</span></span><br><span class="line"><span class="code">				anc[x][i] = anc[y][i-1];</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		for (int &amp;i = head[x]; i; i = next[i]) &#123;</span></span><br><span class="line"><span class="code">			int y = point[i];</span></span><br><span class="line"><span class="code">			if (y != anc[x][0]) &#123;</span></span><br><span class="line"><span class="code">				dep[y] = dep[x] + 1;</span></span><br><span class="line"><span class="code">				anc[y][0] = x;</span></span><br><span class="line"><span class="code">				Stack[++top] = y;</span></span><br><span class="line"><span class="code">			&#125;</span></span><br><span class="line"><span class="code">		&#125;</span></span><br><span class="line"><span class="code">		while (top &amp;&amp; head[Stack[top]] == 0) top--;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swim(int &amp;x, int H) &#123;</span><br><span class="line"><span class="code">	for (int i = 0; H &gt; 0; i++) &#123;</span></span><br><span class="line"><span class="code">		if (H &amp; 1) x = anc[x][i];</span></span><br><span class="line"><span class="code">		H /= 2;</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lca(int x, int y) &#123;</span><br><span class="line"><span class="code">	int i;</span></span><br><span class="line"><span class="code">	if (dep[x] &gt; dep[y]) swap(x, y);</span></span><br><span class="line"><span class="code">	swim(y, dep[y] - dep[x]);</span></span><br><span class="line"><span class="code">	if (x == y) return x;</span></span><br><span class="line"><span class="code">	for (;;) &#123;</span></span><br><span class="line"><span class="code">		for	(i = 0; anc[x][i] != anc[y][i]; i++);</span></span><br><span class="line"><span class="code">		if (i == 0) return anc[x][0];</span></span><br><span class="line"><span class="code">		x = anc[x][i-1];</span></span><br><span class="line"><span class="code">		y = anc[y][i-1];</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">	return -1;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵类">矩阵类</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现矩阵的基本变换</span><br><span class="line">*结构体: Matrix</span><br><span class="line">*成员变量:</span><br><span class="line">*	int n,m       矩阵大小</span><br><span class="line">*	int a[][]	  矩阵内容</span><br><span class="line">*重载运算符: + - *</span><br><span class="line">*成员函数:</span><br><span class="line">*	void cleat()  清空矩阵</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int MAXN = 1010;</span><br><span class="line"><span class="keyword">const</span> int MAXM = 1010;</span><br><span class="line">struct <span class="keyword">Matrix</span>&#123;</span><br><span class="line">	int <span class="keyword">n</span>, <span class="keyword">m</span>;</span><br><span class="line">	int a[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line">	void <span class="keyword">clear</span>()&#123;</span><br><span class="line">		<span class="keyword">n</span> = <span class="keyword">m</span> = 0;</span><br><span class="line">		memset(a, 0, sizeof(a));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator +(<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				tmp.a[i][j] = a[i][j] + b.a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator - (<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span>	(int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				tmp.a[i][j] = a[i][j] - b.a[i][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">Matrix</span> operator * (<span class="keyword">const</span> <span class="keyword">Matrix</span> &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">Matrix</span> tmp;</span><br><span class="line">		tmp.<span class="keyword">clear</span>();</span><br><span class="line">		tmp.<span class="keyword">n</span> = <span class="keyword">n</span>;</span><br><span class="line">		tmp.<span class="keyword">m</span> = <span class="keyword">m</span>;</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">n</span>; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>	(int j = 0; j &lt; b.<span class="keyword">m</span>; j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>	(int k = 0; k &lt; <span class="keyword">m</span>; k++)&#123;</span><br><span class="line">					tmp.a[i][j] += a[i][k] * b.a[k][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		retrun tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Prim算法">Prim算法</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*先任意找一个点标记,然后每次找一条最短的两端分别为标记和未标记的边加进来,</span><br><span class="line">*把未标记的点标记上.即每次加入一条合法的最短的边,每次扩展一个点由未标记为</span><br><span class="line">*以标记,直到扩展至N个点</span><br><span class="line">*</span><br><span class="line">*int Prim();</span><br><span class="line">*复杂度: O(|V|^2)</span><br><span class="line">*输入:</span><br><span class="line">*	g	全局变量,g[i]表示所有与节点i相连的边</span><br><span class="line">*		g[i][j].first表示与节点i的第j条边相连的节点的编号</span><br><span class="line">*		g[i][j].second表示距离</span><br><span class="line">*</span><br><span class="line">*输出:	最小生成树的边权和</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">void Prim() &#123;</span><br><span class="line">	memset(v, 0, sizeof(v));</span><br><span class="line">	<span class="keyword">for</span> (int i= 1; i &lt;= <span class="keyword">N</span>; i++) <span class="keyword">dis</span>[i] = <span class="keyword">INF</span>;</span><br><span class="line">	<span class="keyword">dis</span>[1] = 0;</span><br><span class="line">	int ans = 0;</span><br><span class="line">	<span class="keyword">for</span>	(int i = 1; i &lt;= <span class="keyword">N</span>; i++) &#123;</span><br><span class="line">		int <span class="keyword">mark</span> = -1;</span><br><span class="line">		<span class="keyword">for</span>	(int j = 1; j &lt;= <span class="keyword">N</span>; j++)</span><br><span class="line">			<span class="keyword">if</span>	(!v[j])</span><br><span class="line">				<span class="keyword">if</span>	(<span class="keyword">mark</span> == -1) &#123;</span><br><span class="line">					<span class="keyword">mark</span> = j;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">dis</span>[j] &lt; <span class="keyword">dis</span>[<span class="keyword">mark</span>]) <span class="keyword">mark</span> = j;</span><br><span class="line">		<span class="keyword">if</span>	(<span class="keyword">mark</span> = -1) <span class="keyword">break</span>;</span><br><span class="line">		v[<span class="keyword">mark</span>] = 1;</span><br><span class="line">		ans += <span class="keyword">dis</span>[<span class="keyword">mark</span>];</span><br><span class="line">		<span class="keyword">for</span>	(int j = 0; j &lt; <span class="keyword">g</span>[<span class="keyword">mark</span>].size(); j++)</span><br><span class="line">			<span class="keyword">if</span>	(!v[<span class="keyword">g</span>[<span class="keyword">mark</span>][j].first]) &#123;</span><br><span class="line">				int x = <span class="keyword">g</span>[<span class="keyword">mark</span>][j].first;</span><br><span class="line">				<span class="keyword">dis</span>[x] = <span class="literal">min</span>(<span class="keyword">dis</span>[x], <span class="keyword">g</span>[<span class="keyword">mark</span>][j].seceond);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法">Kruskal算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给出带权无向图，用Kruskal算法求出其权值和最小的生成树。</span><br><span class="line">*</span><br><span class="line">*Kruskal是通过一个贪心的想法：每次去剩下的边权最小的边，如果加上这条边以后图出现了一个环(这个可以</span><br><span class="line">*通过并查集维护)，则破坏了生成树的性质，就不选这条边。依次进行直到整张图出现一棵生成树为止。</span><br><span class="line">*</span><br><span class="line">*int kruskal();</span><br><span class="line">*复杂度：O(MlogM)</span><br><span class="line">*输 入： N, M     全局变量，图中的点数和边数</span><br><span class="line">*       e        全局变量，e[i]表示第i条边的信息(连接x与y，权值为w)</span><br><span class="line">*输 出： 最小生成树的边权和</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> edge&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    edge(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">int</span> y = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>):x(x), y(y), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfather</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fa[x] = getfather(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(e+<span class="number">1</span>, e+M+<span class="number">1</span>, cmp);        <span class="comment">//对边权从小到大排序</span></span><br><span class="line">    <span class="keyword">int</span> cnt = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> t1 = getfather(fa[e[i].x]);</span><br><span class="line">        <span class="keyword">int</span> t2 = getfather(fa[e[i].y]);</span><br><span class="line">        <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">            fa[t1] = t2;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组">树状数组</h3><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*对于数组A[1..n],在O(logn)的时间内完成一下任务:</span><br><span class="line">*(1)给A[i]加上一个数</span><br><span class="line">*(2)求A[1]+...+A[i]的和</span><br><span class="line">*</span><br><span class="line">*树状数组的第i个元素Tree[i]表示A[lowbit(i)+1..i]的和,其中lowbit(i)表示i的最低二进制位.</span><br><span class="line">*当想要查询一个A[1]+...+A[i]的和,可以依据如下算法即可:</span><br><span class="line">*(1)令sum=0,转第(2)步.</span><br><span class="line">*(2)假如i&lt;=0,算法结束,返回sum值,否则sum+=Tree[i],转第(3)步.</span><br><span class="line">*(3)i-=lowbit(i),转第(2)步.</span><br><span class="line">*可以看出,这个算法就是将这一个个区间的和全部加起来,为什么效率是O(logn)的呢?一下给出证明:</span><br><span class="line">*i-=lowbit(i)这一步实际上等价于将i的二进制的最后一个1减去.而i的二进制里最多有logn个1,所以查询效率是O(logn)的.</span><br><span class="line">*而且A[i]加上x的算法如下:</span><br><span class="line">*(1)当i&gt;n时,算法结束,否则转第(2)步.</span><br><span class="line">*(2)Tree[i]+=x, i+=lowbit(i),否则转第(1)步.</span><br><span class="line">*i+=lowbit(i)这个过程实际上也只是一个把末尾1补为0的过程.容易看出复杂度也是O(logn)的.</span><br><span class="line">*最后lowbit(i)的求法有个简单的公式,lowbit(i) = i &amp; (-i).</span><br><span class="line">*</span><br><span class="line">*void add(int x, int value);</span><br><span class="line">*复杂度: O(logn)</span><br><span class="line">*输入: 	 x, value A[x]增加value</span><br><span class="line">*int get(int x)</span><br><span class="line">*复杂度: O(logn)</span><br><span class="line">*输入:	 x 查询A[1]~A[x]的和</span><br><span class="line">*输出:	 A[1]+...+A[x]</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxn为最大容量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> Tree[maxn+<span class="number">10</span>];</span><br><span class="line">inline <span class="keyword">int</span> lwbit(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">return</span> (x &amp; -x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add(<span class="keyword">int</span> x, <span class="keyword">int</span> value)&#123;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = x; i &lt;= maxn; i += lowbit(i))</span><br><span class="line">		Tree[i] += value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> get(<span class="keyword">int</span> x)&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>	(<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">		sum += Tree[i];</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="符号判断">符号判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*给定一个double类型的数,判断它的符号.</span><br><span class="line">*</span><br><span class="line">*因为计算几何中经常涉及精度问题,需要对一个很小的数判断正负,所以需要引入</span><br><span class="line">*一个极小量eps.</span><br><span class="line">*</span><br><span class="line">*返回值: -1表示x为负数,1表示x为正数,0表示x为0.</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维点类">二维点类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*设计一个二维点类,可以进行一些向量运算</span><br><span class="line">*</span><br><span class="line">*结构体:point</span><br><span class="line">*成员变量:</span><br><span class="line">*	double x, y		点的坐标</span><br><span class="line">*重载运算符:	+, -, *, /, ==</span><br><span class="line">*成员函数:</span><br><span class="line">*	input()		输入一个点</span><br><span class="line">*	norm()		计算向量的模长</span><br><span class="line">*相关函数:</span><br><span class="line">*	double sqr(double x)							计算一个数的平方</span><br><span class="line">*	double det(cosnt point &amp;a, const point &amp;b)		计算两个向量的叉积</span><br><span class="line">*	double dot(cosnt point &amp;a, const point &amp;b)		计算两个向量的点积</span><br><span class="line">*	double dist(cosnt point &amp;a, const point &amp;b)		计算两个点的距离</span><br><span class="line">*	point rotate_point(cosnt point &amp;p, double A)	向量&lt;OP&gt;绕原点逆时针旋转A(弧度)</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(-<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">inline <span class="keyword">double</span> sqr(<span class="keyword">double</span> x) &#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct <span class="built_in">point</span> &#123;</span><br><span class="line">	<span class="keyword">double</span> x, y;</span><br><span class="line">	<span class="built_in">point</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">point</span>(<span class="keyword">double</span> a, <span class="keyword">double</span> b): x(a), y(b) &#123;&#125;</span><br><span class="line">	<span class="keyword">void</span> input() &#123;</span><br><span class="line">		scanf(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator + (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x + b.x, a.y + b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator - (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x - b.x, a.y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend bool operator == (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> cmp(a.x - b.x) == <span class="number">0</span> &amp;&amp; cmp(a.y - b.y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator * (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x * b, a.y * b);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator * (<span class="keyword">const</span> <span class="keyword">double</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a * b.x, a * b.y);</span><br><span class="line">	&#125;</span><br><span class="line">	friend <span class="built_in">point</span> operator / (<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">point</span>(a.x / b, a.y / b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> <span class="built_in">norm</span>() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(x) + sqr(y));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> det(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.y - a.y * b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> dot(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> a.x * b.x + a.y * b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> <span class="built_in">dist</span>(<span class="keyword">const</span> <span class="built_in">point</span> &amp;a, <span class="keyword">const</span> <span class="built_in">point</span> &amp;b) &#123;</span><br><span class="line">	<span class="keyword">return</span> (a - b).<span class="built_in">norm</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">point</span> rotate_point(<span class="keyword">const</span> <span class="built_in">point</span> &amp;p, <span class="keyword">double</span> A) &#123;</span><br><span class="line">	<span class="keyword">double</span> tx = p.x, ty = p.y;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">point</span>(tx * <span class="built_in">cos</span>(A) - ty * <span class="built_in">sin</span>(A), tx * <span class="built_in">sin</span>(A) + ty * <span class="built_in">cos</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线段类">线段类</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现一个线段类,可以完成线段的一些计算几何运算.</span><br><span class="line">*</span><br><span class="line">*为了避免精度问题,且实现起来方便,线段用一个有向线段表示.线段类的运算也都使用</span><br><span class="line">*向量运算.在存储时,就存下线段上的两点,用a-&gt;b来表示有向线段.同样也可以用这种方</span><br><span class="line">*法来表示直线.</span><br><span class="line">*</span><br><span class="line">*结构体: line</span><br><span class="line">*成员变量:</span><br><span class="line">*		point a, b 线段的两个端点</span><br><span class="line">*相关函数:</span><br><span class="line">*		line point_make_line(const point a, const point b);</span><br><span class="line">*		用两个点a, b生成的一个线段或直线</span><br><span class="line">*		double dis_point_segment(const point p, const point s, const point t);</span><br><span class="line">*		求p点到线段st的距离</span><br><span class="line">*		void PointProjLine(const point p, const point s, const point t, point &amp; cp);</span><br><span class="line">*		求p点到线段st的垂足,保存在cp中.</span><br><span class="line">*		bool PointOnSegment(point p, point s, point t);</span><br><span class="line">*		判断p点是否在线段st上(包括端点)</span><br><span class="line">*		bool parallel(line a, line b);</span><br><span class="line">*		判断a和b是否平行</span><br><span class="line">*		bool line_make_point(line a, line b, point &amp;res);</span><br><span class="line">*		判断a和b是否相交,如果相交则返回true且交点保存在res中</span><br><span class="line">*		line move_d(line a, const double &amp;len);</span><br><span class="line">*		将直线a沿法向量方向平移距离len得到的直线</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line">struct <span class="built_in">line</span> &#123;</span><br><span class="line">	<span class="built_in">point</span> a, b;</span><br><span class="line">	<span class="built_in">line</span>() &#123;&#125;</span><br><span class="line">	<span class="built_in">line</span>(<span class="built_in">point</span> x, <span class="built_in">point</span> y): a(x), b(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">line</span> point_make_line(<span class="keyword">const</span> <span class="built_in">point</span> a, <span class="keyword">const</span> <span class="built_in">point</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">line</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> dis_point_segment(<span class="keyword">const</span> <span class="built_in">point</span> p, <span class="keyword">const</span> <span class="built_in">point</span> s, <span class="keyword">const</span> <span class="built_in">point</span> t) &#123;</span><br><span class="line">	<span class="keyword">if</span> (cmp(dot(p-s, t-s)) &lt; <span class="number">0</span>) <span class="keyword">return</span> (p-s).<span class="built_in">norm</span>();</span><br><span class="line">	<span class="keyword">if</span> (cmp(dot(p-t, s-t)) &lt; <span class="number">0</span>) <span class="keyword">return</span> (p-t).<span class="built_in">norm</span>();</span><br><span class="line">	<span class="keyword">return</span> fabs(det(s-p, t-p) / dot(t-s, t-s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> PointProjLine(<span class="keyword">const</span> <span class="built_in">point</span> p, <span class="keyword">const</span> <span class="built_in">point</span> s, <span class="keyword">const</span> <span class="built_in">point</span> t, <span class="built_in">point</span> &amp;cp) &#123;</span><br><span class="line">	<span class="keyword">double</span> r = dot((t-s), (p-s)) / dot(t-s, t-s);</span><br><span class="line">	cp = s + r * (t-s);</span><br><span class="line">&#125;</span><br><span class="line">bool PointOnSegment(<span class="built_in">point</span> p, <span class="built_in">point</span> s, <span class="built_in">point</span> t) &#123;</span><br><span class="line">	<span class="keyword">return</span> cmp(det(p-s, t-s)) == <span class="number">0</span> &amp;&amp; cmp(dot(p-s, p-t)) &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool parallel(<span class="built_in">line</span> a, <span class="built_in">line</span> b) &#123;</span><br><span class="line">	<span class="keyword">return</span> !cmp(det(a.a - a.b, b.a - b.b));</span><br><span class="line">&#125;</span><br><span class="line">bool line_make_point(<span class="built_in">line</span> a, <span class="built_in">line</span> b, <span class="built_in">point</span> &amp;res) &#123;</span><br><span class="line">	<span class="keyword">if</span> (parallel(a, b)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">double</span> s1 = det(a.a - b.a, b.b - b.a);</span><br><span class="line">	<span class="keyword">double</span> s2 = det(a.b - b.a, b.b - b.a);</span><br><span class="line">	res = (s1*a.b - s2*a.a) / (s1 - s2);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">lien move_d(<span class="built_in">line</span> a, <span class="keyword">const</span> <span class="keyword">double</span> &amp;len) &#123;</span><br><span class="line">	<span class="built_in">point</span> d = a.b - a.a;</span><br><span class="line">	d = d / d.<span class="built_in">norm</span>();</span><br><span class="line">	d = retate_point(d, pi/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">line</span>(a.a+d*len, a.b+d*len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多边形类">多边形类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span><br><span class="line">*实现一个多边形类,完成计算多边形的面积,重心等基本操作.</span><br><span class="line">*</span><br><span class="line">*判断点在多边形内:从该点做一条水平向右的射线,统计射线与多边形相交的情况,若相</span><br><span class="line">*交次数为偶数,则说明该点在形外,否则在形内.为了便于交点在顶点或射线与某些边重</span><br><span class="line">*合时的判断,可以将每条边看成左开右闭的线段,即若交点为左端点则不计算.</span><br><span class="line">*</span><br><span class="line">*结构体: polygon</span><br><span class="line">*成员变量:</span><br><span class="line">*	int n					多边形点数</span><br><span class="line">*	point a[]				多边形顶点坐标(按顺时针顺序)</span><br><span class="line">*成员函数:</span><br><span class="line">*	double perimeter()		计算多边形周长</span><br><span class="line">*	double area()			计算多边形面积</span><br><span class="line">*	int Point_In(point t);	判断点是否在多边形内部</span><br><span class="line">*	复杂度: O(N)</span><br><span class="line">*	输  入:	t	需要判断的点t</span><br><span class="line">*	输	出: 0 	表示t点在多边形外</span><br><span class="line">*			1	表示t点在多边形内</span><br><span class="line">*			2	表示t点在多边形的边界上</span><br><span class="line">*</span><br><span class="line">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">struct</span> polygon &#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	point a[maxn];</span><br><span class="line">	polygon() &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">perimeter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		a[n] = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += (a[i+<span class="number">1</span>] - a[i]).norm();</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">		a[n] = a[<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			sum += det(a[i+<span class="number">1</span>], a[i]);</span><br><span class="line">		<span class="keyword">return</span> sum/<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Point_In</span><span class="params">(point t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>, i, d1, d2, k;</span><br><span class="line">		a[n] = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (PointOnSergment(t, a[i], a[i+<span class="number">1</span>])) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">			k = cmp(det(a[i+<span class="number">1</span>]-a[i], t-a[i]));</span><br><span class="line">			d1 = cmp(a[i].y - t.y);</span><br><span class="line">			d2 = cmp(a[i+<span class="number">1</span>].y - t.y);</span><br><span class="line">			<span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) num++;</span><br><span class="line">			<span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) num--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num != <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里的模版基本来自《ACM国际大学生程序设计竞赛：算法与实现》这本书，有部分修改。</p>
<!-- toc -->
<h3 id="树链剖分">树链剖分</h3><figure class="highlight inform7"><table><tr><td class=]]>
    </summary>
    
      <category term="template" scheme="https://github.com/sillyplus/tags/template/"/>
    
      <category term="资源" scheme="https://github.com/sillyplus/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
</feed>
